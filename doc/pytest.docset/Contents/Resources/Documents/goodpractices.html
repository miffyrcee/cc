


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Good Integration Practices &#8212; pytest documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/pygments_pytest.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Flaky tests" href="flaky.html" />
    <link rel="prev" title="API Reference" href="reference.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = './';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="flaky.html" title="Flaky tests"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="reference.html" title="API Reference"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">pytest-6.2</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Good Integration Practices</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="good-integration-practices">
<span id="goodpractices"></span><h1>Good Integration Practices<a class="headerlink" href="#good-integration-practices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="install-package-with-pip">
<h2>Install package with pip<a class="headerlink" href="#install-package-with-pip" title="Permalink to this headline">¶</a></h2>
<p>For development, we recommend you use <a class="reference external" href="https://docs.python.org/3/library/venv.html">venv</a> for virtual environments and
<a class="reference external" href="https://pypi.org/project/pip/">pip</a> for installing your application and any dependencies,
as well as the <code class="docutils literal notranslate"><span class="pre">pytest</span></code> package itself.
This ensures your code and dependencies are isolated from your system Python installation.</p>
<p>Next, place a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file in the root of your package with the following minimum content:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;PACKAGENAME&quot;</span><span class="p">,</span> <span class="n">packages</span><span class="o">=</span><span class="n">find_packages</span><span class="p">())</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">PACKAGENAME</span></code> is the name of your package. You can then install your package in “editable” mode by running from the same directory:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip install -e .
</pre></div>
</div>
<p>which lets you change your source code (both tests and application) and rerun tests at will.
This is similar to running <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">develop</span></code> or <code class="docutils literal notranslate"><span class="pre">conda</span> <span class="pre">develop</span></code> in that it installs
your package using a symlink to your development code.</p>
</div>
<div class="section" id="conventions-for-python-test-discovery">
<span id="python-test-discovery"></span><span id="test-discovery"></span><h2>Conventions for Python test discovery<a class="headerlink" href="#conventions-for-python-test-discovery" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pytest</span></code> implements the following standard test discovery:</p>
<ul class="simple">
<li><p>If no arguments are specified then collection starts from <a class="reference internal" href="reference.html#confval-testpaths"><code class="xref std std-confval docutils literal notranslate"><span class="pre">testpaths</span></code></a>
(if configured) or the current directory. Alternatively, command line arguments
can be used in any combination of directories, file names or node ids.</p></li>
<li><p>Recurse into directories, unless they match <a class="reference internal" href="reference.html#confval-norecursedirs"><code class="xref std std-confval docutils literal notranslate"><span class="pre">norecursedirs</span></code></a>.</p></li>
<li><p>In those directories, search for <code class="docutils literal notranslate"><span class="pre">test_*.py</span></code> or <code class="docutils literal notranslate"><span class="pre">*_test.py</span></code> files, imported by their <a class="reference internal" href="#test-package-name">test package name</a>.</p></li>
<li><p>From those files, collect test items:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">test</span></code> prefixed test functions or methods outside of class</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">test</span></code> prefixed test functions or methods inside <code class="docutils literal notranslate"><span class="pre">Test</span></code> prefixed test classes (without an <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method)</p></li>
</ul>
</li>
</ul>
<p>For examples of how to customize your test discovery <a class="reference internal" href="example/pythoncollection.html"><span class="doc">Changing standard (Python) test discovery</span></a>.</p>
<p>Within Python modules, <code class="docutils literal notranslate"><span class="pre">pytest</span></code> also discovers tests using the standard
<a class="reference internal" href="unittest.html#unittest-testcase"><span class="std std-ref">unittest.TestCase</span></a> subclassing technique.</p>
</div>
<div class="section" id="choosing-a-test-layout-import-rules">
<h2>Choosing a test layout / import rules<a class="headerlink" href="#choosing-a-test-layout-import-rules" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pytest</span></code> supports two common test layouts:</p>
<div class="section" id="tests-outside-application-code">
<h3>Tests outside application code<a class="headerlink" href="#tests-outside-application-code" title="Permalink to this headline">¶</a></h3>
<p>Putting tests into an extra directory outside your actual application code
might be useful if you have many functional tests or for other reasons want
to keep tests separate from actual application code (often a good idea):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>setup.py
mypkg/
    __init__.py
    app.py
    view.py
tests/
    test_app.py
    test_view.py
    ...
</pre></div>
</div>
<p>This has the following benefits:</p>
<ul class="simple">
<li><p>Your tests can run against an installed version after executing <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">.</span></code>.</p></li>
<li><p>Your tests can run against the local copy with an editable install after executing <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--editable</span> <span class="pre">.</span></code>.</p></li>
<li><p>If you don’t have a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file and are relying on the fact that Python by default puts the current
directory in <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> to import your package, you can execute <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">pytest</span></code> to execute the tests against the
local copy directly, without using <code class="docutils literal notranslate"><span class="pre">pip</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See <a class="reference internal" href="pythonpath.html#pytest-vs-python-m-pytest"><span class="std std-ref">Invoking pytest versus python -m pytest</span></a> for more information about the difference between calling <code class="docutils literal notranslate"><span class="pre">pytest</span></code> and
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">pytest</span></code>.</p>
</div>
<p>Note that this scheme has a drawback if you are using <code class="docutils literal notranslate"><span class="pre">prepend</span></code> <a class="reference internal" href="pythonpath.html#import-modes"><span class="std std-ref">import mode</span></a>
(which is the default): your test files must have <strong>unique names</strong>, because
<code class="docutils literal notranslate"><span class="pre">pytest</span></code> will import them as <em>top-level</em> modules since there are no packages
to derive a full package name from. In other words, the test files in the example above will
be imported as <code class="docutils literal notranslate"><span class="pre">test_app</span></code> and <code class="docutils literal notranslate"><span class="pre">test_view</span></code> top-level modules by adding <code class="docutils literal notranslate"><span class="pre">tests/</span></code> to
<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>.</p>
<p>If you need to have test modules with the same name, you might add <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> files to your
<code class="docutils literal notranslate"><span class="pre">tests</span></code> folder and subfolders, changing them to packages:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>setup.py
mypkg/
    ...
tests/
    __init__.py
    foo/
        __init__.py
        test_view.py
    bar/
        __init__.py
        test_view.py
</pre></div>
</div>
<p>Now pytest will load the modules as <code class="docutils literal notranslate"><span class="pre">tests.foo.test_view</span></code> and <code class="docutils literal notranslate"><span class="pre">tests.bar.test_view</span></code>, allowing
you to have modules with the same name. But now this introduces a subtle problem: in order to load
the test modules from the <code class="docutils literal notranslate"><span class="pre">tests</span></code> directory, pytest prepends the root of the repository to
<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, which adds the side-effect that now <code class="docutils literal notranslate"><span class="pre">mypkg</span></code> is also importable.</p>
<p>This is problematic if you are using a tool like <a class="reference internal" href="#tox">tox</a> to test your package in a virtual environment,
because you want to test the <em>installed</em> version of your package, not the local code from the repository.</p>
<p id="src-layout">In this situation, it is <strong>strongly</strong> suggested to use a <code class="docutils literal notranslate"><span class="pre">src</span></code> layout where application root package resides in a
sub-directory of your root:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>setup.py
src/
    mypkg/
        __init__.py
        app.py
        view.py
tests/
    __init__.py
    foo/
        __init__.py
        test_view.py
    bar/
        __init__.py
        test_view.py
</pre></div>
</div>
<p>This layout prevents a lot of common pitfalls and has many benefits, which are better explained in this excellent
<a class="reference external" href="https://blog.ionelmc.ro/2014/05/25/python-packaging/#the-structure">blog post by Ionel Cristian Mărieș</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new <code class="docutils literal notranslate"><span class="pre">--import-mode=importlib</span></code> (see <a class="reference internal" href="pythonpath.html#import-modes"><span class="std std-ref">Import modes</span></a>) doesn’t have
any of the drawbacks above because <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> and <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> are not changed when importing
test modules, so users that run
into this issue are strongly encouraged to try it and report if the new option works well for them.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">src</span></code> directory layout is still strongly recommended however.</p>
</div>
</div>
<div class="section" id="tests-as-part-of-application-code">
<h3>Tests as part of application code<a class="headerlink" href="#tests-as-part-of-application-code" title="Permalink to this headline">¶</a></h3>
<p>Inlining test directories into your application package
is useful if you have direct relation between tests and application modules and
want to distribute them along with your application:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>setup.py
mypkg/
    __init__.py
    app.py
    view.py
    test/
        __init__.py
        test_app.py
        test_view.py
        ...
</pre></div>
</div>
<p>In this scheme, it is easy to run your tests using the <code class="docutils literal notranslate"><span class="pre">--pyargs</span></code> option:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pytest --pyargs mypkg
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pytest</span></code> will discover where <code class="docutils literal notranslate"><span class="pre">mypkg</span></code> is installed and collect tests from there.</p>
<p>Note that this layout also works in conjunction with the <code class="docutils literal notranslate"><span class="pre">src</span></code> layout mentioned in the previous section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can use Python3 namespace packages (PEP420) for your application
but pytest will still perform <a class="reference internal" href="#test-package-name">test package name</a> discovery based on the
presence of <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> files.  If you use one of the
two recommended file system layouts above but leave away the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
files from your directories it should just work on Python3.3 and above.  From
“inlined tests”, however, you will need to use absolute imports for
getting at your application code.</p>
</div>
<div class="admonition note" id="test-package-name">
<p class="admonition-title">Note</p>
<p>In <code class="docutils literal notranslate"><span class="pre">prepend</span></code> and <code class="docutils literal notranslate"><span class="pre">append</span></code> import-modes, if pytest finds a <code class="docutils literal notranslate"><span class="pre">&quot;a/b/test_module.py&quot;</span></code>
test file while recursing into the filesystem it determines the import name
as follows:</p>
<ul class="simple">
<li><p>determine <code class="docutils literal notranslate"><span class="pre">basedir</span></code>: this is the first “upward” (towards the root)
directory not containing an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.  If e.g. both <code class="docutils literal notranslate"><span class="pre">a</span></code>
and <code class="docutils literal notranslate"><span class="pre">b</span></code> contain an <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file then the parent directory
of <code class="docutils literal notranslate"><span class="pre">a</span></code> will become the <code class="docutils literal notranslate"><span class="pre">basedir</span></code>.</p></li>
<li><p>perform <code class="docutils literal notranslate"><span class="pre">sys.path.insert(0,</span> <span class="pre">basedir)</span></code> to make the test module
importable under the fully qualified import name.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">a.b.test_module</span></code> where the path is determined
by converting path separators <code class="docutils literal notranslate"><span class="pre">/</span></code> into “.” characters.  This means
you must follow the convention of having directory and file
names map directly to the import names.</p></li>
</ul>
<p>The reason for this somewhat evolved importing technique is
that in larger projects multiple test modules might import
from each other and thus deriving a canonical import name helps
to avoid surprises such as a test module getting imported twice.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">--import-mode=importlib</span></code> things are less convoluted because
pytest doesn’t need to change <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> or <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>, making things
much less surprising.</p>
</div>
</div>
</div>
<div class="section" id="tox">
<span id="use-tox"></span><h2>tox<a class="headerlink" href="#tox" title="Permalink to this headline">¶</a></h2>
<p>Once you are done with your work and want to make sure that your actual
package passes all tests you may want to look into <a class="reference internal" href="#tox">tox</a>, the
virtualenv test automation tool and its <a class="reference external" href="https://tox.readthedocs.io/en/latest/example/pytest.html">pytest support</a>.
tox helps you to setup virtualenv environments with pre-defined
dependencies and then executing a pre-configured test command with
options.  It will run tests against the installed package and not
against your source code checkout, helping to detect packaging
glitches.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015–2020, holger krekel and pytest-dev team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  <script src="_static/version_warning_offset.js"></script>

  </body>
</html>