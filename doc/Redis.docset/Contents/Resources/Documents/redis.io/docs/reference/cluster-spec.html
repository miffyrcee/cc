<html><!-- Online page at https://redis.io/docs/reference/cluster-spec/ --><head><meta charset="utf-8"><title>Redis cluster specification</title><link rel="stylesheet" href="../../css_1.css" type="text/css"><link rel="stylesheet" href="../../css_2.css" type="text/css"><link rel="stylesheet" href="../../css_3.css" type="text/css"><link rel="stylesheet" href="../../css_4.css" type="text/css"><link rel="stylesheet" href="../../css_5.css" type="text/css"><script type="text/javascript" src="../../js_1.js"></script><script type="text/javascript" src="../../js_10.js"></script><script type="text/javascript" src="../../js_3.js"></script><script type="text/javascript" src="../../js_4.js"></script><script type="text/javascript" src="../../js_5.js"></script><script type="text/javascript" src="../../js_6.js"></script><script type="text/javascript" src="../../js_7.js"></script><script type="text/javascript" src="../../js_8.js"></script><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style><style>
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      </style></head><body class="antialiased tracking-[-0.01em]">
    <noscript>&amp;amp;amp;amp;amp;amp;amp;amp;amp;lt;iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T4MTBKP"
        height="0" width="0" style="display:none;visibility:hidden"&amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;&amp;amp;amp;amp;amp;amp;amp;amp;amp;lt;/iframe&amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;</noscript>
    <header class="sticky top-0 z-50 flex items-center w-full text-xs lg:text-sm font-semibold lg:font-medium text-white shadow bg-midnight-700">
      <div class="flex items-center w-full h-16 container max-w-[85rem] mx-auto px-4 sm:px-8">
  <a class="relative z-50 mr-auto" href="../../../redis.io.html">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 368.69 125.59" class="w-auto h-8">
  <defs>
    <style>
      .cls-1 {
        fill: none;
      }

      .cls-2 {
        clip-path: url(#clip-path);
      }

      .cls-3 {
        fill: #a32422;
      }

      .cls-4 {
        fill: #dc382c;
      }

      .cls-5 {
        fill: #fff;
      }

      .cls-6 {
        fill: #741113;
      }

      .cls-7 {
        fill: #ac2724;
      }
    </style>
    <clipPath id="clip-path" transform="translate(0.01 0.01)">
      <rect class="cls-1" width="146.42" height="125.48"></rect>
    </clipPath>
  </defs>
  <g id="Layer_2" data-name="Layer 2">
    <g id="Layer_1-2" data-name="Layer 1">
      <g class="cls-2">
        <path class="cls-3" d="M140.66,96.74c-7.8,4.08-48.28,20.73-57,25.3s-13.39,4.44-20.21,1.18S13.7,102.5,5.92,98.78C2,96.94,0,95.37,0,93.9V79.09S56.08,66.92,65.13,63.64,77.31,60.28,85,63.1,138.79,74.24,146.4,77V91.6c0,1.52-1.75,3-5.74,5.13Z" transform="translate(0.01 0.01)"></path>
        <path class="cls-4" d="M140.66,82c-7.8,4.06-48.28,20.71-57,25.2s-13.39,4.45-20.21,1.2S13.7,87.69,5.92,84s-7.93-6.27-.3-9.25S56.08,55,65.13,51.7,77.31,48.33,85,51.16,133,70,140.57,72.79s7.92,5.08.09,9.13Z" transform="translate(0.01 0.01)"></path>
        <path class="cls-3" d="M140.66,72.62c-7.8,4.07-48.28,20.71-57,25.2S70.31,102.27,63.49,99,13.7,78.37,5.92,74.66C2,72.8,0,71.24,0,69.76V55S56.08,42.79,65.13,39.51,77.31,36.14,85,39,138.79,50.1,146.4,52.88v14.6C146.4,69,144.65,70.52,140.66,72.62Z" transform="translate(0.01 0.01)"></path>
        <path class="cls-4" d="M140.66,57.81c-7.8,4.08-48.28,20.72-57,25.21s-13.39,4.46-20.21,1.2S13.7,63.57,5.92,59.85-2,53.6,5.62,50.62s50.46-19.79,59.51-23S77.31,24.21,85,27,133,45.94,140.57,48.65s7.92,5.09.09,9.13Z" transform="translate(0.01 0.01)"></path>
        <path class="cls-3" d="M140.66,47.59c-7.8,4.08-48.28,20.73-57,25.21S70.31,77.25,63.49,74,13.7,53.34,5.92,49.63C2,47.79,0,46.22,0,44.74V29.93S56.08,17.76,65.13,14.49,77.31,11.12,85,13.94s53.77,11.14,61.38,13.92v14.6C146.4,44,144.65,45.5,140.66,47.59Z" transform="translate(0.01 0.01)"></path>
        <path class="cls-4" d="M140.66,32.8c-7.8,4-48.28,20.75-57,25.2s-13.39,4.44-20.21,1.2S13.7,38.53,5.92,34.83s-7.93-6.27-.3-9.25S56.08,5.8,65.13,2.54,77.31-.82,85,2,133,20.85,140.57,23.63s7.92,5.09.09,9.14Z" transform="translate(0.01 0.01)"></path>
      </g>
      <polygon class="cls-5" points="75.51 11.78 85.17 8.61 82.55 14.87 92.38 18.55 79.71 19.87 76.86 26.71 72.28 19.08 57.63 17.76 68.57 13.82 65.28 7.76 75.51 11.78 75.51 11.78 75.51 11.78"></polygon>
      <polygon class="cls-5" points="76.12 51.71 52.44 41.88 86.36 36.67 76.12 51.71 76.12 51.71 76.12 51.71"></polygon>
      <path class="cls-5" d="M43.28,22.34c10,0,18.13,3.15,18.13,7s-8.15,7-18.13,7-18.14-3.15-18.14-7S33.27,22.34,43.28,22.34Z" transform="translate(0.01 0.01)"></path>
      <polygon class="cls-6" points="107.39 20.42 127.46 28.35 107.41 36.28 107.39 20.42 107.39 20.42 107.39 20.42"></polygon>
      <polygon class="cls-7" points="107.39 20.42 107.41 36.28 105.23 37.13 85.17 29.2 107.39 20.42 107.39 20.42 107.39 20.42"></polygon>
      <path class="cls-5" d="M193,41.4a17.36,17.36,0,0,1,6.23-4.34,20,20,0,0,1,7.3-1.61,6.71,6.71,0,0,1,5,1.61,5,5,0,0,1,1.52,3.79,5.39,5.39,0,0,1-1.52,3.79,4.9,4.9,0,0,1-3.79,1.63c-6.24.55-14.9,6.77-14.9,15.22V80.67a5.57,5.57,0,0,1-5.42,5.41,4.92,4.92,0,0,1-3.87-1.67,5.36,5.36,0,0,1-1.62-3.79v-40a5.35,5.35,0,0,1,1.62-3.79,7.2,7.2,0,0,1,4.07-1.36,5.52,5.52,0,0,1,5.41,5.4Z" transform="translate(0.01 0.01)"></path>
      <path class="cls-5" d="M258.71,59a5.25,5.25,0,0,1-1.35,3.54,6.11,6.11,0,0,1-3.79,1.62h-32a10.31,10.31,0,0,0,3.47,6.56,14.46,14.46,0,0,0,9.48,4.57,14.07,14.07,0,0,0,10.56-2.44,5.52,5.52,0,0,1,4.07-1.63,4.65,4.65,0,0,1,3.51,1.36,4.41,4.41,0,0,1,.26,6.24c-.08.09-.17.17-.26.26a24.49,24.49,0,0,1-17.59,6.5A23,23,0,0,1,217.5,78a26.67,26.67,0,0,1-7.3-17.9,24.31,24.31,0,0,1,7.3-17.88,22.59,22.59,0,0,1,17.06-7.31,22,22,0,0,1,16.74,6.78,24.78,24.78,0,0,1,7.61,16.74v.53Zm-24.1-14.35a14.2,14.2,0,0,0-9.13,3.53,13.17,13.17,0,0,0-4.33,7h28.43a12.39,12.39,0,0,0-4.88-6.76,17.3,17.3,0,0,0-10-3.81" transform="translate(0.01 0.01)"></path>
      <path class="cls-5" d="M309.66,80.12a5.57,5.57,0,0,1-5.41,5.42,5.85,5.85,0,0,1-5.42-4.34A23.23,23.23,0,0,1,285,85.54a23.57,23.57,0,0,1-17.33-7.31,24.14,24.14,0,0,1-7.05-17.88,25.75,25.75,0,0,1,7.05-17.87A23.85,23.85,0,0,1,285,34.87a22.34,22.34,0,0,1,13.53,4.34V20.28a4.92,4.92,0,0,1,1.63-3.79A5.37,5.37,0,0,1,304,14.86a4.92,4.92,0,0,1,3.79,1.63,5.36,5.36,0,0,1,1.63,3.79V80.12ZM285.31,74.7a12,12,0,0,0,9.47-4.32,14.4,14.4,0,0,0,0-20A13,13,0,0,0,285.31,46a11.65,11.65,0,0,0-9.48,4.34,14.4,14.4,0,0,0,0,20,12.49,12.49,0,0,0,9.48,4.32" transform="translate(0.01 0.01)"></path>
      <path class="cls-5" d="M325.67,20.28v2.18A5.5,5.5,0,0,1,324,26.58a4.64,4.64,0,0,1-3.79,1.35,4.86,4.86,0,0,1-3.78-1.61,5.44,5.44,0,0,1-1.63-4.06v-2a5.28,5.28,0,0,1,1.63-3.79,5.33,5.33,0,0,1,3.78-1.63A5,5,0,0,1,324,16.49a4.9,4.9,0,0,1,1.66,3.79m-9.13,16.53a5.28,5.28,0,0,1,3.79-1.63,4.85,4.85,0,0,1,3.79,1.63,5.48,5.48,0,0,1,1.55,4V80.42A4.55,4.55,0,0,1,324,84.21a5.33,5.33,0,0,1-3.78,1.63,4.9,4.9,0,0,1-3.79-1.63,5.28,5.28,0,0,1-1.63-3.79V40.85a5.39,5.39,0,0,1,1.63-4" transform="translate(0.01 0.01)"></path>
      <path class="cls-5" d="M364.08,40.6a5.29,5.29,0,0,1,2.17,3.24,7.17,7.17,0,0,1-.54,4.06,5.4,5.4,0,0,1-3.25,2.16,5.61,5.61,0,0,1-4.07-.81c-3.79-2.43-6.75-3.78-9.2-3.78a8.74,8.74,0,0,0-6,1.88c-1.08.82-1.62,1.36-1.62,1.9a2,2,0,0,0,.27,1.36,3.74,3.74,0,0,0,1.08.81,16.19,16.19,0,0,0,7.32,2.43h0a37.75,37.75,0,0,1,9.74,3,13.57,13.57,0,0,1,6.5,5.7,13.46,13.46,0,0,1-4.06,18.67,21.79,21.79,0,0,1-13,4.06c-6.23,0-12.18-2.43-17.87-7a5.77,5.77,0,0,1-1.9-3.53,5.2,5.2,0,0,1,8.4-4.56,15.73,15.73,0,0,0,11.1,4.33,11.61,11.61,0,0,0,6.77-1.9c1.08-1.08,1.9-1.89,1.9-2.71s0-1.08-.27-1.35c0-.28-.55-.81-1.36-1.08a20.15,20.15,0,0,0-8.13-2.86h0a28.26,28.26,0,0,1-9.2-3,16.56,16.56,0,0,1-6.5-5.67,12.61,12.61,0,0,1-1.61-6.23,13.3,13.3,0,0,1,5.95-11.11,21.82,21.82,0,0,1,12.45-3.79c4.56.28,9.48,2.16,14.89,5.69" transform="translate(0.01 0.01)"></path>
    </g>
  </g>
</svg>
  </a>

	<nav data-menu="" class="hidden lg:flex items-center justify-center content-start lg:content-center lg:gap-y-4 flex-1 z-40 fixed inset-0 lg:static bg-slate-900 lg:bg-transparent text-sm max-h-screen lg:max-w-none pt-20 pb-8 lg:py-0 overflow-y-auto lg:overflow-y-visible">
    
    
      

        
        <a href="../getting-started.html" class="hidden uppercase rounded-sm lg:flex items-center justify-items-center first:ml-auto ml-1 px-3 py-2 rounded bg-transparent hover:text-white/50 focus:text-white/50 whitespace-nowrap transition-colors">
          
          
          Get started
        </a>

        
        <a href="../getting-started.html" class="flex lg:hidden items-center mt-1.5">
          Get started
        </a>
      
    
      
        
        
        <dl class="hidden lg:flex group relative first:ml-auto ml-1 mt-3 mb-0 px-3 pt-2 pb-5 cursor-pointer">
          <dt class="sr-only uppercase lg:not-sr-only flex items-center justify-items-center group-hover:text-white/50 group-focus-within:text-white/50 whitespace-nowrap transition-colors" href="#">
            
            Docs
          </dt>
          <dd class="hidden lg:grid text-[0.8rem] lg:text-sm text-redis-neutral-800 absolute top-full -mt-1 right-[1000rem] p-2 group-hover:right-[unset] group-hover:-left-3 group-focus-within:right-[unset] group-focus-within:-left-3 bg-white rounded-lg border border-slate-500/10 bg-clip-padding shadow-md">
            
              
                <div class="-my-2 pr-3 py-4 col-start-1  pl-3 ">
                  <a href="../about.html" class=" font-semibold text-[0.9375rem] text-slate-900 flex items-center whitespace-nowrap min-w-[10rem] hover:text-slate-600 focus:text-slate-600 transition-colors">
                    
                      <span class="grid place-items-center w-5 h-5 mr-2.5">
                        
                        <svg viewBox="0 0 147 126" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M140.708 96.7107c-7.81 4.0703-48.2904 20.7203-57.0004 25.2903C74.9976 126.571 70.3176 126.441 63.4976 123.191s-49.8-20.73-57.57002-24.4403C2.04758 96.9007.00756836 95.3407.00756836 93.8607V79.0508S56.0876 66.8807 65.1376 63.6107 77.3176 60.2406 85.0276 63.0606C92.7376 65.8806 138.798 74.2007 146.408 76.9807V91.5606C146.408 93.0806 144.658 94.5606 140.668 96.6907L140.708 96.7107z" fill="#a32422"></path><path d="M140.708 81.9108C132.898 85.9808 92.4176 102.631 83.7076 107.121 74.9976 111.611 70.3176 111.561 63.4976 108.321c-6.82-3.24-49.8-20.6703-57.57001-24.3703-7.77-3.7-7.92999-6.27-.30999-9.25s50.47-19.78 59.52-23S77.3176 48.3408 85.0276 51.1708C92.7376 54.0008 132.968 70.0108 140.578 72.7908 148.188 75.5708 148.488 77.8808 140.668 81.9208L140.708 81.9108z" fill="#dc382c"></path><path d="M140.708 72.5807C132.898 76.6507 92.4176 93.3008 83.7076 97.7908 74.9976 102.281 70.3176 102.231 63.4976 98.9907 56.6776 95.7507 13.6976 78.3407 5.92758 74.6207 2.04758 72.7707.00756836 71.2007.00756836 69.7207V54.9306S56.0876 42.7607 65.1376 39.4707 77.3176 36.1107 85.0276 38.9407C92.7376 41.7707 138.798 50.0607 146.408 52.8507v14.64C146.488 68.9607 144.698 70.4907 140.708 72.5807z" fill="#a32422"></path><path d="M140.708 57.7808c-7.81 4.08-48.2904 20.7099-57.0004 25.1999S70.3176 87.4407 63.4976 84.1807s-49.8-20.65-57.57001-24.36C-1.84241 56.1107-2.0024 53.5607 5.6176 50.5807s50.47-19.78 59.52-23S77.3176 24.2208 85.0276 27.0308C92.7376 29.8408 132.968 45.9508 140.578 48.6608 148.188 51.3708 148.488 53.7408 140.668 57.7908L140.708 57.7808z" fill="#dc382c"></path><path d="M140.708 47.5508c-7.81 4.08-48.2904 20.73-57.0004 25.22C74.9976 77.2608 70.3176 77.2107 63.4976 73.9507 56.6776 70.6907 13.6976 53.3007 5.92758 49.5907c-3.88-1.84-5.92001164-3.41-5.92001164-4.89V29.9008S56.0876 17.7207 65.1376 14.4507c9.05-3.27 12.18-3.3599 19.89-.549899999999999C92.7376 16.7108 138.798 25.0407 146.408 27.8307V42.4208C146.488 43.9408 144.698 45.4908 140.708 47.5508z" fill="#a32422"></path><path d="M140.708 32.7607c-7.81 4-48.2904 20.7599-57.0004 25.1999s-13.39 4.4401-20.21 1.2001-49.8-20.66-57.57001-24.36c-7.77-3.7-7.92999-6.27-.30999-9.26 7.62-2.99 50.47-19.77998 59.52-22.99998 9.05-3.219996 12.18-3.360025 19.89-.53003C92.7376 4.84069 132.968 20.8507 140.578 23.6407 148.188 26.4307 148.488 28.7207 140.668 32.7707L140.708 32.7607z" fill="#dc382c"></path><path d="M140.708 96.7107c-7.81 4.0703-48.2904 20.7203-57.0004 25.2903C74.9976 126.571 70.3176 126.441 63.4976 123.191s-49.8-20.73-57.57002-24.4403C2.04758 96.9007.00756836 95.3407.00756836 93.8607V79.0508S56.0876 66.8807 65.1376 63.6107 77.3176 60.2406 85.0276 63.0606C92.7376 65.8806 138.798 74.2007 146.408 76.9807V91.5606C146.408 93.0806 144.658 94.5606 140.668 96.6907L140.708 96.7107z" fill="#a32422"></path><path d="M140.708 81.9108C132.898 85.9808 92.4176 102.631 83.7076 107.121 74.9976 111.611 70.3176 111.561 63.4976 108.321c-6.82-3.24-49.8-20.6703-57.57001-24.3703-7.77-3.7-7.92999-6.27-.30999-9.25s50.47-19.78 59.52-23S77.3176 48.3408 85.0276 51.1708C92.7376 54.0008 132.968 70.0108 140.578 72.7908 148.188 75.5708 148.488 77.8808 140.668 81.9208L140.708 81.9108z" fill="#dc382c"></path><path d="M140.708 72.5807C132.898 76.6507 92.4176 93.3008 83.7076 97.7908 74.9976 102.281 70.3176 102.231 63.4976 98.9907 56.6776 95.7507 13.6976 78.3407 5.92758 74.6207 2.04758 72.7707.00756836 71.2007.00756836 69.7207V54.9306S56.0876 42.7607 65.1376 39.4707 77.3176 36.1107 85.0276 38.9407C92.7376 41.7707 138.798 50.0607 146.408 52.8507v14.64C146.488 68.9607 144.698 70.4907 140.708 72.5807z" fill="#a32422"></path><path d="M140.708 57.7808c-7.81 4.08-48.2904 20.7099-57.0004 25.1999S70.3176 87.4407 63.4976 84.1807s-49.8-20.65-57.57001-24.36C-1.84241 56.1107-2.0024 53.5607 5.6176 50.5807s50.47-19.78 59.52-23S77.3176 24.2208 85.0276 27.0308C92.7376 29.8408 132.968 45.9508 140.578 48.6608 148.188 51.3708 148.488 53.7408 140.668 57.7908L140.708 57.7808z" fill="#dc382c"></path><path d="M140.708 47.5508c-7.81 4.08-48.2904 20.73-57.0004 25.22C74.9976 77.2608 70.3176 77.2107 63.4976 73.9507 56.6776 70.6907 13.6976 53.3007 5.92758 49.5907c-3.88-1.84-5.92001164-3.41-5.92001164-4.89V29.9008S56.0876 17.7207 65.1376 14.4507c9.05-3.27 12.18-3.3599 19.89-.549899999999999C92.7376 16.7108 138.798 25.0407 146.408 27.8307V42.4208C146.488 43.9408 144.698 45.4908 140.708 47.5508z" fill="#a32422"></path><path d="M140.708 32.7607c-7.81 4-48.2904 20.7599-57.0004 25.1999s-13.39 4.4401-20.21 1.2001-49.8-20.66-57.57001-24.36c-7.77-3.7-7.92999-6.27-.30999-9.26 7.62-2.99 50.47-19.77998 59.52-22.99998 9.05-3.219996 12.18-3.360025 19.89-.53003C92.7376 4.84069 132.968 20.8507 140.578 23.6407 148.188 26.4307 148.488 28.7207 140.668 32.7707L140.708 32.7607z" fill="#dc382c"></path><path d="M75.5476 11.7307l9.66-3.17-2.62 6.26 9.83 3.68-12.67 1.32L76.8976 26.6607l-4.58-7.63-14.65-1.32 10.94-3.94L65.3176 7.71069l10.23 4.02001z" fill="#fff"></path><path d="M76.1575 51.6607l-23.68-9.83 33.92-5.2-10.24 15.03z" fill="#fff"></path><path d="M43.3276 22.3008c10 0 18.12 3.15 18.12 7s-8.14 7-18.12 7c-9.98.0-18.14-3.15000000000001-18.14-7s8.13-7 18.14-7z" fill="#fff"></path><path d="M107.428 20.3707l20.07 7.93-20.05 7.93L107.428 20.3707z" fill="#741113"></path><path d="M107.428 20.3707 107.448 36.2307 105.268 37.0807l-20.0605-7.93 22.2205-8.78z" fill="#ac2724"></path></svg>
                      </span>
                    
                    Redis
                  </a>
                  
                    <a href="../getting-started.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Get started
                    </a>
                  
                    <a href="../data-types.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Data types
                    </a>
                  
                    <a href="../ui/cli.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Redis CLI
                    </a>
                  
                    <a href="../clients.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Redis clients
                    </a>
                  
                    <a href="../management/persistence.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Persistence
                    </a>
                  
                    <a href="../management/scaling.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Scaling
                    </a>
                  
                </div>
              
            
              
                <div class="-my-2 pr-3 py-4 col-start-2  border-l pl-5 ">
                  <a href="../stack.html" class=" font-semibold text-[0.9375rem] text-slate-900 flex items-center whitespace-nowrap min-w-[10rem] hover:text-slate-600 focus:text-slate-600 transition-colors">
                    
                      <span class="grid place-items-center w-5 h-5 mr-2.5">
                        
                        <svg viewBox="0 0 39 31" fill="none"><path d="M21.7371 15.2903C21.5759 15.2895 21.4198 15.2337 21.2947 15.1321 21.1695 15.0305 21.0828 14.8892 21.049 14.7316S21.0362 14.4096 21.1086 14.2655C21.1811 14.1215 21.3005 14.0066 21.4472 13.9397L35.7199 7.47338 21.4578 1.34289C21.2943 1.26329 21.1678 1.12377 21.1045.953307 21.0412.78285 21.046.594558 21.1179.427547 21.1898.260535 21.3233.127641 21.4906.0564719 21.6579-.0146977 21.8462-.0186728 22.0164.045373L37.7492 6.80518C37.8747 6.8605 37.9814 6.95112 38.0563 7.06599S38.171 7.31503 38.171 7.45216 38.1312 7.72347 38.0563 7.83834C37.9814 7.95321 37.8747 8.04383 37.7492 8.09915L22.0306 15.2266C21.9388 15.2698 21.8385 15.2916 21.7371 15.2903z" fill="#db2e2e"></path><path d="M16.4339 15.2903C16.3379 15.2906 16.2429 15.2714 16.1546 15.2337L.421813 8.47393C.296339 8.41861.18966 8.32799.114767 8.21312.0398745 8.09825.0 7.96407.0 7.82694.0 7.68981.0398745 7.55564.114767 7.44077.18966 7.3259.296339 7.23528.421813 7.17995L16.1546.052465C16.3235-.0111265 16.5104-.00772359 16.6768.0619772 16.8433.131678 16.9768.2624 17.0501.427363 17.1233.592325 17.1306.779042 17.0706.949259 17.0106 1.11948 16.8878 1.26031 16.7274 1.34291L2.44763 7.80573 16.7132 13.9362C16.8612 14.0015 16.9823 14.1154 17.0565 14.2592 17.1306 14.4029 17.1532 14.5677 17.1205 14.7261 17.0878 14.8845 17.0019 15.0269 16.8769 15.1295 16.752 15.2322 16.5956 15.2889 16.4339 15.2903z" fill="#db2e2e"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M29.1651 17.4328c3.1288-1.2763 6.2047-2.5279 7.1875-3.0617L37.1163 13.9539C37.3908 13.8108 37.6564 13.6514 37.9118 13.4766 37.972 13.8833 37.972 14.2967 37.9118 14.7034 37.8022 15.1312 37.4875 15.4847 36.289 16.061 35.4617 16.4605 33.1531 17.408 30.5792 18.4687c-3.6167 1.4884-7.778 3.1819-9.0826 3.889C19.2587 23.4183 18.0284 23.4183 16.3137 22.644 15.4864 22.2021 12.4918 20.9117 9.39476 19.5611c-3.3198-1.446-6.75627-2.945-7.77802-3.4753C.22377 15.3575.153061 15.1948.160132 14.8271V13.8655L.513678 14.0564c1.311652.6647 7.219412 3.1819 11.486722 5.0204 2.1142.898 3.8112 1.6298 4.3769 1.8844C18.092 21.7319 19.3082 21.8733 21.5603 20.6748 22.7022 20.0808 25.9619 18.7409 29.1651 17.4328z" fill="#494c4d"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M29.1651 24.5037c3.1288-1.2763 6.2047-2.5279 7.1875-3.0617L37.1163 21.0248C37.3908 20.8817 37.6564 20.7223 37.9118 20.5475 37.972 20.9542 37.972 21.3676 37.9118 21.7743 37.8022 22.2021 37.4875 22.5557 36.289 23.1319 35.4617 23.5314 33.1531 24.4789 30.5792 25.5396c-3.6167 1.4884-7.778 3.1819-9.0826 3.889-2.2379 1.0606-3.4682 1.0606-5.1829.2864C15.4864 29.2801 12.4918 27.9755 9.39476 26.625c-3.3198-1.446-6.75627-2.9451-7.77802-3.4754C.22377 22.4213.153061 22.2587.160132 21.891V20.9364L.513678 21.1273C1.82533 21.792 7.73309 24.3092 12.0004 26.1477c2.1001.898 3.8006 1.6298 4.3663 1.8844C18.0814 28.8028 19.2976 28.9442 21.5497 27.7457 22.7022 27.1518 25.9619 25.8118 29.1651 24.5037z" fill="#494c4d"></path></svg>
                      </span>
                    
                    Redis Stack
                  </a>
                  
                    <a href="../stack/get-started.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Get started
                    </a>
                  
                    <a href="../stack/get-started/clients.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Stack clients
                    </a>
                  
                    <a href="../ui/insight.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      RedisInsight
                    </a>
                  
                    <a href="../stack/json.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      JSON
                    </a>
                  
                    <a href="../stack/search.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Search
                    </a>
                  
                    <a href="../stack/bloom.html" class=" pl-[1.875rem] flex items-center whitespace-nowrap rounded min-w-[10rem] pt-2 text-slate-500 hover:text-indigo-600 focus:text-slate-900 transition-colors">
                      
                      Probabilistic
                    </a>
                  
                </div>
              
            
          </dd>
        </dl>
        
        
        <dl class="lg:hidden">
          <dt class="sr-only">
            Docs
          </dt>
          <dd class="lg:hidden flex flex-col">
            
              
                <a href="../about.html" class="flex items-center mt-2">
                  Redis
                </a>
                
                  <a href="../getting-started.html" class="mt-2">
                    Get started
                  </a>
                
                  <a href="../data-types.html" class="mt-2">
                    Data types
                  </a>
                
                  <a href="../ui/cli.html" class="mt-2">
                    Redis CLI
                  </a>
                
                  <a href="../clients.html" class="mt-2">
                    Redis clients
                  </a>
                
                  <a href="../management/persistence.html" class="mt-2">
                    Persistence
                  </a>
                
                  <a href="../management/scaling.html" class="mt-2">
                    Scaling
                  </a>
                
                <hr class="opacity-10 mt-4 mb-2">
              
            
              
                <a href="../stack.html" class="flex items-center mt-2">
                  Redis Stack
                </a>
                
                  <a href="../stack/get-started.html" class="mt-2">
                    Get started
                  </a>
                
                  <a href="../stack/get-started/clients.html" class="mt-2">
                    Stack clients
                  </a>
                
                  <a href="../ui/insight.html" class="mt-2">
                    RedisInsight
                  </a>
                
                  <a href="../stack/json.html" class="mt-2">
                    JSON
                  </a>
                
                  <a href="../stack/search.html" class="mt-2">
                    Search
                  </a>
                
                  <a href="../stack/bloom.html" class="mt-2">
                    Probabilistic
                  </a>
                
                <hr class="opacity-10 mt-4 mb-2">
              
            
          </dd>
        </dl>
      
    
      

        
        <a href="../../commands.html" class="hidden uppercase rounded-sm lg:flex items-center justify-items-center first:ml-auto ml-1 px-3 py-2 rounded bg-transparent hover:text-white/50 focus:text-white/50 whitespace-nowrap transition-colors">
          
          
          Commands
        </a>

        
        <a href="../../commands.html" class="flex lg:hidden items-center mt-1.5">
          Commands
        </a>
      
    
      
        
        
        <dl class="hidden lg:flex group relative first:ml-auto ml-1 mt-3 mb-0 px-3 pt-2 pb-5 cursor-pointer">
          <dt class="sr-only uppercase lg:not-sr-only flex items-center justify-items-center group-hover:text-white/50 group-focus-within:text-white/50 whitespace-nowrap transition-colors" href="#">
            
            Resources
          </dt>
          <dd class="hidden lg:grid text-[0.8rem] lg:text-sm text-redis-neutral-800 absolute top-full -mt-1 right-[1000rem] p-2 group-hover:right-[unset] group-hover:-left-3 group-focus-within:right-[unset] group-focus-within:-left-3 bg-white rounded-lg border border-slate-500/10 bg-clip-padding shadow-md">
            
              
              <a href="../../resources/clients.html" class=" px-3 flex items-center whitespace-nowrap rounded min-w-[10rem] py-1 text-slate-500 hover:text-slate-900 focus:text-slate-900 transition-colors">
                
                Clients
              </a>
              
            
              
              <a href="../../resources/libraries.html" class=" px-3 flex items-center whitespace-nowrap rounded min-w-[10rem] py-1 text-slate-500 hover:text-slate-900 focus:text-slate-900 transition-colors">
                
                Libraries
              </a>
              
            
              
              <a href="../../resources/tools.html" class=" px-3 flex items-center whitespace-nowrap rounded min-w-[10rem] py-1 text-slate-500 hover:text-slate-900 focus:text-slate-900 transition-colors">
                
                Tools
              </a>
              
            
              
              <a href="../../resources/modules.html" class=" px-3 flex items-center whitespace-nowrap rounded min-w-[10rem] py-1 text-slate-500 hover:text-slate-900 focus:text-slate-900 transition-colors">
                
                Modules
              </a>
              
            
          </dd>
        </dl>
        
        
        <dl class="lg:hidden">
          <dt class="sr-only">
            Resources
          </dt>
          <dd class="lg:hidden flex flex-col">
            
              
              <a href="../../resources/clients.html" class="mt-2">
                Clients
              </a>
              
            
              
              <a href="../../resources/libraries.html" class="mt-2">
                Libraries
              </a>
              
            
              
              <a href="../../resources/tools.html" class="mt-2">
                Tools
              </a>
              
            
              
              <a href="../../resources/modules.html" class="mt-2">
                Modules
              </a>
              
            
          </dd>
        </dl>
      
    
      

        
        <a href="../../community.html" class="hidden uppercase rounded-sm lg:flex items-center justify-items-center first:ml-auto ml-1 px-3 py-2 rounded bg-transparent hover:text-white/50 focus:text-white/50 whitespace-nowrap transition-colors">
          
          
          Community
        </a>

        
        <a href="../../community.html" class="flex lg:hidden items-center mt-1.5">
          Community
        </a>
      
    
      

        
        <a href="../../support.html" class="hidden uppercase rounded-sm lg:flex items-center justify-items-center first:ml-auto ml-1 px-3 py-2 rounded bg-transparent hover:text-white/50 focus:text-white/50 whitespace-nowrap transition-colors">
          
          
          Support
        </a>

        
        <a href="../../support.html" class="flex lg:hidden items-center mt-1.5">
          Support
        </a>
      
    
    
    <div class="flex flex-col lg:flex-row lg:ml-auto lg:space-x-2">
      <button id="search-button" type="button" class="rounded-sm w-full lg:w-auto transition-colors shrink-0 flex-1 lg:flex-none lg:ml-2 lg:mr-0 mt-4 lg:mt-0 inline-flex items-center px-4 py-2 text-sm font-medium rounded border focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 border-white/50 hover:text-indigo-600 focus:text-indigo-600 hover:bg-white focus:bg-white focus:ring-white">
        <svg class="w-[0.875rem] h-[0.875rem] mr-0.5" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
          <circle cx="10" cy="10" r="7"></circle>
          <line x1="21" y1="21" x2="15" y2="15"></line>
        </svg>
        <span class="sr-only">Quick search&amp;hellip…</span>
        <span class="lg:hidden xl:block flex-auto ml-1 mr-4" aria-hidden="">Search…</span>
        <script>
          if (navigator.appVersion.indexOf("Win") != -1 || navigator.appVersion.indexOf("Linux") != -1) {
            document.querySelector('[title="Command"]').textContent = "&#8963;";
          } 
        </script>
        <kbd class="font-sans font-semibold">
          <abbr title="Command" class="no-underline">⌘</abbr>&nbsp;K
        </kbd>
      </button>
      
        <a class="rounded-sm transition-colors shrink-0 inline-flex items-center justify-center mt-2 lg:mt-0 px-4 py-2 text-sm font-medium rounded border focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900
         border-transparent bg-indigo-500 hover:bg-indigo-600 focus:bg-indigo-600 focus:ring-indigo-600
        " href="../../download.html">
          Download
        </a>
      
        <a class="rounded-sm transition-colors shrink-0 inline-flex items-center justify-center mt-2 lg:mt-0 px-4 py-2 text-sm font-medium rounded border focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900
        
         border-white/50 hover:text-indigo-600 focus:text-indigo-600 hover:bg-white focus:bg-white focus:ring-white" href="http://redis.com/try-free/">
          Try Redis Cloud
        </a>
      
    </div>
	</nav>

  <button data-menu-toggle="" aria-expanded="false" class="menu-toggle block ml-auto lg:hidden relative z-50"> 
    <span class="sr-only">Open main menu</span> 
    <svg aria-hidden="true" role="img" viewBox="0 0 24 24" style="pointer-events: none; width: 24px; height: 24px;" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
      <line x1="4" y1="6" x2="20" y2="6"></line>
      <line x1="4" y1="12" x2="20" y2="12"></line>
      <line x1="4" y1="18" x2="20" y2="18"></line>
    </svg>
  </button>
</div>
    </header>

    
  <main class="docs w-full max-w-[85rem] mx-auto px-4 sm:px-6 lg:px-8 md:flex gap-16">
    

<div class="hidden md:block w-52 h-full shrink-0">
  <nav class="w-52 z-40 bg-white hidden md:block fixed top-28 pb-16 h-full max-h-[calc(100vh-7rem)] text-[0.8125rem] leading-7 font">
    <div class="absolute right-0 -top-28 z-[-1] h-screen border-r border-slate-200/50 bg-gradient-to-bl from-slate-50 via-slate-50 to-indigo-100 w-[17rem] xl:w-[calc(50vw-23rem)]"></div>
    <ul class="h-full max-h-[calc(100vh-7rem)] overflow-y-auto pr-6">
      
    <li>
      <a class="flex justify-between items-center truncate font-semibold text-slate-900" href="../../docs.html">
          <span>Documentation</span>
          
      </a>
        <ul class="">
          
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../about.html">
          <span>About</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../getting-started.html">
          <span>Getting started</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../ui.html">
          <span>User interfaces</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../data-types.html">
          <span>Data types</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../clients.html">
          <span>Client quickstarts</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../manual.html">
          <span>Using Redis</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../management.html">
          <span>Managing Redis</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../reference.html">
          <span>Reference</span>
          
            
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400 rotate-90" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./command-tips.html">
          <span>Command tips</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./modules.html">
          <span>Modules API</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./sentinel-clients.html">
          <span>Sentinel clients</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./key-specs.html">
          <span>Command key specifications</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./protocol-spec.html">
          <span>Protocol spec</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./clients.html">
          <span>Client handling</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./eviction.html">
          <span>Eviction</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./command-arguments.html">
          <span>Command arguments</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./signals.html">
          <span>Signal handling</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate active text-indigo-600" href="./cluster-spec.html">
          <span>Cluster spec</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./gopher.html">
          <span>Gopher protocol</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./arm.html">
          <span>ARM support</span>
          
      </a>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="./internals.html">
          <span>Internals</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
        </ul>
    </li>
    <li>
      <a class="flex justify-between items-center truncate text-slate-600 hover:text-indigo-600" href="../stack.html">
          <span>Redis Stack</span>
          
            
            <svg class="shrink-0 h-[1.0rem] w-[1.0rem] stroke-slate-400" viewBox="0 0 20 20" fill="currentColor">
    <path d="M13.5355 10L6.46447 2.92893"></path>
    <path d="M6.46447 17.0711L13.5355 10"></path>
</svg>
            
          
      </a>
        <ul class="child-list">
          
        </ul>
    </li>
        </ul>
    </li>
    </ul>
  </nav>
</div>
    <div class="w-full max-w-[47rem] py-12">
      <nav class="flex" aria-label="Breadcrumb">
  <ol role="list" class="flex items-center space-x-2">
    
  
    
  
    
  
    
  
  <li class="flex items-center text-sm font-medium text-gray-500 hover:text-gray-700">
    
      <a class="text-gray-400 hover:text-gray-500" href="../../../redis.io.html">
        <svg class="flex-shrink-0 h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
          <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path>
        </svg>
        <span class="sr-only">Home</span>
      </a>
    
  </li>

  
  <li class="flex items-center text-sm font-medium text-gray-500 hover:text-gray-700">
    
      <svg class="flex-shrink-0 h-5 w-5 mr-2 text-slate-300" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
      </svg>
      <a class="" href="../../docs.html">
        Documentation
      </a>
    
  </li>

  
  <li class="flex items-center text-sm font-medium text-gray-500 hover:text-gray-700">
    
      <svg class="flex-shrink-0 h-5 w-5 mr-2 text-slate-300" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
      </svg>
      <a class="" href="../reference.html">
        Redis reference
      </a>
    
  </li>

  
  <li class="flex items-center text-sm font-medium text-gray-500 hover:text-gray-700 pointer-events-none">
    
      <svg class="flex-shrink-0 h-5 w-5 mr-2 text-slate-300" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
        <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path>
      </svg>
      <a class="" href="./cluster-spec.html">
        Redis cluster specification
      </a>
    
  </li>

  </ol>
</nav>


      <section class="prose prose-slate w-full max-w-[47rem] py-12">
        <h1>Redis cluster specification</h1>
        <p class="text-lg -mt-5 mb-10">Detailed specification for Redis cluster</p>
        <p>Welcome to the <strong>Redis Cluster Specification</strong>. Here you'll find information
about the algorithms and design rationales of Redis Cluster. This document is a work
in progress as it is continuously synchronized with the actual implementation
of Redis.</p>
<a class="dashAnchor" name="//apple_ref/Section/Main%20properties%20and%20rationales%20of%20the%20design"></a><h2 id="main-properties-and-rationales-of-the-design">Main properties and rationales of the design</h2>
<h3 id="redis-cluster-goals">Redis Cluster goals</h3>
<p>Redis Cluster is a distributed implementation of Redis with the following goals in order of importance in the design:</p>
<ul>
<li>High performance and linear scalability up to 1000 nodes. There are no proxies, asynchronous replication is used, and no merge operations are performed on values.</li>
<li>Acceptable degree of write safety: the system tries (in a best-effort way) to retain all the writes originating from clients connected with the majority of the master nodes. Usually there are small windows where acknowledged writes can be lost. Windows to lose acknowledged writes are larger when clients are in a minority partition.</li>
<li>Availability: Redis Cluster is able to survive partitions where the majority of the master nodes are reachable and there is at least one reachable replica for every master node that is no longer reachable. Moreover using <em>replicas migration</em>, masters no longer replicated by any replica will receive one from a master which is covered by multiple replicas.</li>
</ul>
<p>What is described in this document is implemented in Redis 3.0 or greater.</p>
<h3 id="implemented-subset">Implemented subset</h3>
<p>Redis Cluster implements all the single key commands available in the
non-distributed version of Redis. Commands performing complex multi-key
operations like set unions and intersections are implemented for cases where
all of the keys involved in the operation hash to the same slot.</p>
<p>Redis Cluster implements a concept called <strong>hash tags</strong> that can be used
to force certain keys to be stored in the same hash slot. However, during
manual resharding, multi-key operations may become unavailable for some time
while single-key operations are always available.</p>
<p>Redis Cluster does not support multiple databases like the standalone version
of Redis. We only support database <code>0</code>; the <a href="../../commands/select.html"><code>SELECT</code></a> command is not allowed.</p>
<a class="dashAnchor" name="//apple_ref/Section/Client%20and%20Server%20roles%20in%20the%20Redis%20cluster%20protocol"></a><h2 id="client-and-server-roles-in-the-redis-cluster-protocol">Client and Server roles in the Redis cluster protocol</h2>
<p>In Redis Cluster, nodes are responsible for holding the data,
and taking the state of the cluster, including mapping keys to the right nodes.
Cluster nodes are also able to auto-discover other nodes, detect non-working
nodes, and promote replica nodes to master when needed in order
to continue to operate when a failure occurs.</p>
<p>To perform their tasks all the cluster nodes are connected using a
TCP bus and a binary protocol, called the <strong>Redis Cluster Bus</strong>.
Every node is connected to every other node in the cluster using the cluster
bus. Nodes use a gossip protocol to propagate information about the cluster
in order to discover new nodes, to send ping packets to make sure all the
other nodes are working properly, and to send cluster messages needed to
signal specific conditions. The cluster bus is also used in order to
propagate Pub/Sub messages across the cluster and to orchestrate manual
failovers when requested by users (manual failovers are failovers which
are not initiated by the Redis Cluster failure detector, but by the
system administrator directly).</p>
<p>Since cluster nodes are not able to proxy requests, clients may be redirected
to other nodes using redirection errors <code>-MOVED</code> and <code>-ASK</code>.
The client is in theory free to send requests to all the nodes in the cluster,
getting redirected if needed, so the client is not required to hold the
state of the cluster. However clients that are able to cache the map between
keys and nodes can improve the performance in a sensible way.</p>
<h3 id="write-safety">Write safety</h3>
<p>Redis Cluster uses asynchronous replication between nodes, and <strong>last failover wins</strong> implicit merge function. This means that the last elected master dataset eventually replaces all the other replicas. There is always a window of time when it is possible to lose writes during partitions. However these windows are very different in the case of a client that is connected to the majority of masters, and a client that is connected to the minority of masters.</p>
<p>Redis Cluster tries harder to retain writes that are performed by clients connected to the majority of masters, compared to writes performed in the minority side.
The following are examples of scenarios that lead to loss of acknowledged
writes received in the majority partitions during failures:</p>
<ol>
<li>
<p>A write may reach a master, but while the master may be able to reply to the client, the write may not be propagated to replicas via the asynchronous replication used between master and replica nodes. If the master dies without the write reaching the replicas, the write is lost forever if the master is unreachable for a long enough period that one of its replicas is promoted. This is usually hard to observe in the case of a total, sudden failure of a master node since masters try to reply to clients (with the acknowledge of the write) and replicas (propagating the write) at about the same time. However it is a real world failure mode.</p>
</li>
<li>
<p>Another theoretically possible failure mode where writes are lost is the following:</p>
</li>
</ol>
<ul>
<li>A master is unreachable because of a partition.</li>
<li>It gets failed over by one of its replicas.</li>
<li>After some time it may be reachable again.</li>
<li>A client with an out-of-date routing table may write to the old master before it is converted into a replica (of the new master) by the cluster.</li>
</ul>
<p>The second failure mode is unlikely to happen because master nodes unable to communicate with the majority of the other masters for enough time to be failed over will no longer accept writes, and when the partition is fixed writes are still refused for a small amount of time to allow other nodes to inform about configuration changes. This failure mode also requires that the client's routing table has not yet been updated.</p>
<p>Writes targeting the minority side of a partition have a larger window in which to get lost. For example, Redis Cluster loses a non-trivial number of writes on partitions where there is a minority of masters and at least one or more clients, since all the writes sent to the masters may potentially get lost if the masters are failed over in the majority side.</p>
<p>Specifically, for a master to be failed over it must be unreachable by the majority of masters for at least <code>NODE_TIMEOUT</code>, so if the partition is fixed before that time, no writes are lost. When the partition lasts for more than <code>NODE_TIMEOUT</code>, all the writes performed in the minority side up to that point may be lost. However the minority side of a Redis Cluster will start refusing writes as soon as <code>NODE_TIMEOUT</code> time has elapsed without contact with the majority, so there is a maximum window after which the minority becomes no longer available. Hence, no writes are accepted or lost after that time.</p>
<h3 id="availability">Availability</h3>
<p>Redis Cluster is not available in the minority side of the partition. In the majority side of the partition assuming that there are at least the majority of masters and a replica for every unreachable master, the cluster becomes available again after <code>NODE_TIMEOUT</code> time plus a few more seconds required for a replica to get elected and failover its master (failovers are usually executed in a matter of 1 or 2 seconds).</p>
<p>This means that Redis Cluster is designed to survive failures of a few nodes in the cluster, but it is not a suitable solution for applications that require availability in the event of large net splits.</p>
<p>In the example of a cluster composed of N master nodes where every node has a single replica, the majority side of the cluster will remain available as long as a single node is partitioned away, and will remain available with a probability of <code>1-(1/(N*2-1))</code> when two nodes are partitioned away (after the first node fails we are left with <code>N*2-1</code> nodes in total, and the probability of the only master without a replica to fail is <code>1/(N*2-1))</code>.</p>
<p>For example, in a cluster with 5 nodes and a single replica per node, there is a <code>1/(5*2-1) = 11.11%</code> probability that after two nodes are partitioned away from the majority, the cluster will no longer be available.</p>
<p>Thanks to a Redis Cluster feature called <strong>replicas migration</strong> the Cluster
availability is improved in many real world scenarios by the fact that
replicas migrate to orphaned masters (masters no longer having replicas).
So at every successful failure event, the cluster may reconfigure the replicas
layout in order to better resist the next failure.</p>
<h3 id="performance">Performance</h3>
<p>In Redis Cluster nodes don't proxy commands to the right node in charge for a given key, but instead they redirect clients to the right nodes serving a given portion of the key space.</p>
<p>Eventually clients obtain an up-to-date representation of the cluster and which node serves which subset of keys, so during normal operations clients directly contact the right nodes in order to send a given command.</p>
<p>Because of the use of asynchronous replication, nodes do not wait for other nodes' acknowledgment of writes (if not explicitly requested using the <a href="../../commands/wait.html"><code>WAIT</code></a> command).</p>
<p>Also, because multi-key commands are only limited to <em>near</em> keys, data is never moved between nodes except when resharding.</p>
<p>Normal operations are handled exactly as in the case of a single Redis instance. This means that in a Redis Cluster with N master nodes you can expect the same performance as a single Redis instance multiplied by N as the design scales linearly. At the same time the query is usually performed in a single round trip, since clients usually retain persistent connections with the nodes, so latency figures are also the same as the single standalone Redis node case.</p>
<p>Very high performance and scalability while preserving weak but
reasonable forms of data safety and availability is the main goal of
Redis Cluster.</p>
<h3 id="why-merge-operations-are-avoided">Why merge operations are avoided</h3>
<p>The Redis Cluster design avoids conflicting versions of the same key-value pair in multiple nodes as in the case of the Redis data model this is not always desirable. Values in Redis are often very large; it is common to see lists or sorted sets with millions of elements. Also data types are semantically complex. Transferring and merging these kind of values can be a major bottleneck and/or may require the non-trivial involvement of application-side logic, additional memory to store meta-data, and so forth.</p>
<p>There are no strict technological limits here. CRDTs or synchronously replicated
state machines can model complex data types similar to Redis. However, the
actual run time behavior of such systems would not be similar to Redis Cluster.
Redis Cluster was designed in order to cover the exact use cases of the
non-clustered Redis version.</p>
<a class="dashAnchor" name="//apple_ref/Section/Overview%20of%20Redis%20Cluster%20main%20components"></a><h2 id="overview-of-redis-cluster-main-components">Overview of Redis Cluster main components</h2>
<h3 id="key-distribution-model">Key distribution model</h3>
<p>The cluster's key space is split into 16384 slots, effectively setting an upper limit
for the cluster size of 16384 master nodes (however, the suggested max size of
nodes is on the order of ~ 1000 nodes).</p>
<p>Each master node in a cluster handles a subset of the 16384 hash slots.
The cluster is <strong>stable</strong> when there is no cluster reconfiguration in
progress (i.e. where hash slots are being moved from one node to another).
When the cluster is stable, a single hash slot will be served by a single node
(however the serving node can have one or more replicas that will replace it in the case of net splits or failures,
and that can be used in order to scale read operations where reading stale data is acceptable).</p>
<p>The base algorithm used to map keys to hash slots is the following
(read the next paragraph for the hash tag exception to this rule):</p>
<pre><code>HASH_SLOT = CRC16(key) mod 16384
</code></pre>
<p>The CRC16 is specified as follows:</p>
<ul>
<li>Name: XMODEM (also known as ZMODEM or CRC-16/ACORN)</li>
<li>Width: 16 bit</li>
<li>Poly: 1021 (That is actually x^16 + x^12 + x^5 + 1)</li>
<li>Initialization: 0000</li>
<li>Reflect Input byte: False</li>
<li>Reflect Output CRC: False</li>
<li>Xor constant to output CRC: 0000</li>
<li>Output for "123456789": 31C3</li>
</ul>
<p>14 out of 16 CRC16 output bits are used (this is why there is
a modulo 16384 operation in the formula above).</p>
<p>In our tests CRC16 behaved remarkably well in distributing different kinds of
keys evenly across the 16384 slots.</p>
<p><strong>Note</strong>: A reference implementation of the CRC16 algorithm used is available in the Appendix A of this document.</p>
<h3 id="hash-tags">Hash tags</h3>
<p>There is an exception for the computation of the hash slot that is used in order
to implement <strong>hash tags</strong>. Hash tags are a way to ensure that multiple keys
are allocated in the same hash slot. This is used in order to implement
multi-key operations in Redis Cluster.</p>
<p>To implement hash tags, the hash slot for a key is computed in a
slightly different way in certain conditions.
If the key contains a "{...}" pattern only the substring between
<code>{</code> and <code>}</code> is hashed in order to obtain the hash slot. However since it is
possible that there are multiple occurrences of <code>{</code> or <code>}</code> the algorithm is
well specified by the following rules:</p>
<ul>
<li>IF the key contains a <code>{</code> character.</li>
<li>AND IF there is a <code>}</code> character to the right of <code>{</code>.</li>
<li>AND IF there are one or more characters between the first occurrence of <code>{</code> and the first occurrence of <code>}</code>.</li>
</ul>
<p>Then instead of hashing the key, only what is between the first occurrence of <code>{</code> and the following first occurrence of <code>}</code> is hashed.</p>
<p>Examples:</p>
<ul>
<li>The two keys <code>{user1000}.following</code> and <code>{user1000}.followers</code> will hash to the same hash slot since only the substring <code>user1000</code> will be hashed in order to compute the hash slot.</li>
<li>For the key <code>foo{}{bar}</code> the whole key will be hashed as usually since the first occurrence of <code>{</code> is followed by <code>}</code> on the right without characters in the middle.</li>
<li>For the key <code>foo{{bar}}zap</code> the substring <code>{bar</code> will be hashed, because it is the substring between the first occurrence of <code>{</code> and the first occurrence of <code>}</code> on its right.</li>
<li>For the key <code>foo{bar}{zap}</code> the substring <code>bar</code> will be hashed, since the algorithm stops at the first valid or invalid (without bytes inside) match of <code>{</code> and <code>}</code>.</li>
<li>What follows from the algorithm is that if the key starts with <code>{}</code>, it is guaranteed to be hashed as a whole. This is useful when using binary data as key names.</li>
</ul>
<p>Adding the hash tags exception, the following is an implementation of the <code>HASH_SLOT</code> function in Ruby and C language.</p>
<p>Ruby example code:</p>
<pre><code>def HASH_SLOT(key)
    s = key.index "{"
    if s
        e = key.index "}",s+1
        if e &amp;&amp; e != s+1
            key = key[s+1..e-1]
        end
    end
    crc16(key) % 16384
end
</code></pre>
<p>C example code:</p>
<pre><code>unsigned int HASH_SLOT(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    /* Search the first occurrence of '{'. */
    for (s = 0; s &lt; keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) &amp; 16383;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e &lt; keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 16383;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) &amp; 16383;
}
</code></pre>
<h3 id="cluster-node-attributes">Cluster node attributes</h3>
<p>Every node has a unique name in the cluster. The node name is the
hex representation of a 160 bit random number, obtained the first time a
node is started (usually using /dev/urandom).
The node will save its ID in the node configuration file, and will use the
same ID forever, or at least as long as the node configuration file is not
deleted by the system administrator, or a <em>hard reset</em> is requested
via the <a href="../../commands/cluster-reset.html"><code>CLUSTER RESET</code></a> command.</p>
<p>The node ID is used to identify every node across the whole cluster.
It is possible for a given node to change its IP address without any need
to also change the node ID. The cluster is also able to detect the change
in IP/port and reconfigure using the gossip protocol running over the cluster
bus.</p>
<p>The node ID is not the only information associated with each node, but is
the only one that is always globally consistent. Every node has also the
following set of information associated. Some information is about the
cluster configuration detail of this specific node, and is eventually
consistent across the cluster. Some other information, like the last time
a node was pinged, is instead local to each node.</p>
<p>Every node maintains the following information about other nodes that it is
aware of in the cluster: The node ID, IP and port of the node, a set of
flags, what is the master of the node if it is flagged as <code>replica</code>, last time
the node was pinged and the last time the pong was received, the current
<em>configuration epoch</em> of the node (explained later in this specification),
the link state and finally the set of hash slots served.</p>
<p>A detailed <a href="../../commands/cluster-nodes.html">explanation of all the node fields</a> is described in the <a href="../../commands/cluster-nodes.html"><code>CLUSTER NODES</code></a> documentation.</p>
<p>The <a href="../../commands/cluster-nodes.html"><code>CLUSTER NODES</code></a> command can be sent to any node in the cluster and provides the state of the cluster and the information for each node according to the local view the queried node has of the cluster.</p>
<p>The following is sample output of the <a href="../../commands/cluster-nodes.html"><code>CLUSTER NODES</code></a> command sent to a master
node in a small cluster of three nodes.</p>
<pre><code>$ redis-cli cluster nodes
d1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364
3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729
d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095
</code></pre>
<p>In the above listing the different fields are in order: node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots. Details about the above fields will be covered as soon as we talk of specific parts of Redis Cluster.</p>
<h3 id="the-cluster-bus">The cluster bus</h3>
<p>Every Redis Cluster node has an additional TCP port for receiving
incoming connections from other Redis Cluster nodes. This port will be derived by adding 10000 to the data port or it can be specified with the cluster-port config.</p>
<p>Example 1:</p>
<p>If a Redis node is listening for client connections on port 6379,
and you do not add cluster-port parameter in redis.conf,
the Cluster bus port 16379 will be opened.</p>
<p>Example 2:</p>
<p>If a Redis node is listening for client connections on port 6379,
and you set cluster-port 20000 in redis.conf,
the Cluster bus port 20000 will be opened.</p>
<p>Node-to-node communication happens exclusively using the Cluster bus and
the Cluster bus protocol: a binary protocol composed of frames
of different types and sizes. The Cluster bus binary protocol is not
publicly documented since it is not intended for external software devices
to talk with Redis Cluster nodes using this protocol. However you can
obtain more details about the Cluster bus protocol by reading the
<code>cluster.h</code> and <code>cluster.c</code> files in the Redis Cluster source code.</p>
<h3 id="cluster-topology">Cluster topology</h3>
<p>Redis Cluster is a full mesh where every node is connected with every other node using a TCP connection.</p>
<p>In a cluster of N nodes, every node has N-1 outgoing TCP connections, and N-1 incoming connections.</p>
<p>These TCP connections are kept alive all the time and are not created on demand.
When a node expects a pong reply in response to a ping in the cluster bus, before waiting long enough to mark the node as unreachable, it will try to
refresh the connection with the node by reconnecting from scratch.</p>
<p>While Redis Cluster nodes form a full mesh, <strong>nodes use a gossip protocol and
a configuration update mechanism in order to avoid exchanging too many
messages between nodes during normal conditions</strong>, so the number of messages
exchanged is not exponential.</p>
<h3 id="node-handshake">Node handshake</h3>
<p>Nodes always accept connections on the cluster bus port, and even reply to
pings when received, even if the pinging node is not trusted.
However, all other packets will be discarded by the receiving node if the
sending node is not considered part of the cluster.</p>
<p>A node will accept another node as part of the cluster only in two ways:</p>
<ul>
<li>
<p>If a node presents itself with a <code>MEET</code> message (<a href="../../commands/cluster-meet.html"><code>CLUSTER MEET</code></a> command). A meet message is exactly
like a <a href="../../commands/ping.html"><code>PING</code></a> message, but forces the receiver to accept the node as part of
the cluster. Nodes will send <code>MEET</code> messages to other nodes <strong>only if</strong> the system administrator requests this via the following command:</p>
<p>CLUSTER MEET ip port</p>
</li>
<li>
<p>A node will also register another node as part of the cluster if a node that is already trusted will gossip about this other node. So if A knows B, and B knows C, eventually B will send gossip messages to A about C. When this happens, A will register C as part of the network, and will try to connect with C.</p>
</li>
</ul>
<p>This means that as long as we join nodes in any connected graph, they'll eventually form a fully connected graph automatically. This means that the cluster is able to auto-discover other nodes, but only if there is a trusted relationship that was forced by the system administrator.</p>
<p>This mechanism makes the cluster more robust but prevents different Redis clusters from accidentally mixing after change of IP addresses or other network related events.</p>
<a class="dashAnchor" name="//apple_ref/Section/Redirection%20and%20resharding"></a><h2 id="redirection-and-resharding">Redirection and resharding</h2>
<h3 id="moved-redirection">MOVED Redirection</h3>
<p>A Redis client is free to send queries to every node in the cluster, including
replica nodes. The node will analyze the query, and if it is acceptable
(that is, only a single key is mentioned in the query, or the multiple keys
mentioned are all to the same hash slot) it will lookup what
node is responsible for the hash slot where the key or keys belong.</p>
<p>If the hash slot is served by the node, the query is simply processed, otherwise
the node will check its internal hash slot to node map, and will reply
to the client with a MOVED error, like in the following example:</p>
<pre><code>GET x
-MOVED 3999 127.0.0.1:6381
</code></pre>
<p>The error includes the hash slot of the key (3999) and the endpoint:port of the instance that can serve the query.
The client needs to reissue the query to the specified node's endpoint address and port.
The endpoint can be either an IP address, a hostname, or it can be empty (e.g. <code>-MOVED 3999 :6380</code>).
An empty endpoint indicates that the server node has an unknown endpoint, and the client should send the next request to the same endpoint as the current request but with the provided port.</p>
<p>Note that even if the client waits a long time before reissuing the query,
and in the meantime the cluster configuration changed, the destination node
will reply again with a MOVED error if the hash slot 3999 is now served by
another node. The same happens if the contacted node had no updated information.</p>
<p>So while from the point of view of the cluster nodes are identified by
IDs we try to simplify our interface with the client just exposing a map
between hash slots and Redis nodes identified by endpoint:port pairs.</p>
<p>The client is not required to, but should try to memorize that hash slot
3999 is served by 127.0.0.1:6381. This way once a new command needs to
be issued it can compute the hash slot of the target key and have a
greater chance of choosing the right node.</p>
<p>An alternative is to just refresh the whole client-side cluster layout
using the <a href="../../commands/cluster-shards.html"><code>CLUSTER SHARDS</code></a>, or the deprecated <a href="../../commands/cluster-slots.html"><code>CLUSTER SLOTS</code></a>, command
when a MOVED redirection is received. When a redirection is encountered, it
is likely multiple slots were reconfigured rather than just one, so updating
the client configuration as soon as possible is often the best strategy.</p>
<p>Note that when the Cluster is stable (no ongoing changes in the configuration),
eventually all the clients will obtain a map of hash slots -&gt; nodes, making
the cluster efficient, with clients directly addressing the right nodes
without redirections, proxies or other single point of failure entities.</p>
<p>A client <strong>must be also able to handle -ASK redirections</strong> that are described
later in this document, otherwise it is not a complete Redis Cluster client.</p>
<h3 id="live-reconfiguration">Live reconfiguration</h3>
<p>Redis Cluster supports the ability to add and remove nodes while the cluster
is running. Adding or removing a node is abstracted into the same
operation: moving a hash slot from one node to another. This means
that the same basic mechanism can be used in order to rebalance the cluster, add
or remove nodes, and so forth.</p>
<ul>
<li>To add a new node to the cluster an empty node is added to the cluster and some set of hash slots are moved from existing nodes to the new node.</li>
<li>To remove a node from the cluster the hash slots assigned to that node are moved to other existing nodes.</li>
<li>To rebalance the cluster a given set of hash slots are moved between nodes.</li>
</ul>
<p>The core of the implementation is the ability to move hash slots around.
From a practical point of view a hash slot is just a set of keys, so
what Redis Cluster really does during <em>resharding</em> is to move keys from
an instance to another instance. Moving a hash slot means moving all the keys
that happen to hash into this hash slot.</p>
<p>To understand how this works we need to show the <a href="../../commands/cluster.html"><code>CLUSTER</code></a> subcommands
that are used to manipulate the slots translation table in a Redis Cluster node.</p>
<p>The following subcommands are available (among others not useful in this case):</p>
<ul>
<li><a href="../../commands/cluster-addslots.html"><code>CLUSTER ADDSLOTS</code></a> slot1 [slot2] ... [slotN]</li>
<li><a href="../../commands/cluster-delslots.html"><code>CLUSTER DELSLOTS</code></a> slot1 [slot2] ... [slotN]</li>
<li><a href="../../commands/cluster-addslotsrange.html"><code>CLUSTER ADDSLOTSRANGE</code></a> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li>
<li><a href="../../commands/cluster-delslotsrange.html"><code>CLUSTER DELSLOTSRANGE</code></a> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li>
<li><a href="../../commands/cluster-setslot.html"><code>CLUSTER SETSLOT</code></a> slot NODE node</li>
<li><a href="../../commands/cluster-setslot.html"><code>CLUSTER SETSLOT</code></a> slot MIGRATING node</li>
<li><a href="../../commands/cluster-setslot.html"><code>CLUSTER SETSLOT</code></a> slot IMPORTING node</li>
</ul>
<p>The first four commands, <code>ADDSLOTS</code>, <code>DELSLOTS</code>, <code>ADDSLOTSRANGE</code> and <code>DELSLOTSRANGE</code>, are simply used to assign
(or remove) slots to a Redis node. Assigning a slot means to tell a given
master node that it will be in charge of storing and serving content for
the specified hash slot.</p>
<p>After the hash slots are assigned they will propagate across the cluster
using the gossip protocol, as specified later in the
<em>configuration propagation</em> section.</p>
<p>The <code>ADDSLOTS</code> and <code>ADDSLOTSRANGE</code> commands are usually used when a new cluster is created
from scratch to assign each master node a subset of all the 16384 hash
slots available.</p>
<p>The <code>DELSLOTS</code>  and <code>DELSLOTSRANGE</code> are mainly used for manual modification of a cluster configuration
or for debugging tasks: in practice it is rarely used.</p>
<p>The <code>SETSLOT</code> subcommand is used to assign a slot to a specific node ID if
the <code>SETSLOT &lt;slot&gt; NODE</code> form is used. Otherwise the slot can be set in the
two special states <code>MIGRATING</code> and <code>IMPORTING</code>. Those two special states
are used in order to migrate a hash slot from one node to another.</p>
<ul>
<li>When a slot is set as MIGRATING, the node will accept all queries that
are about this hash slot, but only if the key in question
exists, otherwise the query is forwarded using a <code>-ASK</code> redirection to the
node that is target of the migration.</li>
<li>When a slot is set as IMPORTING, the node will accept all queries that
are about this hash slot, but only if the request is
preceded by an <a href="../../commands/asking.html"><code>ASKING</code></a> command. If the <a href="../../commands/asking.html"><code>ASKING</code></a> command was not given
by the client, the query is redirected to the real hash slot owner via
a <code>-MOVED</code> redirection error, as would happen normally.</li>
</ul>
<p>Let's make this clearer with an example of hash slot migration.
Assume that we have two Redis master nodes, called A and B.
We want to move hash slot 8 from A to B, so we issue commands like this:</p>
<ul>
<li>We send B: CLUSTER SETSLOT 8 IMPORTING A</li>
<li>We send A: CLUSTER SETSLOT 8 MIGRATING B</li>
</ul>
<p>All the other nodes will continue to point clients to node "A" every time
they are queried with a key that belongs to hash slot 8, so what happens
is that:</p>
<ul>
<li>All queries about existing keys are processed by "A".</li>
<li>All queries about non-existing keys in A are processed by "B", because "A" will redirect clients to "B".</li>
</ul>
<p>This way we no longer create new keys in "A".
In the meantime, <code>redis-cli</code> used during reshardings
and Redis Cluster configuration will migrate existing keys in
hash slot 8 from A to B.
This is performed using the following command:</p>
<pre><code>CLUSTER GETKEYSINSLOT slot count
</code></pre>
<p>The above command will return <code>count</code> keys in the specified hash slot.
For keys returned, <code>redis-cli</code> sends node "A" a <a href="../../commands/migrate.html"><code>MIGRATE</code></a> command, that
will migrate the specified keys from A to B in an atomic way (both instances
are locked for the time (usually very small time) needed to migrate keys so
there are no race conditions). This is how <a href="../../commands/migrate.html"><code>MIGRATE</code></a> works:</p>
<pre><code>MIGRATE target_host target_port "" target_database id timeout KEYS key1 key2 ...
</code></pre>
<p><a href="../../commands/migrate.html"><code>MIGRATE</code></a> will connect to the target instance, send a serialized version of
the key, and once an OK code is received, the old key from its own dataset
will be deleted. From the point of view of an external client a key exists
either in A or B at any given time.</p>
<p>In Redis Cluster there is no need to specify a database other than 0, but
<a href="../../commands/migrate.html"><code>MIGRATE</code></a> is a general command that can be used for other tasks not
involving Redis Cluster.
<a href="../../commands/migrate.html"><code>MIGRATE</code></a> is optimized to be as fast as possible even when moving complex
keys such as long lists, but in Redis Cluster reconfiguring the
cluster where big keys are present is not considered a wise procedure if
there are latency constraints in the application using the database.</p>
<p>When the migration process is finally finished, the <code>SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code> command is sent to the two nodes involved in the migration in order to
set the slots to their normal state again. The same command is usually
sent to all other nodes to avoid waiting for the natural
propagation of the new configuration across the cluster.</p>
<h3 id="ask-redirection">ASK redirection</h3>
<p>In the previous section, we briefly talked about ASK redirection. Why can't
we simply use MOVED redirection? Because while MOVED means that
we think the hash slot is permanently served by a different node and the
next queries should be tried against the specified node. ASK means to
send only the next query to the specified node.</p>
<p>This is needed because the next query about hash slot 8 can be about a
key that is still in A, so we always want the client to try A and
then B if needed. Since this happens only for one hash slot out of 16384
available, the performance hit on the cluster is acceptable.</p>
<p>We need to force that client behavior, so to make sure
that clients will only try node B after A was tried, node B will only
accept queries of a slot that is set as IMPORTING if the client sends the
ASKING command before sending the query.</p>
<p>Basically the ASKING command sets a one-time flag on the client that forces
a node to serve a query about an IMPORTING slot.</p>
<p>The full semantics of ASK redirection from the point of view of the client is as follows:</p>
<ul>
<li>If ASK redirection is received, send only the query that was redirected to the specified node but continue sending subsequent queries to the old node.</li>
<li>Start the redirected query with the ASKING command.</li>
<li>Don't yet update local client tables to map hash slot 8 to B.</li>
</ul>
<p>Once hash slot 8 migration is completed, A will send a MOVED message and
the client may permanently map hash slot 8 to the new endpoint and port pair.
Note that if a buggy client performs the map earlier this is not
a problem since it will not send the ASKING command before issuing the query,
so B will redirect the client to A using a MOVED redirection error.</p>
<p>Slots migration is explained in similar terms but with different wording
(for the sake of redundancy in the documentation) in the <a href="../../commands/cluster-setslot.html"><code>CLUSTER SETSLOT</code></a>
command documentation.</p>
<h3 id="client-connections-and-redirection-handling">Client connections and redirection handling</h3>
<p>To be efficient, Redis Cluster clients maintain a map of the current slot
configuration. However, this configuration is not <em>required</em> to be up to date.
When contacting the wrong node results in a redirection, the client
can update its internal slot map accordingly.</p>
<p>Clients usually need to fetch a complete list of slots and mapped node
addresses in two different situations:</p>
<ul>
<li>At startup, to populate the initial slots configuration</li>
<li>When the client receives a <code>MOVED</code> redirection</li>
</ul>
<p>Note that a client may handle the <code>MOVED</code> redirection by updating just the
moved slot in its table; however this is usually not efficient because often
the configuration of multiple slots will be modified at once. For example, if a
replica is promoted to master, all of the slots served by the old master will
be remapped). It is much simpler to react to a <code>MOVED</code> redirection by
fetching the full map of slots to nodes from scratch.</p>
<p>Client can issue a <a href="../../commands/cluster-slots.html"><code>CLUSTER SLOTS</code></a> command to retrieve an array of slot
ranges and the associated master and replica nodes serving the specified ranges.</p>
<p>The following is an example of output of <a href="../../commands/cluster-slots.html"><code>CLUSTER SLOTS</code></a>:</p>
<pre tabindex="0"><code>127.0.0.1:7000&gt; cluster slots
1) 1) (integer) 5461
   2) (integer) 10922
   3) 1) "127.0.0.1"
      2) (integer) 7001
   4) 1) "127.0.0.1"
      2) (integer) 7004
2) 1) (integer) 0
   2) (integer) 5460
   3) 1) "127.0.0.1"
      2) (integer) 7000
   4) 1) "127.0.0.1"
      2) (integer) 7003
3) 1) (integer) 10923
   2) (integer) 16383
   3) 1) "127.0.0.1"
      2) (integer) 7002
   4) 1) "127.0.0.1"
      2) (integer) 7005
</code></pre><p>The first two sub-elements of every element of the returned array are the
start and end slots of the range. The additional elements represent address-port
pairs. The first address-port pair is the master serving the slot, and the
additional address-port pairs are the replicas serving the same slot. Replicas
will be listed only when not in an error condition (i.e., when their FAIL flag is not set).</p>
<p>The first element in the output above says that slots from 5461 to 10922
(start and end included) are served by 127.0.0.1:7001, and it is possible
to scale read-only load contacting the replica at 127.0.0.1:7004.</p>
<p><a href="../../commands/cluster-slots.html"><code>CLUSTER SLOTS</code></a> is not guaranteed to return ranges that cover the full
16384 slots if the cluster is misconfigured, so clients should initialize the
slots configuration map filling the target nodes with NULL objects, and
report an error if the user tries to execute commands about keys
that belong to unassigned slots.</p>
<p>Before returning an error to the caller when a slot is found to
be unassigned, the client should try to fetch the slots configuration
again to check if the cluster is now configured properly.</p>
<h3 id="multi-keys-operations">Multi-keys operations</h3>
<p>Using hash tags, clients are free to use multi-key operations.
For example the following operation is valid:</p>
<pre><code>MSET {user:1000}.name Angela {user:1000}.surname White
</code></pre>
<p>Multi-key operations may become unavailable when a resharding of the
hash slot the keys belong to is in progress.</p>
<p>More specifically, even during a resharding the multi-key operations targeting
keys that all exist and all still hash to the same slot (either the source or
destination node) are still available.</p>
<p>Operations on keys that don't exist or are - during the resharding - split
between the source and destination nodes, will generate a <code>-TRYAGAIN</code> error.
The client can try the operation after some time, or report back the error.</p>
<p>As soon as migration of the specified hash slot has terminated, all
multi-key operations are available again for that hash slot.</p>
<h3 id="scaling-reads-using-replica-nodes">Scaling reads using replica nodes</h3>
<p>Normally replica nodes will redirect clients to the authoritative master for
the hash slot involved in a given command, however clients can use replicas
in order to scale reads using the <a href="../../commands/readonly.html"><code>READONLY</code></a> command.</p>
<p><a href="../../commands/readonly.html"><code>READONLY</code></a> tells a Redis Cluster replica node that the client is ok reading
possibly stale data and is not interested in running write queries.</p>
<p>When the connection is in readonly mode, the cluster will send a redirection
to the client only if the operation involves keys not served
by the replica's master node. This may happen because:</p>
<ol>
<li>The client sent a command about hash slots never served by the master of this replica.</li>
<li>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</li>
</ol>
<p>When this happens the client should update its hash slot map as explained in
the previous sections.</p>
<p>The readonly state of the connection can be cleared using the <a href="../../commands/readwrite.html"><code>READWRITE</code></a> command.</p>
<a class="dashAnchor" name="//apple_ref/Section/Fault%20Tolerance"></a><h2 id="fault-tolerance">Fault Tolerance</h2>
<h3 id="heartbeat-and-gossip-messages">Heartbeat and gossip messages</h3>
<p>Redis Cluster nodes continuously exchange ping and pong packets. Those two kinds of packets have the same structure, and both carry important configuration information. The only actual difference is the message type field. We'll refer to the sum of ping and pong packets as <em>heartbeat packets</em>.</p>
<p>Usually nodes send ping packets that will trigger the receivers to reply with pong packets. However this is not necessarily true. It is possible for nodes to just send pong packets to send information to other nodes about their configuration, without triggering a reply. This is useful, for example, in order to broadcast a new configuration as soon as possible.</p>
<p>Usually a node will ping a few random nodes every second so that the total number of ping packets sent (and pong packets received) by each node is a constant amount regardless of the number of nodes in the cluster.</p>
<p>However every node makes sure to ping every other node that hasn't sent a ping or received a pong for longer than half the <code>NODE_TIMEOUT</code> time. Before <code>NODE_TIMEOUT</code> has elapsed, nodes also try to reconnect the TCP link with another node to make sure nodes are not believed to be unreachable only because there is a problem in the current TCP connection.</p>
<p>The number of messages globally exchanged can be sizable if <code>NODE_TIMEOUT</code> is set to a small figure and the number of nodes (N) is very large, since every node will try to ping every other node for which they don't have fresh information every half the <code>NODE_TIMEOUT</code> time.</p>
<p>For example in a 100 node cluster with a node timeout set to 60 seconds, every node will try to send 99 pings every 30 seconds, with a total amount of pings of 3.3 per second. Multiplied by 100 nodes, this is 330 pings per second in the total cluster.</p>
<p>There are ways to lower the number of messages, however there have been no
reported issues with the bandwidth currently used by Redis Cluster failure
detection, so for now the obvious and direct design is used. Note that even
in the above example, the 330 packets per second exchanged are evenly
divided among 100 different nodes, so the traffic each node receives
is acceptable.</p>
<h3 id="heartbeat-packet-content">Heartbeat packet content</h3>
<p>Ping and pong packets contain a header that is common to all types of packets (for instance packets to request a failover vote), and a special gossip section that is specific to Ping and Pong packets.</p>
<p>The common header has the following information:</p>
<ul>
<li>Node ID, a 160 bit pseudorandom string that is assigned the first time a node is created and remains the same for all the life of a Redis Cluster node.</li>
<li>The <code>currentEpoch</code> and <code>configEpoch</code> fields of the sending node that are used to mount the distributed algorithms used by Redis Cluster (this is explained in detail in the next sections). If the node is a replica the <code>configEpoch</code> is the last known <code>configEpoch</code> of its master.</li>
<li>The node flags, indicating if the node is a replica, a master, and other single-bit node information.</li>
<li>A bitmap of the hash slots served by the sending node, or if the node is a replica, a bitmap of the slots served by its master.</li>
<li>The sender TCP base port that is the port used by Redis to accept client commands.</li>
<li>The cluster port that is the port used by Redis for node-to-node communication.</li>
<li>The state of the cluster from the point of view of the sender (down or ok).</li>
<li>The master node ID of the sending node, if it is a replica.</li>
</ul>
<p>Ping and pong packets also contain a gossip section. This section offers to the receiver a view of what the sender node thinks about other nodes in the cluster. The gossip section only contains information about a few random nodes among the set of nodes known to the sender. The number of nodes mentioned in a gossip section is proportional to the cluster size.</p>
<p>For every node added in the gossip section the following fields are reported:</p>
<ul>
<li>Node ID.</li>
<li>IP and port of the node.</li>
<li>Node flags.</li>
</ul>
<p>Gossip sections allow receiving nodes to get information about the state of other nodes from the point of view of the sender. This is useful both for failure detection and to discover other nodes in the cluster.</p>
<h3 id="failure-detection">Failure detection</h3>
<p>Redis Cluster failure detection is used to recognize when a master or replica node is no longer reachable by the majority of nodes and then respond by promoting a replica to the role of master. When replica promotion is not possible the cluster is put in an error state to stop receiving queries from clients.</p>
<p>As already mentioned, every node takes a list of flags associated with other known nodes. There are two flags that are used for failure detection that are called <code>PFAIL</code> and <code>FAIL</code>. <code>PFAIL</code> means <em>Possible failure</em>, and is a non-acknowledged failure type. <code>FAIL</code> means that a node is failing and that this condition was confirmed by a majority of masters within a fixed amount of time.</p>
<p><strong>PFAIL flag:</strong></p>
<p>A node flags another node with the <code>PFAIL</code> flag when the node is not reachable for more than <code>NODE_TIMEOUT</code> time. Both master and replica nodes can flag another node as <code>PFAIL</code>, regardless of its type.</p>
<p>The concept of non-reachability for a Redis Cluster node is that we have an <strong>active ping</strong> (a ping that we sent for which we have yet to get a reply) pending for longer than <code>NODE_TIMEOUT</code>. For this mechanism to work the <code>NODE_TIMEOUT</code> must be large compared to the network round trip time. In order to add reliability during normal operations, nodes will try to reconnect with other nodes in the cluster as soon as half of the <code>NODE_TIMEOUT</code> has elapsed without a reply to a ping. This mechanism ensures that connections are kept alive so broken connections usually won't result in false failure reports between nodes.</p>
<p><strong>FAIL flag:</strong></p>
<p>The <code>PFAIL</code> flag alone is just local information every node has about other nodes, but it is not sufficient to trigger a replica promotion. For a node to be considered down the <code>PFAIL</code> condition needs to be escalated to a <code>FAIL</code> condition.</p>
<p>As outlined in the node heartbeats section of this document, every node sends gossip messages to every other node including the state of a few random known nodes. Every node eventually receives a set of node flags for every other node. This way every node has a mechanism to signal other nodes about failure conditions they have detected.</p>
<p>A <code>PFAIL</code> condition is escalated to a <code>FAIL</code> condition when the following set of conditions are met:</p>
<ul>
<li>Some node, that we'll call A, has another node B flagged as <code>PFAIL</code>.</li>
<li>Node A collected, via gossip sections, information about the state of B from the point of view of the majority of masters in the cluster.</li>
<li>The majority of masters signaled the <code>PFAIL</code> or <code>FAIL</code> condition within <code>NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT</code> time. (The validity factor is set to 2 in the current implementation, so this is just two times the <code>NODE_TIMEOUT</code> time).</li>
</ul>
<p>If all the above conditions are true, Node A will:</p>
<ul>
<li>Mark the node as <code>FAIL</code>.</li>
<li>Send a <code>FAIL</code> message (as opposed to a <code>FAIL</code> condition within a heartbeat message) to all the reachable nodes.</li>
</ul>
<p>The <code>FAIL</code> message will force every receiving node to mark the node in <code>FAIL</code> state, whether or not it already flagged the node in <code>PFAIL</code> state.</p>
<p>Note that <em>the FAIL flag is mostly one way</em>. That is, a node can go from <code>PFAIL</code> to <code>FAIL</code>, but a <code>FAIL</code> flag can only be cleared in the following situations:</p>
<ul>
<li>The node is already reachable and is a replica. In this case the <code>FAIL</code> flag can be cleared as replicas are not failed over.</li>
<li>The node is already reachable and is a master not serving any slot. In this case the <code>FAIL</code> flag can be cleared as masters without slots do not really participate in the cluster and are waiting to be configured in order to join the cluster.</li>
<li>The node is already reachable and is a master, but a long time (N times the <code>NODE_TIMEOUT</code>) has elapsed without any detectable replica promotion. It's better for it to rejoin the cluster and continue in this case.</li>
</ul>
<p>It is useful to note that while the <code>PFAIL</code> -&gt; <code>FAIL</code> transition uses a form of agreement, the agreement used is weak:</p>
<ol>
<li>Nodes collect views of other nodes over some time period, so even if the majority of master nodes need to "agree", actually this is just state that we collected from different nodes at different times and we are not sure, nor we require, that at a given moment the majority of masters agreed. However we discard failure reports which are old, so the failure was signaled by the majority of masters within a window of time.</li>
<li>While every node detecting the <code>FAIL</code> condition will force that condition on other nodes in the cluster using the <code>FAIL</code> message, there is no way to ensure the message will reach all the nodes. For instance a node may detect the <code>FAIL</code> condition and because of a partition will not be able to reach any other node.</li>
</ol>
<p>However the Redis Cluster failure detection has a liveness requirement: eventually all the nodes should agree about the state of a given node. There are two cases that can originate from split brain conditions. Either some minority of nodes believe the node is in <code>FAIL</code> state, or a minority of nodes believe the node is not in <code>FAIL</code> state. In both the cases eventually the cluster will have a single view of the state of a given node:</p>
<p><strong>Case 1</strong>: If a majority of masters have flagged a node as <code>FAIL</code>, because of failure detection and the <em>chain effect</em> it generates, every other node will eventually flag the master as <code>FAIL</code>, since in the specified window of time enough failures will be reported.</p>
<p><strong>Case 2</strong>: When only a minority of masters have flagged a node as <code>FAIL</code>, the replica promotion will not happen (as it uses a more formal algorithm that makes sure everybody knows about the promotion eventually) and every node will clear the <code>FAIL</code> state as per the <code>FAIL</code> state clearing rules above (i.e. no promotion after N times the <code>NODE_TIMEOUT</code> has elapsed).</p>
<p><strong>The <code>FAIL</code> flag is only used as a trigger to run the safe part of the algorithm</strong> for the replica promotion. In theory a replica may act independently and start a replica promotion when its master is not reachable, and wait for the masters to refuse to provide the acknowledgment if the master is actually reachable by the majority. However the added complexity of the <code>PFAIL -&gt; FAIL</code> state, the weak agreement, and the <code>FAIL</code> message forcing the propagation of the state in the shortest amount of time in the reachable part of the cluster, have practical advantages. Because of these mechanisms, usually all the nodes will stop accepting writes at about the same time if the cluster is in an error state. This is a desirable feature from the point of view of applications using Redis Cluster. Also erroneous election attempts initiated by replicas that can't reach its master due to local problems (the master is otherwise reachable by the majority of other master nodes) are avoided.</p>
<a class="dashAnchor" name="//apple_ref/Section/Configuration%20handling%2C%20propagation%2C%20and%20failovers"></a><h2 id="configuration-handling-propagation-and-failovers">Configuration handling, propagation, and failovers</h2>
<h3 id="cluster-current-epoch">Cluster current epoch</h3>
<p>Redis Cluster uses a concept similar to the Raft algorithm "term". In Redis Cluster the term is called epoch instead, and it is used in order to give incremental versioning to events. When multiple nodes provide conflicting information, it becomes possible for another node to understand which state is the most up to date.</p>
<p>The <code>currentEpoch</code> is a 64 bit unsigned number.</p>
<p>At node creation every Redis Cluster node, both replicas and master nodes, set the <code>currentEpoch</code> to 0.</p>
<p>Every time a packet is received from another node, if the epoch of the sender (part of the cluster bus messages header) is greater than the local node epoch, the <code>currentEpoch</code> is updated to the sender epoch.</p>
<p>Because of these semantics, eventually all the nodes will agree to the greatest <code>currentEpoch</code> in the cluster.</p>
<p>This information is used when the state of the cluster is changed and a node seeks agreement in order to perform some action.</p>
<p>Currently this happens only during replica promotion, as described in the next section. Basically the epoch is a logical clock for the cluster and dictates that given information wins over one with a smaller epoch.</p>
<h3 id="configuration-epoch">Configuration epoch</h3>
<p>Every master always advertises its <code>configEpoch</code> in ping and pong packets along with a bitmap advertising the set of slots it serves.</p>
<p>The <code>configEpoch</code> is set to zero in masters when a new node is created.</p>
<p>A new <code>configEpoch</code> is created during replica election. replicas trying to replace
failing masters increment their epoch and try to get authorization from
a majority of masters. When a replica is authorized, a new unique <code>configEpoch</code>
is created and the replica turns into a master using the new <code>configEpoch</code>.</p>
<p>As explained in the next sections the <code>configEpoch</code> helps to resolve conflicts when different nodes claim divergent configurations (a condition that may happen because of network partitions and node failures).</p>
<p>replica nodes also advertise the <code>configEpoch</code> field in ping and pong packets, but in the case of replicas the field represents the <code>configEpoch</code> of its master as of the last time they exchanged packets. This allows other instances to detect when a replica has an old configuration that needs to be updated (master nodes will not grant votes to replicas with an old configuration).</p>
<p>Every time the <code>configEpoch</code> changes for some known node, it is permanently stored in the nodes.conf file by all the nodes that receive this information. The same also happens for the <code>currentEpoch</code> value. These two variables are guaranteed to be saved and <code>fsync-ed</code> to disk when updated before a node continues its operations.</p>
<p>The <code>configEpoch</code> values generated using a simple algorithm during failovers
are guaranteed to be new, incremental, and unique.</p>
<h3 id="replica-election-and-promotion">Replica election and promotion</h3>
<p>Replica election and promotion is handled by replica nodes, with the help of master nodes that vote for the replica to promote.
A replica election happens when a master is in <code>FAIL</code> state from the point of view of at least one of its replicas that has the prerequisites in order to become a master.</p>
<p>In order for a replica to promote itself to master, it needs to start an election and win it. All the replicas for a given master can start an election if the master is in <code>FAIL</code> state, however only one replica will win the election and promote itself to master.</p>
<p>A replica starts an election when the following conditions are met:</p>
<ul>
<li>The replica's master is in <code>FAIL</code> state.</li>
<li>The master was serving a non-zero number of slots.</li>
<li>The replica replication link was disconnected from the master for no longer than a given amount of time, in order to ensure the promoted replica's data is reasonably fresh. This time is user configurable.</li>
</ul>
<p>In order to be elected, the first step for a replica is to increment its <code>currentEpoch</code> counter, and request votes from master instances.</p>
<p>Votes are requested by the replica by broadcasting a <code>FAILOVER_AUTH_REQUEST</code> packet to every master node of the cluster. Then it waits for a maximum time of two times the <code>NODE_TIMEOUT</code> for replies to arrive (but always for at least 2 seconds).</p>
<p>Once a master has voted for a given replica, replying positively with a <code>FAILOVER_AUTH_ACK</code>, it can no longer vote for another replica of the same master for a period of <code>NODE_TIMEOUT * 2</code>. In this period it will not be able to reply to other authorization requests for the same master. This is not needed to guarantee safety, but useful for preventing multiple replicas from getting elected (even if with a different <code>configEpoch</code>) at around the same time, which is usually not wanted.</p>
<p>A replica discards any <code>AUTH_ACK</code> replies with an epoch that is less than the <code>currentEpoch</code> at the time the vote request was sent. This ensures it doesn't count votes intended for a previous election.</p>
<p>Once the replica receives ACKs from the majority of masters, it wins the election.
Otherwise if the majority is not reached within the period of two times <code>NODE_TIMEOUT</code> (but always at least 2 seconds), the election is aborted and a new one will be tried again after <code>NODE_TIMEOUT * 4</code> (and always at least 4 seconds).</p>
<h3 id="replica-rank">Replica rank</h3>
<p>As soon as a master is in <code>FAIL</code> state, a replica waits a short period of time before trying to get elected. That delay is computed as follows:</p>
<pre><code>DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +
        REPLICA_RANK * 1000 milliseconds.
</code></pre>
<p>The fixed delay ensures that we wait for the <code>FAIL</code> state to propagate across the cluster, otherwise the replica may try to get elected while the masters are still unaware of the <code>FAIL</code> state, refusing to grant their vote.</p>
<p>The random delay is used to desynchronize replicas so they're unlikely to start an election at the same time.</p>
<p>The <code>REPLICA_RANK</code> is the rank of this replica regarding the amount of replication data it has processed from the master.
Replicas exchange messages when the master is failing in order to establish a (best effort) rank:
the replica with the most updated replication offset is at rank 0, the second most updated at rank 1, and so forth.
In this way the most updated replicas try to get elected before others.</p>
<p>Rank order is not strictly enforced; if a replica of higher rank fails to be
elected, the others will try shortly.</p>
<p>Once a replica wins the election, it obtains a new unique and incremental <code>configEpoch</code> which is higher than that of any other existing master. It starts advertising itself as master in ping and pong packets, providing the set of served slots with a <code>configEpoch</code> that will win over the past ones.</p>
<p>In order to speedup the reconfiguration of other nodes, a pong packet is broadcast to all the nodes of the cluster. Currently unreachable nodes will eventually be reconfigured when they receive a ping or pong packet from another node or will receive an <code>UPDATE</code> packet from another node if the information it publishes via heartbeat packets are detected to be out of date.</p>
<p>The other nodes will detect that there is a new master serving the same slots served by the old master but with a greater <code>configEpoch</code>, and will upgrade their configuration. Replicas of the old master (or the failed over master if it rejoins the cluster) will not just upgrade the configuration but will also reconfigure to replicate from the new master. How nodes rejoining the cluster are configured is explained in the next sections.</p>
<h3 id="masters-reply-to-replica-vote-request">Masters reply to replica vote request</h3>
<p>In the previous section, we discussed how replicas try to get elected. This section explains what happens from the point of view of a master that is requested to vote for a given replica.</p>
<p>Masters receive requests for votes in form of <code>FAILOVER_AUTH_REQUEST</code> requests from replicas.</p>
<p>For a vote to be granted the following conditions need to be met:</p>
<ol>
<li>A master only votes a single time for a given epoch, and refuses to vote for older epochs: every master has a lastVoteEpoch field and will refuse to vote again as long as the <code>currentEpoch</code> in the auth request packet is not greater than the lastVoteEpoch. When a master replies positively to a vote request, the lastVoteEpoch is updated accordingly, and safely stored on disk.</li>
<li>A master votes for a replica only if the replica's master is flagged as <code>FAIL</code>.</li>
<li>Auth requests with a <code>currentEpoch</code> that is less than the master <code>currentEpoch</code> are ignored. Because of this the master reply will always have the same <code>currentEpoch</code> as the auth request. If the same replica asks again to be voted, incrementing the <code>currentEpoch</code>, it is guaranteed that an old delayed reply from the master can not be accepted for the new vote.</li>
</ol>
<p>Example of the issue caused by not using rule number 3:</p>
<p>Master <code>currentEpoch</code> is 5, lastVoteEpoch is 1 (this may happen after a few failed elections)</p>
<ul>
<li>Replica <code>currentEpoch</code> is 3.</li>
<li>Replica tries to be elected with epoch 4 (3+1), master replies with an ok with <code>currentEpoch</code> 5, however the reply is delayed.</li>
<li>Replica will try to be elected again, at a later time, with epoch 5 (4+1), the delayed reply reaches the replica with <code>currentEpoch</code> 5, and is accepted as valid.</li>
</ul>
<ol start="4">
<li>Masters don't vote for a replica of the same master before <code>NODE_TIMEOUT * 2</code> has elapsed if a replica of that master was already voted for. This is not strictly required as it is not possible for two replicas to win the election in the same epoch. However, in practical terms it ensures that when a replica is elected it has plenty of time to inform the other replicas and avoid the possibility that another replica will win a new election, performing an unnecessary second failover.</li>
<li>Masters make no effort to select the best replica in any way. If the replica's master is in <code>FAIL</code> state and the master did not vote in the current term, a positive vote is granted. The best replica is the most likely to start an election and win it before the other replicas, since it will usually be able to start the voting process earlier because of its <em>higher rank</em> as explained in the previous section.</li>
<li>When a master refuses to vote for a given replica there is no negative response, the request is simply ignored.</li>
<li>Masters don't vote for replicas sending a <code>configEpoch</code> that is less than any <code>configEpoch</code> in the master table for the slots claimed by the replica. Remember that the replica sends the <code>configEpoch</code> of its master, and the bitmap of the slots served by its master. This means that the replica requesting the vote must have a configuration for the slots it wants to failover that is newer or equal the one of the master granting the vote.</li>
</ol>
<h3 id="practical-example-of-configuration-epoch-usefulness-during-partitions">Practical example of configuration epoch usefulness during partitions</h3>
<p>This section illustrates how the epoch concept is used to make the replica promotion process more resistant to partitions.</p>
<ul>
<li>A master is no longer reachable indefinitely. The master has three replicas A, B, C.</li>
<li>Replica A wins the election and is promoted to master.</li>
<li>A network partition makes A not available for the majority of the cluster.</li>
<li>Replica B wins the election and is promoted as master.</li>
<li>A partition makes B not available for the majority of the cluster.</li>
<li>The previous partition is fixed, and A is available again.</li>
</ul>
<p>At this point B is down and A is available again with a role of master (actually <code>UPDATE</code> messages would reconfigure it promptly, but here we assume all <code>UPDATE</code> messages were lost). At the same time, replica C will try to get elected in order to fail over B. This is what happens:</p>
<ol>
<li>C will try to get elected and will succeed, since for the majority of masters its master is actually down. It will obtain a new incremental <code>configEpoch</code>.</li>
<li>A will not be able to claim to be the master for its hash slots, because the other nodes already have the same hash slots associated with a higher configuration epoch (the one of B) compared to the one published by A.</li>
<li>So, all the nodes will upgrade their table to assign the hash slots to C, and the cluster will continue its operations.</li>
</ol>
<p>As you'll see in the next sections, a stale node rejoining a cluster
will usually get notified as soon as possible about the configuration change
because as soon as it pings any other node, the receiver will detect it
has stale information and will send an <code>UPDATE</code> message.</p>
<h3 id="hash-slots-configuration-propagation">Hash slots configuration propagation</h3>
<p>An important part of Redis Cluster is the mechanism used to propagate the information about which cluster node is serving a given set of hash slots. This is vital to both the startup of a fresh cluster and the ability to upgrade the configuration after a replica was promoted to serve the slots of its failing master.</p>
<p>The same mechanism allows nodes partitioned away for an indefinite amount of
time to rejoin the cluster in a sensible way.</p>
<p>There are two ways hash slot configurations are propagated:</p>
<ol>
<li>Heartbeat messages. The sender of a ping or pong packet always adds information about the set of hash slots it (or its master, if it is a replica) serves.</li>
<li><code>UPDATE</code> messages. Since in every heartbeat packet there is information about the sender <code>configEpoch</code> and set of hash slots served, if a receiver of a heartbeat packet finds the sender information is stale, it will send a packet with new information, forcing the stale node to update its info.</li>
</ol>
<p>The receiver of a heartbeat or <code>UPDATE</code> message uses certain simple rules in
order to update its table mapping hash slots to nodes. When a new Redis Cluster node is created, its local hash slot table is simply initialized to <code>NULL</code> entries so that each hash slot is not bound or linked to any node. This looks similar to the following:</p>
<pre tabindex="0"><code>0 -&gt; NULL
1 -&gt; NULL
2 -&gt; NULL
...
16383 -&gt; NULL
</code></pre><p>The first rule followed by a node in order to update its hash slot table is the following:</p>
<p><strong>Rule 1</strong>: If a hash slot is unassigned (set to <code>NULL</code>), and a known node claims it, I'll modify my hash slot table and associate the claimed hash slots to it.</p>
<p>So if we receive a heartbeat from node A claiming to serve hash slots 1 and 2 with a configuration epoch value of 3, the table will be modified to:</p>
<pre tabindex="0"><code>0 -&gt; NULL
1 -&gt; A [3]
2 -&gt; A [3]
...
16383 -&gt; NULL
</code></pre><p>When a new cluster is created, a system administrator needs to manually assign (using the <a href="../../commands/cluster-addslots.html"><code>CLUSTER ADDSLOTS</code></a> command, via the redis-cli command line tool, or by any other means) the slots served by each master node only to the node itself, and the information will rapidly propagate across the cluster.</p>
<p>However this rule is not enough. We know that hash slot mapping can change
during two events:</p>
<ol>
<li>A replica replaces its master during a failover.</li>
<li>A slot is resharded from a node to a different one.</li>
</ol>
<p>For now let's focus on failovers. When a replica fails over its master, it obtains
a configuration epoch which is guaranteed to be greater than the one of its
master (and more generally greater than any other configuration epoch
generated previously). For example node B, which is a replica of A, may failover
A with configuration epoch of 4. It will start to send heartbeat packets
(the first time mass-broadcasting cluster-wide) and because of the following
second rule, receivers will update their hash slot tables:</p>
<p><strong>Rule 2</strong>: If a hash slot is already assigned, and a known node is advertising it using a <code>configEpoch</code> that is greater than the <code>configEpoch</code> of the master currently associated with the slot, I'll rebind the hash slot to the new node.</p>
<p>So after receiving messages from B that claim to serve hash slots 1 and 2 with configuration epoch of 4, the receivers will update their table in the following way:</p>
<pre tabindex="0"><code>0 -&gt; NULL
1 -&gt; B [4]
2 -&gt; B [4]
...
16383 -&gt; NULL
</code></pre><p>Liveness property: because of the second rule, eventually all nodes in the cluster will agree that the owner of a slot is the one with the greatest <code>configEpoch</code> among the nodes advertising it.</p>
<p>This mechanism in Redis Cluster is called <strong>last failover wins</strong>.</p>
<p>The same happens during resharding. When a node importing a hash slot completes
the import operation, its configuration epoch is incremented to make sure the
change will be propagated throughout the cluster.</p>
<h3 id="update-messages-a-closer-look">UPDATE messages, a closer look</h3>
<p>With the previous section in mind, it is easier to see how update messages
work. Node A may rejoin the cluster after some time. It will send heartbeat
packets where it claims it serves hash slots 1 and 2 with configuration epoch
of 3. All the receivers with updated information will instead see that
the same hash slots are associated with node B having a higher configuration
epoch. Because of this they'll send an <code>UPDATE</code> message to A with the new
configuration for the slots. A will update its configuration because of the
<strong>rule 2</strong> above.</p>
<h3 id="how-nodes-rejoin-the-cluster">How nodes rejoin the cluster</h3>
<p>The same basic mechanism is used when a node rejoins a cluster.
Continuing with the example above, node A will be notified
that hash slots 1 and 2 are now served by B. Assuming that these two were
the only hash slots served by A, the count of hash slots served by A will
drop to 0! So A will <strong>reconfigure to be a replica of the new master</strong>.</p>
<p>The actual rule followed is a bit more complex than this. In general it may
happen that A rejoins after a lot of time, in the meantime it may happen that
hash slots originally served by A are served by multiple nodes, for example
hash slot 1 may be served by B, and hash slot 2 by C.</p>
<p>So the actual <em>Redis Cluster node role switch rule</em> is: <strong>A master node will change its configuration to replicate (be a replica of) the node that stole its last hash slot</strong>.</p>
<p>During reconfiguration, eventually the number of served hash slots will drop to zero, and the node will reconfigure accordingly. Note that in the base case this just means that the old master will be a replica of the replica that replaced it after a failover. However in the general form the rule covers all possible cases.</p>
<p>Replicas do exactly the same: they reconfigure to replicate the node that
stole the last hash slot of its former master.</p>
<h3 id="replica-migration">Replica migration</h3>
<p>Redis Cluster implements a concept called <em>replica migration</em> in order to
improve the availability of the system. The idea is that in a cluster with
a master-replica setup, if the map between replicas and masters is fixed
availability is limited over time if multiple independent failures of single
nodes happen.</p>
<p>For example in a cluster where every master has a single replica, the cluster
can continue operations as long as either the master or the replica fail, but not
if both fail the same time. However there is a class of failures that are
the independent failures of single nodes caused by hardware or software issues
that can accumulate over time. For example:</p>
<ul>
<li>Master A has a single replica A1.</li>
<li>Master A fails. A1 is promoted as new master.</li>
<li>Three hours later A1 fails in an independent manner (unrelated to the failure of A). No other replica is available for promotion since node A is still down. The cluster cannot continue normal operations.</li>
</ul>
<p>If the map between masters and replicas is fixed, the only way to make the cluster
more resistant to the above scenario is to add replicas to every master, however
this is costly as it requires more instances of Redis to be executed, more
memory, and so forth.</p>
<p>An alternative is to create an asymmetry in the cluster, and let the cluster
layout automatically change over time. For example the cluster may have three
masters A, B, C. A and B have a single replica each, A1 and B1. However the master
C is different and has two replicas: C1 and C2.</p>
<p>Replica migration is the process of automatic reconfiguration of a replica
in order to <em>migrate</em> to a master that has no longer coverage (no working
replicas). With replica migration the scenario mentioned above turns into the
following:</p>
<ul>
<li>Master A fails. A1 is promoted.</li>
<li>C2 migrates as replica of A1, that is otherwise not backed by any replica.</li>
<li>Three hours later A1 fails as well.</li>
<li>C2 is promoted as new master to replace A1.</li>
<li>The cluster can continue the operations.</li>
</ul>
<h3 id="replica-migration-algorithm">Replica migration algorithm</h3>
<p>The migration algorithm does not use any form of agreement since the replica
layout in a Redis Cluster is not part of the cluster configuration that needs
to be consistent and/or versioned with config epochs. Instead it uses an
algorithm to avoid mass-migration of replicas when a master is not backed.
The algorithm guarantees that eventually (once the cluster configuration is
stable) every master will be backed by at least one replica.</p>
<p>This is how the algorithm works. To start we need to define what is a
<em>good replica</em> in this context: a good replica is a replica not in <code>FAIL</code> state
from the point of view of a given node.</p>
<p>The execution of the algorithm is triggered in every replica that detects that
there is at least a single master without good replicas. However among all the
replicas detecting this condition, only a subset should act. This subset is
actually often a single replica unless different replicas have in a given moment
a slightly different view of the failure state of other nodes.</p>
<p>The <em>acting replica</em> is the replica among the masters with the maximum number
of attached replicas, that is not in FAIL state and has the smallest node ID.</p>
<p>So for example if there are 10 masters with 1 replica each, and 2 masters with
5 replicas each, the replica that will try to migrate is - among the 2 masters
having 5 replicas - the one with the lowest node ID. Given that no agreement
is used, it is possible that when the cluster configuration is not stable,
a race condition occurs where multiple replicas believe themselves to be
the non-failing replica with the lower node ID (it is unlikely for this to happen
in practice). If this happens, the result is multiple replicas migrating to the
same master, which is harmless. If the race happens in a way that will leave
the ceding master without replicas, as soon as the cluster is stable again
the algorithm will be re-executed again and will migrate a replica back to
the original master.</p>
<p>Eventually every master will be backed by at least one replica. However,
the normal behavior is that a single replica migrates from a master with
multiple replicas to an orphaned master.</p>
<p>The algorithm is controlled by a user-configurable parameter called
<code>cluster-migration-barrier</code>: the number of good replicas a master
must be left with before a replica can migrate away. For example, if this
parameter is set to 2, a replica can try to migrate only if its master remains
with two working replicas.</p>
<h3 id="configepoch-conflicts-resolution-algorithm">configEpoch conflicts resolution algorithm</h3>
<p>When new <code>configEpoch</code> values are created via replica promotion during
failovers, they are guaranteed to be unique.</p>
<p>However there are two distinct events where new configEpoch values are
created in an unsafe way, just incrementing the local <code>currentEpoch</code> of
the local node and hoping there are no conflicts at the same time.
Both the events are system-administrator triggered:</p>
<ol>
<li><a href="../../commands/cluster-failover.html"><code>CLUSTER FAILOVER</code></a> command with <code>TAKEOVER</code> option is able to manually promote a replica node into a master <em>without the majority of masters being available</em>. This is useful, for example, in multi data center setups.</li>
<li>Migration of slots for cluster rebalancing also generates new configuration epochs inside the local node without agreement for performance reasons.</li>
</ol>
<p>Specifically, during manual resharding, when a hash slot is migrated from
a node A to a node B, the resharding program will force B to upgrade
its configuration to an epoch which is the greatest found in the cluster,
plus 1 (unless the node is already the one with the greatest configuration
epoch), without requiring agreement from other nodes.
Usually a real world resharding involves moving several hundred hash slots
(especially in small clusters). Requiring an agreement to generate new
configuration epochs during resharding, for each hash slot moved, is
inefficient. Moreover it requires a fsync in each of the cluster nodes
every time in order to store the new configuration. Because of the way it is
performed instead, we only need a new config epoch when the first hash slot is moved,
making it much more efficient in production environments.</p>
<p>However because of the two cases above, it is possible (though unlikely) to end
with multiple nodes having the same configuration epoch. A resharding operation
performed by the system administrator, and a failover happening at the same
time (plus a lot of bad luck) could cause <code>currentEpoch</code> collisions if
they are not propagated fast enough.</p>
<p>Moreover, software bugs and filesystem corruptions can also contribute
to multiple nodes having the same configuration epoch.</p>
<p>When masters serving different hash slots have the same <code>configEpoch</code>, there
are no issues. It is more important that replicas failing over a master have
unique configuration epochs.</p>
<p>That said, manual interventions or resharding may change the cluster
configuration in different ways. The Redis Cluster main liveness property
requires that slot configurations always converge, so under every circumstance
we really want all the master nodes to have a different <code>configEpoch</code>.</p>
<p>In order to enforce this, <strong>a conflict resolution algorithm</strong> is used in the
event that two nodes end up with the same <code>configEpoch</code>.</p>
<ul>
<li>IF a master node detects another master node is advertising itself with
the same <code>configEpoch</code>.</li>
<li>AND IF the node has a lexicographically smaller Node ID compared to the other node claiming the same <code>configEpoch</code>.</li>
<li>THEN it increments its <code>currentEpoch</code> by 1, and uses it as the new <code>configEpoch</code>.</li>
</ul>
<p>If there are any set of nodes with the same <code>configEpoch</code>, all the nodes but the one with the greatest Node ID will move forward, guaranteeing that, eventually, every node will pick a unique configEpoch regardless of what happened.</p>
<p>This mechanism also guarantees that after a fresh cluster is created, all
nodes start with a different <code>configEpoch</code> (even if this is not actually
used) since <code>redis-cli</code> makes sure to use <a href="../../commands/cluster-set-config-epoch.html"><code>CLUSTER SET-CONFIG-EPOCH</code></a> at startup.
However if for some reason a node is left misconfigured, it will update
its configuration to a different configuration epoch automatically.</p>
<h3 id="node-resets">Node resets</h3>
<p>Nodes can be software reset (without restarting them) in order to be reused
in a different role or in a different cluster. This is useful in normal
operations, in testing, and in cloud environments where a given node can
be reprovisioned to join a different set of nodes to enlarge or create a new
cluster.</p>
<p>In Redis Cluster nodes are reset using the <a href="../../commands/cluster-reset.html"><code>CLUSTER RESET</code></a> command. The
command is provided in two variants:</p>
<ul>
<li><code>CLUSTER RESET SOFT</code></li>
<li><code>CLUSTER RESET HARD</code></li>
</ul>
<p>The command must be sent directly to the node to reset. If no reset type is
provided, a soft reset is performed.</p>
<p>The following is a list of operations performed by a reset:</p>
<ol>
<li>Soft and hard reset: If the node is a replica, it is turned into a master, and its dataset is discarded. If the node is a master and contains keys the reset operation is aborted.</li>
<li>Soft and hard reset: All the slots are released, and the manual failover state is reset.</li>
<li>Soft and hard reset: All the other nodes in the nodes table are removed, so the node no longer knows any other node.</li>
<li>Hard reset only: <code>currentEpoch</code>, <code>configEpoch</code>, and <code>lastVoteEpoch</code> are set to 0.</li>
<li>Hard reset only: the Node ID is changed to a new random ID.</li>
</ol>
<p>Master nodes with non-empty data sets can't be reset (since normally you want to reshard data to the other nodes). However, under special conditions when this is appropriate (e.g. when a cluster is totally destroyed with the intent of creating a new one), <a href="../../commands/flushall.html"><code>FLUSHALL</code></a> must be executed before proceeding with the reset.</p>
<h3 id="removing-nodes-from-a-cluster">Removing nodes from a cluster</h3>
<p>It is possible to practically remove a node from an existing cluster by
resharding all its data to other nodes (if it is a master node) and
shutting it down. However, the other nodes will still remember its node
ID and address, and will attempt to connect with it.</p>
<p>For this reason, when a node is removed we want to also remove its entry
from all the other nodes tables. This is accomplished by using the
<code>CLUSTER FORGET &lt;node-id&gt;</code> command.</p>
<p>The command does two things:</p>
<ol>
<li>It removes the node with the specified node ID from the nodes table.</li>
<li>It sets a 60 second ban which prevents a node with the same node ID from being re-added.</li>
</ol>
<p>The second operation is needed because Redis Cluster uses gossip in order to auto-discover nodes, so removing the node X from node A, could result in node B gossiping about node X to A again. Because of the 60 second ban, the Redis Cluster administration tools have 60 seconds in order to remove the node from all the nodes, preventing the re-addition of the node due to auto discovery.</p>
<p>Further information is available in the <a href="../../commands/cluster-forget.html"><code>CLUSTER FORGET</code></a> documentation.</p>
<a class="dashAnchor" name="//apple_ref/Section/Publish%2FSubscribe"></a><h2 id="publishsubscribe">Publish/Subscribe</h2>
<p>In a Redis Cluster, clients can subscribe to every node, and can also
publish to every other node. The cluster will make sure that published
messages are forwarded as needed.</p>
<p>The clients can send SUBSCRIBE to any node and can also send PUBLISH to any node.
It will simply broadcast each published message to all other nodes.</p>
<p>Redis 7.0 and later features sharded pub/sub, in which shard channels are assigned to slots by the same algorithm used to assign keys to slots.
A shard message must be sent to a node that owns the slot the shard channel is hashed to.
The cluster makes sure the published shard messages are forwarded to all nodes in the shard, so clients can subscribe to a shard channel by connecting to either the master responsible for the slot, or to any of its replicas.</p>
<a class="dashAnchor" name="//apple_ref/Section/Appendix"></a><h2 id="appendix">Appendix</h2>
<h3 id="appendix-a-crc16-reference-implementation-in-ansi-c">Appendix A: CRC16 reference implementation in ANSI C</h3>
<pre><code>/*
 * Copyright 2001-2010 Georges Menie (www.menie.org)
 * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the University of California, Berkeley nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* CRC16 implementation according to CCITT standards.
 *
 * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the
 * following parameters:
 *
 * Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"
 * Width                      : 16 bit
 * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)
 * Initialization             : 0000
 * Reflect Input byte         : False
 * Reflect Output CRC         : False
 * Xor constant to output CRC : 0000
 * Output for "123456789"     : 31C3
 */

static const uint16_t crc16tab[256]= {
    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
};

uint16_t crc16(const char *buf, int len) {
    int counter;
    uint16_t crc = 0;
    for (counter = 0; counter &lt; len; counter++)
            crc = (crc&lt;&lt;8) ^ crc16tab[((crc&gt;&gt;8) ^ *buf++)&amp;0x00FF];
    return crc;
}
</code></pre>

          
  <form class="page-feedback" method="POST" name="page-feedback"><input type="hidden" name="form-name" value="page-feedback">
    <input name="origin" value="https://redis.io/docs/reference/cluster-spec/" class="hidden">
  <div class="grid justify-center mt-10 pt-10 border-t-2">
    <span class="font-bold font-small">Rate this page</span>
    <div class="star-rating">
      
      <input type="radio" id="5-stars" name="rating" value="5" onchange="document.querySelector('#feedback-form').classList.remove('hidden')">
      <label for="5-stars" class="star">★</label>
      
      <input type="radio" id="4-stars" name="rating" value="4" onchange="document.querySelector('#feedback-form').classList.remove('hidden')">
      <label for="4-stars" class="star">★</label>
      
      <input type="radio" id="3-stars" name="rating" value="3" onchange="document.querySelector('#feedback-form').classList.remove('hidden')">
      <label for="3-stars" class="star">★</label>
      
      <input type="radio" id="2-stars" name="rating" value="2" onchange="document.querySelector('#feedback-form').classList.remove('hidden')">
      <label for="2-stars" class="star">★</label>
      
      <input type="radio" id="1-stars" name="rating" value="1" onchange="document.querySelector('#feedback-form').classList.remove('hidden')">
      <label for="1-stars" class="star">★</label>
      
    </div>  
  </div>
  <div id="feedback-form" class="hidden">
    <div class="feedback-submit">
      <textarea name="comment" placeholder="Why did you choose this rating?" class="border border-neutral-500 p-2 mt-1 block w-full h-24" rows="3"></textarea>
      <button class="button button-indigo w-min justify-self-end" type="submit">
        Submit
      </button>
    </div>
  </div>
</form>
      </section>
    </div>
    

  <section class="hidden xl:block w-52 h-full shrink-0">
    <div class="w-52 z-40 hidden bg-white/75 md:block overflow-auto fixed top-28 h-full max-h-[calc(100vh-15rem)] text-[0.8125rem]">
      





<nav class="flex flex-col gap-1 mb-6 pb-2 border-b-2">
  <a href="https://github.com/redis/redis-doc/edit/master/docs/reference/cluster-spec.md" target="_blank" class="group inline-flex items-center gap-1 text-sm text-slate-700 hover:text-indigo-600 mt-auto self-start">
    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
      <path d="M11 44q-1.2 0-2.1-.9Q8 42.2 8 41V7q0-1.2.9-2.1Q9.8 4 11 4h17l12 12v7.8h-3V18H26V7H11v34h15v3Zm0-3V7v34Zm26.8-11.15 1.4 1.4-8.2 8.2V42h2.55l8.2-8.2 1.4 1.4-8.8 8.8H29v-5.35Zm5.35 5.35-5.35-5.35 3.05-3.05q.45-.45 1.05-.45.6 0 1.05.45l3.25 3.25q.45.45.45 1.05 0 .6-.45 1.05Z" fill="currentColor"></path>
    </svg>
    Edit this page
  </a>
  <a href="https://github.com/redis/redis-doc/issues/new?title=Redis%20cluster%20specification" target="_blank" class="group inline-flex items-center gap-1 text-sm text-slate-700 hover:text-indigo-600 mt-auto self-start">
    <svg class="w-4 h-4" viewBox="0 0 98 96" xmlns="http://www.w3.org/2000/svg">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="currentColor"></path>
    </svg>
    Create an issue
  </a>
</nav>


      
        <h1 class="font-semibold my-3">On This Page</h1>
        <nav class="text-slate-700">
          <nav id="TableOfContents">
  <ul>
    <li><a href="#main-properties-and-rationales-of-the-design">Main properties and rationales of the design</a>
      <ul>
        <li><a href="#redis-cluster-goals">Redis Cluster goals</a></li>
        <li><a href="#implemented-subset">Implemented subset</a></li>
      </ul>
    </li>
    <li><a href="#client-and-server-roles-in-the-redis-cluster-protocol">Client and Server roles in the Redis cluster protocol</a>
      <ul>
        <li><a href="#write-safety">Write safety</a></li>
        <li><a href="#availability">Availability</a></li>
        <li><a href="#performance">Performance</a></li>
        <li><a href="#why-merge-operations-are-avoided">Why merge operations are avoided</a></li>
      </ul>
    </li>
    <li><a href="#overview-of-redis-cluster-main-components">Overview of Redis Cluster main components</a>
      <ul>
        <li><a href="#key-distribution-model">Key distribution model</a></li>
        <li><a href="#hash-tags">Hash tags</a></li>
        <li><a href="#cluster-node-attributes">Cluster node attributes</a></li>
        <li><a href="#the-cluster-bus">The cluster bus</a></li>
        <li><a href="#cluster-topology">Cluster topology</a></li>
        <li><a href="#node-handshake">Node handshake</a></li>
      </ul>
    </li>
    <li><a href="#redirection-and-resharding">Redirection and resharding</a>
      <ul>
        <li><a href="#moved-redirection">MOVED Redirection</a></li>
        <li><a href="#live-reconfiguration">Live reconfiguration</a></li>
        <li><a href="#ask-redirection">ASK redirection</a></li>
        <li><a href="#client-connections-and-redirection-handling">Client connections and redirection handling</a></li>
        <li><a href="#multi-keys-operations">Multi-keys operations</a></li>
        <li><a href="#scaling-reads-using-replica-nodes">Scaling reads using replica nodes</a></li>
      </ul>
    </li>
    <li><a href="#fault-tolerance">Fault Tolerance</a>
      <ul>
        <li><a href="#heartbeat-and-gossip-messages">Heartbeat and gossip messages</a></li>
        <li><a href="#heartbeat-packet-content">Heartbeat packet content</a></li>
        <li><a href="#failure-detection">Failure detection</a></li>
      </ul>
    </li>
    <li><a href="#configuration-handling-propagation-and-failovers">Configuration handling, propagation, and failovers</a>
      <ul>
        <li><a href="#cluster-current-epoch">Cluster current epoch</a></li>
        <li><a href="#configuration-epoch">Configuration epoch</a></li>
        <li><a href="#replica-election-and-promotion">Replica election and promotion</a></li>
        <li><a href="#replica-rank">Replica rank</a></li>
        <li><a href="#masters-reply-to-replica-vote-request">Masters reply to replica vote request</a></li>
        <li><a href="#practical-example-of-configuration-epoch-usefulness-during-partitions">Practical example of configuration epoch usefulness during partitions</a></li>
        <li><a href="#hash-slots-configuration-propagation">Hash slots configuration propagation</a></li>
        <li><a href="#update-messages-a-closer-look">UPDATE messages, a closer look</a></li>
        <li><a href="#how-nodes-rejoin-the-cluster">How nodes rejoin the cluster</a></li>
        <li><a href="#replica-migration">Replica migration</a></li>
        <li><a href="#replica-migration-algorithm">Replica migration algorithm</a></li>
        <li><a href="#configepoch-conflicts-resolution-algorithm">configEpoch conflicts resolution algorithm</a></li>
        <li><a href="#node-resets">Node resets</a></li>
        <li><a href="#removing-nodes-from-a-cluster">Removing nodes from a cluster</a></li>
      </ul>
    </li>
    <li><a href="#publishsubscribe">Publish/Subscribe</a></li>
    <li><a href="#appendix">Appendix</a>
      <ul>
        <li><a href="#appendix-a-crc16-reference-implementation-in-ansi-c">Appendix A: CRC16 reference implementation in ANSI C</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </nav>
        
    </div>
  </section>


  </main>


    <footer class="bg-midnight-700 relative z-50">
      <p class="container max-w-[85rem] mx-auto px-4 sm:px-8 py-8 text-slate-400 text-sm text-center">
  This is a community website sponsored by <a href="https://redis.com/" class="text-white underline underline-offset-1 decoration-transparent hover:decoration-slate-500 transition-colors">Redis Ltd.</a> © 2023. Redis and the cube logo are registered trademarks of Redis Ltd. <a href="../../terms.html" class="text-white underline underline-offset-1 decoration-transparent hover:decoration-slate-500 transition-colors">Terms of use &amp; privacy policy</a>.
</p>

      <script>
  
  document.addEventListener('DOMContentLoaded', () => {

    const TableOfContents = {
      container: document.querySelector('#TableOfContents'),
      links: null,
      headings: null,
      intersectionOptions: {
        rootMargin: '0px',
        threshold: 1
      },
      previousSection: null,
      observer: null,

      init() {
        if (!this.container) return false

        this.handleObserver = this.handleObserver.bind(this)
        this.setUpObserver()
        this.findLinksAndHeadings()
        this.observeSections()
      },

      handleObserver(entries, observer) {
        entries.forEach(entry => {
          let href = `#${entry.target.getAttribute('id')}`
          let link = this.links.find(l => l.getAttribute('href') === href)

          if (entry.isIntersecting && entry.intersectionRatio >= 1) {
            link.classList.add('visible')
            this.previousSection = entry.target.getAttribute('id')
          } else {
            link.classList.remove('visible')
          }

          this.highlightFirstActive()
        })
      },

      highlightFirstActive() {
        let firstVisibleLink = this.container.querySelector('.visible')

        this.links.forEach(link => {
          link.classList.remove('active')
        })

        if (firstVisibleLink) {
          firstVisibleLink.classList.add('active')
        }

        if (!firstVisibleLink && this.previousSection) {
          this.container.querySelector(
            `a[href="#${this.previousSection}"]`
          ).classList.add('active')
        }
      },

      observeSections() {
        this.headings.forEach(heading => {
          this.observer.observe(heading)
        })
      },

      setUpObserver() {
        this.observer = new IntersectionObserver(
          this.handleObserver,
          this.intersectionOptions
        )
      },

      findLinksAndHeadings() {
        this.links = [...this.container.querySelectorAll('a')]
        this.headings = this.links.map(link => {
          let id = link.getAttribute('href')
          return document.querySelector(id)
        })
      }
    }

    TableOfContents.init()

})
</script>
    </footer>

    
<div class="sr-only w-screen h-screen fixed z-[200] top-0 left-0 cursor-auto flex flex-col bg-slate-900/75 p-4 sm:p-6 md:p-[10vh] lg:p-[12vh]" id="search-container" role="button" aria-expanded="true" aria-haspopup="listbox" aria-labelledby="search-label" tabindex="0">
  <div class="search-modal">
    <header class="search-bar">
      <form id="search-form" class="search-form">
        <label class="search-magnifier-label" for="search-input" id="search-label">
          <svg width="20" height="20" class="search-icon" viewBox="0 0 20 20">
            <path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path>
          </svg>
        </label>
        <div class="search-loading-indicator">
          <svg viewBox="0 0 38 38" stroke="currentColor" stroke-opacity=".5">
            <g fill="none" fill-rule="evenodd">
              <g transform="translate(1 1)" stroke-width="2">
                <circle stroke-opacity=".3" cx="18" cy="18" r="18"></circle>
                <path d="M36 18c0-9.94-8.06-18-18-18">
                  <animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="1s" repeatCount="indefinite"></animateTransform>
                </path>
              </g>
            </g>
          </svg>
        </div>
        <input class="search-input" aria-autocomplete="both" aria-labelledby="search-label" id="search-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search…" maxlength="64" type="search" value="">
        <button type="reset" title="Clear the query" class="search-reset" aria-label="Clear the query" hidden="">
          <svg width="20" height="20" viewBox="0 0 20 20">
            <path d="M10 10l5.09-5.09L10 10l5.09 5.09L10 10zm0 0L4.91 4.91 10 10l-5.09 5.09L10 10z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path>
          </svg>
        </button>
      </form>
      <button id="search-cancel" type="reset" aria-label="Cancel">
        Cancel
      </button>
    </header>
    <dl id="search-results" class="search-results" role="listbox"></dl>
    <footer class="search-footer">
      <a href="../stack/search.html" target="_blank" rel="noopener noreferrer">
        <span class="logo-label">Powered by Redis Stack</span>
        
        <svg viewBox="0 0 39 31" fill="none"><path d="M21.7371 15.2903C21.5759 15.2895 21.4198 15.2337 21.2947 15.1321 21.1695 15.0305 21.0828 14.8892 21.049 14.7316S21.0362 14.4096 21.1086 14.2655C21.1811 14.1215 21.3005 14.0066 21.4472 13.9397L35.7199 7.47338 21.4578 1.34289C21.2943 1.26329 21.1678 1.12377 21.1045.953307 21.0412.78285 21.046.594558 21.1179.427547 21.1898.260535 21.3233.127641 21.4906.0564719 21.6579-.0146977 21.8462-.0186728 22.0164.045373L37.7492 6.80518C37.8747 6.8605 37.9814 6.95112 38.0563 7.06599S38.171 7.31503 38.171 7.45216 38.1312 7.72347 38.0563 7.83834C37.9814 7.95321 37.8747 8.04383 37.7492 8.09915L22.0306 15.2266C21.9388 15.2698 21.8385 15.2916 21.7371 15.2903z" fill="#db2e2e"></path><path d="M16.4339 15.2903C16.3379 15.2906 16.2429 15.2714 16.1546 15.2337L.421813 8.47393C.296339 8.41861.18966 8.32799.114767 8.21312.0398745 8.09825.0 7.96407.0 7.82694.0 7.68981.0398745 7.55564.114767 7.44077.18966 7.3259.296339 7.23528.421813 7.17995L16.1546.052465C16.3235-.0111265 16.5104-.00772359 16.6768.0619772 16.8433.131678 16.9768.2624 17.0501.427363 17.1233.592325 17.1306.779042 17.0706.949259 17.0106 1.11948 16.8878 1.26031 16.7274 1.34291L2.44763 7.80573 16.7132 13.9362C16.8612 14.0015 16.9823 14.1154 17.0565 14.2592 17.1306 14.4029 17.1532 14.5677 17.1205 14.7261 17.0878 14.8845 17.0019 15.0269 16.8769 15.1295 16.752 15.2322 16.5956 15.2889 16.4339 15.2903z" fill="#db2e2e"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M29.1651 17.4328c3.1288-1.2763 6.2047-2.5279 7.1875-3.0617L37.1163 13.9539C37.3908 13.8108 37.6564 13.6514 37.9118 13.4766 37.972 13.8833 37.972 14.2967 37.9118 14.7034 37.8022 15.1312 37.4875 15.4847 36.289 16.061 35.4617 16.4605 33.1531 17.408 30.5792 18.4687c-3.6167 1.4884-7.778 3.1819-9.0826 3.889C19.2587 23.4183 18.0284 23.4183 16.3137 22.644 15.4864 22.2021 12.4918 20.9117 9.39476 19.5611c-3.3198-1.446-6.75627-2.945-7.77802-3.4753C.22377 15.3575.153061 15.1948.160132 14.8271V13.8655L.513678 14.0564c1.311652.6647 7.219412 3.1819 11.486722 5.0204 2.1142.898 3.8112 1.6298 4.3769 1.8844C18.092 21.7319 19.3082 21.8733 21.5603 20.6748 22.7022 20.0808 25.9619 18.7409 29.1651 17.4328z" fill="#494c4d"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M29.1651 24.5037c3.1288-1.2763 6.2047-2.5279 7.1875-3.0617L37.1163 21.0248C37.3908 20.8817 37.6564 20.7223 37.9118 20.5475 37.972 20.9542 37.972 21.3676 37.9118 21.7743 37.8022 22.2021 37.4875 22.5557 36.289 23.1319 35.4617 23.5314 33.1531 24.4789 30.5792 25.5396c-3.6167 1.4884-7.778 3.1819-9.0826 3.889-2.2379 1.0606-3.4682 1.0606-5.1829.2864C15.4864 29.2801 12.4918 27.9755 9.39476 26.625c-3.3198-1.446-6.75627-2.9451-7.77802-3.4754C.22377 22.4213.153061 22.2587.160132 21.891V20.9364L.513678 21.1273C1.82533 21.792 7.73309 24.3092 12.0004 26.1477c2.1001.898 3.8006 1.6298 4.3663 1.8844C18.0814 28.8028 19.2976 28.9442 21.5497 27.7457 22.7022 27.1518 25.9619 25.8118 29.1651 24.5037z" fill="#494c4d"></path></svg>
      </a>
    </footer>
  </div>
</div>

<script>
  const searchModal = (() => {
    const searchButton = document.querySelector('#search-button')
    const searchContainer = document.querySelector('#search-container')
    const searchInput = searchContainer.querySelector('#search-input')
    const resultsContainer = searchContainer.querySelector('#search-results')
    const style = document.createElement('style')
    
    let keys = {}
    let focusable
    let firstFocusable
    let lastFocusable
  
    function next (elem, selector) {
      let nextElem = elem.nextElementSibling
      if (!selector) return nextElem
      if (nextElem && nextElem.matches(selector)) return nextElem
      return null
    }
  
    function debounce(callback, delay) {
      let timeout
      
      return function() {
        clearTimeout(timeout)
        timeout = setTimeout(callback, delay)
      }
    }
  
    function searchSubmit(form) {
      if (form.id !== 'search-form') return false
  
      const searchTerm = searchInput.value
  
      if (searchTerm.length < 1) {
        resultsContainer.innerHTML = ''
        return
      }
  
      function search(url) {
        let promise = new Promise((resolve, reject) => {
          const req = new XMLHttpRequest()
          req.open('GET', url)
          req.onload = function() {
            if (req.status === 200) {
              resolve(JSON.parse(req.response))
            } else {
              reject(Error(req.status))
            }
          }
          req.send()
        })
  
        return promise
      }
  
      function sortData(data) {
        
        const getCategories = (data) =>
          data.reduce((a, c) => {
            if (!a.includes(c.hierarchy[0])) {
              a.push(c.hierarchy[0])
            }
  
            return a
          }, [])

        
        const constructSectionTitle = (record) => {
          if (record.hierarchy && record.hierarchy.length > 2) {
            return record.hierarchy[1]
          } else {
            return record.title
          }
        }

        
        const mergeData = (data, categories) =>
          categories.map((category) => {
            const obj = {}
            obj.category = category
  
            data.forEach((record) => {
              if (record.hierarchy[0] === category) {
                obj[record.title] = {
                  path: constructSectionTitle(record),
                  url: record.url,
                }
              }
            })
  
            return obj
          })
  
        return mergeData(data.results, getCategories(data.results))
      }
  
      function escape_evil_chars(str_in) {
        return str_in.replaceAll('>','&gt;').replaceAll('<', '&lt;').replaceAll('&', '&amp;').replaceAll('"','&quot;').replaceAll("'",'&#x27;')
      }   
      
      function displayData(data) {
        resultsContainer.innerHTML = ''
        
        if (data.results.length < 1) {
          escapedSearchTerm = escape_evil_chars(searchTerm)
          resultsContainer.insertAdjacentHTML(
            'beforeend',
            `<dt class="sr-only">${escapedSearchTerm}:</dt>
            <dd class="search-no-results">
              No results for \"<span class="search-title">${escapedSearchTerm}</span>\"
            </dd>`
          )
        } else {
          sortData(data).forEach((result) => {
            resultsContainer.insertAdjacentHTML(
              'beforeend', 
              `<dt class="search-item-source">
                ${result.category}
              </dt>`
            )
    
            delete result.category
    
            Object.keys(result).forEach((key, index) => {
              resultsContainer.insertAdjacentHTML(
                'beforeend',
                `<dd class="search-item" role="option">
                  <a href="${result[key].url}">
                    <span class="search-item-icon"></span>
                    <span class="search-item-content">
                      ${result[key].path ? `<span class="search-item-path">${result[key].path}</span>` : ''}
                      <span class="search-item-title">${key.replace(new RegExp(`(^|)(${searchTerm})(|$)`, 'ig'), '$1<b class="search-term-match">$2</b>$3')}</span>
                    </span>
                    <span class="search-item-action"></span>
                  </a>
                </dd>`
              )
            })
            
            if (!resultsContainer.querySelector('[aria-selected]')) resultsContainer.querySelector('.search-item').setAttribute('aria-selected', '')
          })
        }
        return
      }
  
      function displayError(error) {
        console.log(error)
      }
  
      search(`https://search-service.redislabs.com/search?q=${searchTerm}*&site=https://redis.io`)
        .then(displayData)
        .catch(displayError)
    }
  
    function loadHandler(event) {
      style.innerHTML = `
        [data-scroll-disabled="on"], 
        [data-scroll-disabled="on"] body {
          touch-action: none;
          overscroll-behavior: none;
          -webkit-overflow-scrolling: auto;
          overflow: hidden;
        }
  
        [data-scroll-disabled="on"] .sticky {
          position: fixed;
        }
      `
  
      document.head.appendChild(style)
      document.documentElement.dataset.searchState = 'off'
    }
  
    function getNextSibling(elem, selector, direction) {
      let sibling = direction === 'down' ? elem.nextElementSibling : elem.previousElementSibling
    
      while (sibling) {
        if (sibling.matches(selector)) return sibling
        sibling = direction === 'down' ? sibling.nextElementSibling : sibling.previousElementSibling
      }
    }
  
    function tabSelection(direction) {
      const currentSelection = resultsContainer.querySelector('[aria-selected]')
      if (!currentSelection || direction === 'down' && !currentSelection.nextElementSibling || direction === 'up' && !currentSelection.previousElementSibling) return false
        
      const nextSelection = getNextSibling(currentSelection, '.search-item', direction)
      if (!nextSelection) return false
      
      nextSelection.setAttribute('aria-selected', '')
      currentSelection.removeAttribute('aria-selected')
      resultsContainer.scrollTop = nextSelection.offsetTop - resultsContainer.offsetTop
    }
    
    function keyDownHandler(event) {
      switch (event.key) {
  
        // Arrow keys
        case 'ArrowDown':
          if (document.documentElement.dataset.searchState === 'off' || !document.querySelector('.search-item')) return false
          event.preventDefault()
          tabSelection('down')
          break
  
        case 'ArrowUp':
          if (document.documentElement.dataset.searchState === 'off' || !document.querySelector('.search-item')) return false
          event.preventDefault()
          tabSelection('up')
          break
  
        // Tab
        case 'Tab':
          if (document.documentElement.dataset.searchState === 'off') return false
  
          if (focusable.length === 1) {
            event.preventDefault()
            break
          }
  
          // If shift is fired, tab backward
          if (event.shiftKey) {
            if (document.activeElement === firstFocusable) {
              event.preventDefault()
              lastFocusable.focus()
            }
  
            // Otherwise tab forward
          } else {
            if (document.activeElement === lastFocusable) {
              event.preventDefault()
              firstFocusable.focus()
            }
          }
          break
  
        // Esc
        case 'Escape':
          if (document.documentElement.dataset.searchState === 'off') return false
          stopSearch()
          break
        
        // Enter
        case 'Enter':
          if (!document.querySelector('.search-item:focus-within') && document.querySelector('.search-item[aria-selected]')) {
            event.preventDefault()
            document.querySelector('.search-item[aria-selected] a').click()
          }
          break
  
        // Forward slash
        case '/':
          if (document.documentElement.dataset.searchState === 'on') return false
          event.preventDefault()
          startSearch()
          break
      
        // Default
        default:
          return false
          break
      }
    }
  
    function keyUpHandler(event) {
      if (document.documentElement.dataset.searchState === 'off' || !document.activeElement.matches('.search-input')) return false
      
      switch (event.key) {
        case 'ArrowDown':
          return false
          break
        case 'ArrowUp':
          return false
          break
        case 'ArrowLeft':
          return false
          break
        case 'ArrowRight':
          return false
          break
        case 'Tab':
          return false
          break
        case 'Escape':
          return false
          break
        case 'Enter':
          return false
          break
        case '/':
          return false
          break
        default:
          searchSubmit(document.activeElement.closest('form'))
          break
      }
    }
  
    function multiKeyHandler(event) {
      if (document.documentElement.dataset.searchState === 'on') return false
  
      let { key, type } = event
      let isKeyDown = (type == 'keydown')
      keys[key] = isKeyDown
  
      // Both (cmd || cntrl) & k pressed
      if (isKeyDown && (keys.Control || keys.Meta) && keys.k) {
        event.preventDefault()
        startSearch()
      }
    }
  
    // Click handler function
    function clickHandler(event) {
      if (event.target.closest('#search-button')) {
        startSearch()
      } else if (event.target.closest('#search-cancel') || event.target.matches('#search-container')) {
        stopSearch()
      }
    }
  
    function startSearch() {
      sessionStorage.setItem('scroll-position', document.documentElement.scrollTop)
      document.documentElement.dataset.scrollDisabled = 'on'
      document.documentElement.dataset.searchState = 'on'
      allowFocus(searchContainer, true)
      trapFocus(searchContainer)
      searchInput.focus()
    }
  
    function stopSearch() {
      document.documentElement.dataset.searchState = 'off'
      document.documentElement.dataset.scrollDisabled = 'off'
      document.documentElement.scrollTop = sessionStorage.getItem('scroll-position')
      allowFocus(searchContainer, false)
      document.activeElement.blur()
      resultsContainer.innerHTML = ''
      searchInput.value = ''
      keys = {}
    }
  
    function submitHandler(event) {
      if (event.target.id === 'search-form') {
        event.preventDefault()
        return false
      }
    }
  
    function allowFocus(selector, state) {
      const focusable = selector.querySelectorAll('button, [href], input, select, textarea')
      focusable.forEach(el => el.setAttribute('tabindex', state ? '' : '-1'))
      selector.classList.toggle('sr-only')
    }
  
    function trapFocus(selector) {
      focusable = selector.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"]')
      firstFocusable = focusable[0]
      lastFocusable = focusable[focusable.length - 1]
    }
  
    // Attach event listeners
    document.addEventListener('DOMContentLoaded', loadHandler)
    document.addEventListener('click', clickHandler)
    document.addEventListener('keydown', event => debounce(keyDownHandler(event), 100))
    document.addEventListener('keyup', event => debounce(keyUpHandler(event), 100))
    document.addEventListener('keydown', multiKeyHandler)
    document.addEventListener('keyup', multiKeyHandler)
    document.addEventListener('submit', submitHandler)
  })()
</script>
  

</body></html>