<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Nvim documentation: lua</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Nvim documentation: lua</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="lua.txt"></A><B>lua.txt</B>*    Nvim


                            NVIM REFERENCE MANUAL



<A HREF="#Lua">Lua</A> engine                                                           *<A NAME="lua"></A><B>lua</B>* *<A NAME="Lua"></A><B>Lua</B>*

                                       Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

INTRODUCTION                                                       *<A NAME="lua-intro"></A><B>lua-intro</B>*

The <A HREF="#Lua">Lua</A> 5.1 language is builtin and always available. Try this command to get
an idea of what lurks beneath:

<B>    :lua print(vim.inspect(package.loaded))</B>
 
Nvim includes a &quot;standard library&quot; |<A HREF="#lua-stdlib">lua-stdlib</A>| for <A HREF="#Lua">Lua</A>. It complements the
&quot;editor stdlib&quot; (|<A HREF="builtin.html#builtin-functions">builtin-functions</A>| and <A HREF="intro.html#Ex">Ex</A> commands) and the |<A HREF="api.html#API">API</A>|, all of
which can be used from <A HREF="#Lua">Lua</A> code. A good overview of using <A HREF="#Lua">Lua</A> in neovim is
given by https://github.com/nanotee/nvim-lua-guide.

The |<A HREF="repeat.html#:source">:source</A>| and |<A HREF="repeat.html#:runtime">:runtime</A>| commands can run <A HREF="#Lua">Lua</A> scripts <A HREF="motion.html#as">as</A> well <A HREF="motion.html#as">as</A> Vim
scripts. <A HREF="#Lua">Lua</A> modules can be loaded with `require('name')`, which
conventionally returns a table but can return any value.

See |<A HREF="#lua-require">lua-require</A>| for details on how Nvim finds and loads <A HREF="#Lua">Lua</A> modules.
See |<A HREF="#lua-require-example">lua-require-example</A>| for an example of how to write and use a module.

==============================================================================

IMPORTING LUA MODULES                                            *<A NAME="lua-require"></A><B>lua-require</B>*

Modules are searched for under the directories specified in <A HREF="options.html#'runtimepath'">'runtimepath'</A>, in
the order they appear. Any `.` in the module name is treated <A HREF="motion.html#as">as</A> a directory
separator when searching. For a module `foo.bar`, each directory is searched
for `lua/foo/bar.lua`, then `lua/foo/bar/init.lua`. If no files are found,
the directories are searched again for a shared library with a name matching
`lua/foo/bar.?`, where `?` is a <A HREF="eval.html#list">list</A> of <A HREF="cmdline.html#suffixes">suffixes</A> (such <A HREF="motion.html#as">as</A> `so` or `dll`) derived from
the initial value of |<A HREF="package.html">package.cpath</A>|. If still no files are found, Nvim falls
back to Lua's default search mechanism. The first <A HREF="usr_41.html#script">script</A> found is run and
`require()` returns the value returned by the <A HREF="usr_41.html#script">script</A> if any, else `true`.

The return value is cached after the first call to `require()` for each module,
with subsequent calls returning the cached value without searching for, or
executing any <A HREF="usr_41.html#script">script</A>. For further details on `require()`, see the <A HREF="#Lua">Lua</A>
documentation at https://www.lua.org/manual/5.1/manual.html#pdf-require.

For example, if <A HREF="options.html#'runtimepath'">'runtimepath'</A> is `foo,bar` and |<A HREF="package.html">package.cpath</A>| was
`./?.so;./?.dll` at <A HREF="starting.html#startup">startup</A>, `require('mod')` searches these paths in order
and loads the first module found:

    foo/lua/mod.lua
    foo/lua/mod/init.lua
    bar/lua/mod.lua
    bar/lua/mod/init.lua
    foo/lua/mod.so
    foo/lua/mod.dll
    bar/lua/mod.so
    bar/lua/mod.dll

Nvim automatically adjusts |<A HREF="package.html">package.path</A>| and |<A HREF="package.html">package.cpath</A>| according to the
effective <A HREF="options.html#'runtimepath'">'runtimepath'</A> value. Adjustment happens whenever <A HREF="options.html#'runtimepath'">'runtimepath'</A> is
changed. |<A HREF="package.html">package.path</A>| is adjusted by simply appending `/lua/?.lua` and
`/lua/?/init.lua` to each directory from <A HREF="options.html#'runtimepath'">'runtimepath'</A> (`/` is actually the
first character of `package.config`).

Similarly to |<A HREF="package.html">package.path</A>|, modified directories from <A HREF="options.html#'runtimepath'">'runtimepath'</A> are also
added to |<A HREF="package.html">package.cpath</A>|. In this <A HREF="change.html#case">case</A>, instead of appending `/lua/?.lua` and
`/lua/?/init.lua` to each runtimepath, all unique `?`-containing <A HREF="cmdline.html#suffixes">suffixes</A> of
the existing |<A HREF="package.html">package.cpath</A>| are used. Example:

1. Given that
   - <A HREF="options.html#'runtimepath'">'runtimepath'</A> contains `/foo/bar,/xxx;yyy/baz,/abc`;
   - initial (defined at compile-time or derived from
     `$LUA_CPATH`/`$LUA_INIT`) |<A HREF="package.html">package.cpath</A>| contains
     `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`.
2. It finds `?`-containing <A HREF="cmdline.html#suffixes">suffixes</A> `/?.so`, `/a?d/j/g.elf` and `/?.so`, in
   order: parts of the path starting from the first path component containing
   question <A HREF="motion.html#mark">mark</A> and preceding path separator.
3. The suffix of `/def/?.so`, namely `/?.so` is not unique, <A HREF="motion.html#as">as</A> it’s the same
   <A HREF="motion.html#as">as</A> the suffix of the first path from |<A HREF="package.html">package.path</A>| (i.e. `./?.so`). Which
   leaves `/?.so` and `/a?d/j/g.elf`, in this order.
4. <A HREF="options.html#'runtimepath'">'runtimepath'</A> has three paths: `/foo/bar`, `/xxx;yyy/baz` and `/abc`. The
   second one contains a semicolon which is a paths separator so <A HREF="motion.html#it">it</A> is out,
   leaving only `/foo/bar` and `/abc`, in order.
5. The cartesian product of paths from 4. and <A HREF="cmdline.html#suffixes">suffixes</A> from 3. is taken,
   giving four variants. In each variant, a `/lua` path segment is inserted
   between path and suffix, leaving:

   - `/foo/bar/lua/?.so`
   - `/foo/bar/lua/a?d/j/g.elf`
   - `/abc/lua/?.so`
   - `/abc/lua/a?d/j/g.elf`

6. New paths are prepended to the original |<A HREF="package.html">package.cpath</A>|.

The result will look like this:

    `/foo/bar,/xxx;yyy/baz,/abc` ('runtimepath')
    × `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so` (`package.cpath`)

    = `/foo/bar/lua/?.so;/foo/bar/lua/a?d/j/g.elf;/abc/lua/?.so;/abc/lua/a?d/j/g.elf;./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`

Note:

- To track <A HREF="options.html#'runtimepath'">'runtimepath'</A> updates, paths added at previous update are
  remembered and removed at the next update, while all paths derived from the
  new <A HREF="options.html#'runtimepath'">'runtimepath'</A> are prepended <A HREF="motion.html#as">as</A> described above. This allows removing
  paths when path is removed from <A HREF="options.html#'runtimepath'">'runtimepath'</A>, adding paths when they are
  added and reordering |<A HREF="package.html">package.path</A>|/|<A HREF="package.html">package.cpath</A>| content if <A HREF="options.html#'runtimepath'">'runtimepath'</A>
  was reordered.

- Although adjustments happen automatically, Nvim does not track current
  values of |<A HREF="package.html">package.path</A>| or |<A HREF="package.html">package.cpath</A>|. If you happen to delete some
  paths from there you can set <A HREF="options.html#'runtimepath'">'runtimepath'</A> to trigger an update:
<B>      let &amp;runtimepath = &amp;runtimepath</B>

- Skipping paths from <A HREF="options.html#'runtimepath'">'runtimepath'</A> which contain semicolons applies both to
  |<A HREF="package.html">package.path</A>| and |<A HREF="package.html">package.cpath</A>|. Given that there are some badly written
  plugins using shell, which will not work with paths containing semicolons,
  <A HREF="motion.html#it">it</A> is better to not have them in <A HREF="options.html#'runtimepath'">'runtimepath'</A> at all.

==============================================================================

<A HREF="#Lua">Lua</A> <A HREF="autocmd.html#Syntax">Syntax</A> Information                                       *<A NAME="lua-syntax-help"></A><B>lua-syntax-help</B>*

While <A HREF="#Lua">Lua</A> has a simple <A HREF="syntax.html#syntax">syntax</A>, there are a few things to understand,
particularly when looking at the documentation above.


                                                    *<A NAME="lua-syntax-call-function"></A><B>lua-syntax-call-function</B>*

<A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A> can be called in multiple ways. Consider the function:

<B>    local example_func = function(a, b)</B>
<B>        print("A is: ", a)</B>
<B>        print("B is: ", b)</B>
<B>    end</B>
 
The first way to call this function is:

<B>    example_func(1, 2)</B>
<B>    -- ==== Result ====</B>
<B>    -- A is: 1</B>
<B>    -- B is: 2</B>
 
This way of calling a function is familiar from most scripting languages.
In <A HREF="#Lua">Lua</A>, it's important to understand that any function arguments that are
not supplied are automatically set to `nil`. For example:

<B>    example_func(1)</B>
<B>    -- ==== Result ====</B>
<B>    -- A is: 1</B>
<B>    -- B is: nil</B>
 
Additionally, if any extra parameters are passed, they are discarded
completely.

In <A HREF="#Lua">Lua</A>, <A HREF="motion.html#it">it</A> is also possible to omit the parentheses (only) if the function
takes a single <A HREF="eval.html#string">string</A> or table literal (`&quot;foo&quot;` or &quot;`{1,2,3}`&quot;, respectively).
The latter is most often used to approximate &quot;keyword-style&quot; arguments with a
single dictionary, for example:

<B>    local func_with_opts = function(opts)</B>
<B>        local will_do_foo = opts.foo</B>
<B>        local filename = opts.filename</B>

<B>        ...</B>
<B>    end</B>

<B>    func_with_opts { foo = true, filename = "hello.world" }</B>
 
In this style, each &quot;parameter&quot; is passed via keyword. It is still valid
to call the function in the standard style:

<B>    func_with_opts({ foo = true, filename = "hello.world" })</B>
 
But often in the documentation, you will see the former rather than the
latter style due to its brevity.

==============================================================================

<A HREF="#Lua">Lua</A> Patterns                                                    *<A NAME="lua-patterns"></A><B>lua-patterns</B>*

For performance reasons, <A HREF="#Lua">Lua</A> does not support regular expressions natively.
Instead, the <A HREF="#Lua">Lua</A> `string` standard library allows manipulations using a
restricted set of &quot;patterns&quot;, see |<A HREF="luaref.html#luaref-patterns">luaref-patterns</A>|.

Examples (`string.match` extracts the first match):

<B>    print(string.match("foo123bar123", "%d+"))</B>
<B>    -- -&gt; 123</B>

<B>    print(string.match("foo123bar123", "[^%d]+"))</B>
<B>    -- -&gt; foo</B>

<B>    print(string.match("foo123bar123", "[abc]+"))</B>
<B>    -- -&gt; ba</B>

<B>    print(string.match("foo.bar", "%.bar"))</B>
<B>    -- -&gt; .bar</B>

For more complex matching, Vim regular expressions can be used from <A HREF="#Lua">Lua</A>
through |<A HREF="vim.html">vim.regex()</A>|.

------------------------------------------------------------------------------

LUA PLUGIN EXAMPLE                                       *<A NAME="lua-require-example"></A><B>lua-require-example</B>*

The following example <A HREF="usr_05.html#plugin">plugin</A> adds a command `:MakeCharBlob` which transforms
current buffer into a long `unsigned char` array. <A HREF="#Lua">Lua</A> contains transformation
function in a module `lua/charblob.lua` which is imported in
`autoload/charblob.vim` (`require(&quot;charblob&quot;)`). Example <A HREF="usr_05.html#plugin">plugin</A> is supposed
to be put into any directory from <A HREF="options.html#'runtimepath'">'runtimepath'</A>, e.g. `~/.config/nvim` (in
this <A HREF="change.html#case">case</A> `lua/charblob.lua` means `~/.config/nvim/lua/charblob.lua`).

autoload/charblob.vim:

<B>    function charblob#encode_buffer()</B>
<B>      call setline(1, luaeval(</B>
<B>      \    'require("charblob").encode(unpack(_A))',</B>
<B>      \    [getline(1, '$'), &amp;textwidth, '  ']))</B>
<B>    endfunction</B>
 
plugin/charblob.vim:

<B>    if exists('g:charblob_loaded')</B>
<B>      finish</B>
<B>    endif</B>
<B>    let g:charblob_loaded = 1</B>

<B>    command MakeCharBlob :call charblob#encode_buffer()</B>
 
lua/charblob.lua:

<B>    local function charblob_bytes_iter(lines)</B>
<B>      local init_s = {</B>
<B>        next_line_idx = 1,</B>
<B>        next_byte_idx = 1,</B>
<B>        lines = lines,</B>
<B>      }</B>
<B>      local function next(s, _)</B>
<B>        if lines[s.next_line_idx] == nil then</B>
<B>          return nil</B>
<B>        end</B>
<B>        if s.next_byte_idx &gt; #(lines[s.next_line_idx]) then</B>
<B>          s.next_line_idx = s.next_line_idx + 1</B>
<B>          s.next_byte_idx = 1</B>
<B>          return ('\n'):byte()</B>
<B>        end</B>
<B>        local ret = lines[s.next_line_idx]:byte(s.next_byte_idx)</B>
<B>        if ret == ('\n'):byte() then</B>
<B>          ret = 0  -- See :h NL-used-for-NUL.</B>
<B>        end</B>
<B>        s.next_byte_idx = s.next_byte_idx + 1</B>
<B>        return ret</B>
<B>      end</B>
<B>      return next, init_s, nil</B>
<B>    end</B>

<B>    local function charblob_encode(lines, textwidth, indent)</B>
<B>      local ret = {</B>
<B>        'const unsigned char blob[] = {',</B>
<B>        indent,</B>
<B>      }</B>
<B>      for byte in charblob_bytes_iter(lines) do</B>
<B>        --                .- space + number (width 3) + comma</B>
<B>        if #(ret[#ret]) + 5 &gt; textwidth then</B>
<B>          ret[#ret + 1] = indent</B>
<B>        else</B>
<B>          ret[#ret] = ret[#ret] .. ' '</B>
<B>        end</B>
<B>        ret[#ret] = ret[#ret] .. (('%3u,'):format(byte))</B>
<B>      end</B>
<B>      ret[#ret + 1] = '};'</B>
<B>      return ret</B>
<B>    end</B>

<B>    return {</B>
<B>      bytes_iter = charblob_bytes_iter,</B>
<B>      encode = charblob_encode,</B>
<B>    }</B>
 
==============================================================================

COMMANDS                                                        *<A NAME="lua-commands"></A><B>lua-commands</B>*

These commands execute a <A HREF="#Lua">Lua</A> chunk from either the command line (:lua, <A HREF="#:luado">:luado</A>)
or a file (:luafile) on the given line <A HREF="cmdline.html#[range]">[range]</A>. As always in <A HREF="#Lua">Lua</A>, each chunk
has its own scope (closure), so only global <A HREF="eval.html#variables">variables</A> are shared between
command calls. The |<A HREF="#lua-stdlib">lua-stdlib</A>| modules, user modules, and anything else on
|<A HREF="package.html">package.path</A>| are available.

The <A HREF="#Lua">Lua</A> print() function redirects its output to the Nvim message area, with
arguments separated by &quot; &quot; (space) instead of &quot;\t&quot; (tab).


                                                                        *<A NAME=":lua"></A><B>:lua</B>*
<A HREF="#:lua">:lua</A> {chunk}
    Executes <A HREF="#Lua">Lua</A> chunk {chunk}. If {chunk} starts with &quot;<A HREF="change.html#=">=</A>&quot; the rest of the
    chunk is evaluated <A HREF="motion.html#as">as</A> an <A HREF="eval.html#expression">expression</A> and printed. `:lua =expr` is
    equivalent to `:lua print(vim.inspect(expr))`

    Examples:
<B>        :lua vim.api.nvim_command('echo "Hello, Nvim!"')</B>
     To see the <A HREF="#Lua">Lua</A> version:
<B>        :lua print(_VERSION)</B>
     To see the LuaJIT version:
<B>        :lua =jit.version</B>
 

                                                                *<A NAME=":lua-heredoc"></A><B>:lua-heredoc</B>*
<A HREF="#:lua">:lua</A> <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> [endmarker]
{script}
{endmarker}
    Executes <A HREF="#Lua">Lua</A> <A HREF="usr_41.html#script">script</A> {script} from within Vimscript. {endmarker} must NOT
    be preceded by <A HREF="pattern.html#whitespace">whitespace</A>. You can omit [endmarker] after the &quot;<A HREF="change.html#&lt;&lt;">&lt;&lt;</A>&quot; and use
    a dot &quot;<A HREF="repeat.html#.">.</A>&quot; after {script} (similar to |<A HREF="insert.html#:append">:append</A>|, |<A HREF="insert.html#:insert">:insert</A>|).

    Example:
<B>        function! CurrentLineInfo()</B>
<B>        lua &lt;&lt; EOF</B>
<B>        local linenr = vim.api.nvim_win_get_cursor(0)[1]</B>
<B>        local curline = vim.api.nvim_buf_get_lines(</B>
<B>                0, linenr - 1, linenr, false)[1]</B>
<B>        print(string.format("Current line [%d] has %d bytes",</B>
<B>                linenr, #curline))</B>
<B>        EOF</B>
<B>        endfunction</B>
 
    Note that the `local` <A HREF="eval.html#variables">variables</A> will disappear when the block finishes.
    But not globals.


                                                                      *<A NAME=":luado"></A><B>:luado</B>*
:[range]luado {body}
    Executes <A HREF="#Lua">Lua</A> chunk &quot;function(line, linenr) {body} end&quot; for each buffer
    line in <A HREF="cmdline.html#[range]">[range]</A>, where `line` is the current line text (without &lt;EOL&gt;),
    and `linenr` is the current line number. If the function returns a <A HREF="eval.html#string">string</A>
    that becomes the text of the corresponding buffer line. Default <A HREF="cmdline.html#[range]">[range]</A> is
    the whole file: &quot;1,$&quot;.

    Examples:
<B>        :luado return string.format("%s\t%d", line:reverse(), #line)</B>

<B>        :lua require"lpeg"</B>
<B>        :lua -- balanced parenthesis grammar:</B>
<B>        :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }</B>
<B>        :luado if bp:match(line) then return "--&gt;\t" .. line end</B>
 

                                                                    *<A NAME=":luafile"></A><B>:luafile</B>*
<A HREF="#:luafile">:luafile</A> <A HREF="editing.html#{file}">{file}</A>
    Execute <A HREF="#Lua">Lua</A> <A HREF="usr_41.html#script">script</A> in <A HREF="editing.html#{file}">{file}</A>.
    The whole argument is used <A HREF="motion.html#as">as</A> the filename (like |<A HREF="editing.html#:edit">:edit</A>|), spaces <A HREF="diff.html#do">do</A> not
    need to be escaped. Alternatively you can |<A HREF="repeat.html#:source">:source</A>| <A HREF="#Lua">Lua</A> files.

    Examples:
<B>        :luafile script.lua</B>
<B>        :luafile %</B>
 

==============================================================================

<A HREF="#luaeval()">luaeval()</A>                                                 *<A NAME="lua-eval"></A><B>lua-eval</B>* *<A NAME="luaeval()"></A><B>luaeval()</B>*

The (dual) equivalent of &quot;vim.eval&quot; for passing <A HREF="#Lua">Lua</A> values to Nvim is
&quot;luaeval&quot;. &quot;luaeval&quot; takes an <A HREF="eval.html#expression">expression</A> <A HREF="eval.html#string">string</A> and an optional argument used
for _A inside <A HREF="eval.html#expression">expression</A> and returns the result of the <A HREF="eval.html#expression">expression</A>. It is
semantically equivalent in <A HREF="#Lua">Lua</A> to:

<B>    local chunkheader = "local _A = select(1, ...) return "</B>
<B>    function luaeval (expstr, arg)</B>
<B>        local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))</B>
<B>        return chunk(arg) -- return typval</B>
<B>    end</B>
 
<A HREF="#Lua">Lua</A> nils, numbers, strings, tables and booleans are converted to their
respective Vimscript types. If a <A HREF="#Lua">Lua</A> <A HREF="eval.html#string">string</A> contains a NUL byte, <A HREF="motion.html#it">it</A> will be
converted to a |<A HREF="eval.html#Blob">Blob</A>|. Conversion of other <A HREF="#Lua">Lua</A> types is an error.

The magic global &quot;_A&quot; contains the second argument to <A HREF="#luaeval()">luaeval()</A>.

Example:
<B>    :echo luaeval('_A[1] + _A[2]', [40, 2])</B>
<B>    42</B>
<B>    :echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')</B>
<B>    foo</B>
 
<A HREF="#Lua">Lua</A> tables are used <A HREF="motion.html#as">as</A> both dictionaries and lists, so <A HREF="motion.html#it">it</A> is impossible to
determine whether empty table is meant to be empty <A HREF="eval.html#list">list</A> or empty dictionary.
Additionally <A HREF="#Lua">Lua</A> does not have integer numbers. To distinguish between these
cases there is the following agreement:

0. Empty table is empty <A HREF="eval.html#list">list</A>.
1. Table with N incrementally growing integral numbers, starting from 1 and
   ending with N is considered to be a <A HREF="eval.html#list">list</A>.
2. Table with <A HREF="eval.html#string">string</A> keys, none of which contains NUL byte, is considered to
   be a dictionary.
3. Table with <A HREF="eval.html#string">string</A> keys, at least one of which contains NUL byte, is also
   considered to be a dictionary, but this time <A HREF="motion.html#it">it</A> is converted to
   a |<A HREF="builtin.html#msgpack-special-map">msgpack-special-map</A>|.

                                                             *<A NAME="lua-special-tbl"></A><B>lua-special-tbl</B>*
4. Table with `vim.type_idx` key may be a dictionary, a <A HREF="eval.html#list">list</A> or floating-point
   value:
   - `{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}` is converted to
     a floating-point 1.0. Note that by default integral <A HREF="#Lua">Lua</A> numbers are
     converted to |<A HREF="eval.html#Number">Number</A>|<A HREF="change.html#s">s</A>, non-integral are converted to |<A HREF="eval.html#Float">Float</A>|<A HREF="change.html#s">s</A>. This
     variant allows integral |<A HREF="eval.html#Float">Float</A>|<A HREF="change.html#s">s</A>.
   - `{[vim.type_idx]=vim.types.dictionary}` is converted to an empty
     dictionary, `{[vim.type_idx]=vim.types.dictionary, [42]=1, a=2}` is
     converted to a dictionary `{'a': 42}`: non-string keys are ignored.
     Without `vim.type_idx` key tables with keys not fitting in 1., 2. or 3.
     are <A HREF="message.html#errors">errors</A>.
   - `{[vim.type_idx]=vim.types.array}` is converted to an empty <A HREF="eval.html#list">list</A>. As well
     <A HREF="motion.html#as">as</A> `{[vim.type_idx]=vim.types.array, [42]=1}`: integral keys that <A HREF="diff.html#do">do</A> not
     form a 1-step sequence from 1 to N are ignored, <A HREF="motion.html#as">as</A> well <A HREF="motion.html#as">as</A> all
     non-integral keys.

Examples:

<B>    :echo luaeval('math.pi')</B>
<B>    :function Rand(x,y) " random uniform between x and y</B>
<B>    :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})</B>
<B>    :  endfunction</B>
<B>    :echo Rand(1,10)</B>
 
Note: Second argument to `luaeval` is converted (&quot;marshalled&quot;) from Vimscript
to <A HREF="#Lua">Lua</A>, so changes to <A HREF="#Lua">Lua</A> containers <A HREF="diff.html#do">do</A> not affect values in Vimscript. Return
value is also always converted. When converting, |<A HREF="builtin.html#msgpack-special-dict">msgpack-special-dict</A>|s are
treated specially.

==============================================================================

Vimscript <A HREF="eval.html#v:lua">v:lua</A> interface                                         *<A NAME="v:lua-call"></A><B>v:lua-call</B>*

From Vimscript the special `v:lua` prefix can be used to call <A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A>
which are global or accessible from global tables. The <A HREF="eval.html#expression">expression</A>
<B>    v:lua.func(arg1, arg2)</B>
is equivalent to the <A HREF="#Lua">Lua</A> chunk
<B>    return func(...)</B>
where the args are converted to <A HREF="#Lua">Lua</A> values. The <A HREF="eval.html#expression">expression</A>
<B>    v:lua.somemod.func(args)</B>
is equivalent to the <A HREF="#Lua">Lua</A> chunk
<B>    return somemod.func(...)</B>

In addition, <A HREF="eval.html#functions">functions</A> of <A HREF="repeat.html#packages">packages</A> can be accessed like
<B>    v:lua.require'mypack'.func(arg1, arg2)</B>
<B>    v:lua.require'mypack.submod'.func(arg1, arg2)</B>
Note: Only single <A HREF="change.html#quote">quote</A> form without parens is allowed. Using
`require&quot;mypack&quot;` or `require('mypack')` <A HREF="motion.html#as">as</A> prefixes <A HREF="diff.html#do">do</A> NOT work (the latter
is still valid <A HREF="motion.html#as">as</A> a function call of itself, in <A HREF="change.html#case">case</A> require returns a useful
value).

The `v:lua` prefix may be used to call <A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A> <A HREF="motion.html#as">as</A> |<A HREF="eval.html#method">method</A>|<A HREF="change.html#s">s</A>. For
example:
<B>    arg1-&gt;v:lua.somemod.func(arg2)</B>
 
You can use `v:lua` in &quot;func&quot; <A HREF="options.html#options">options</A> like <A HREF="options.html#'tagfunc'">'tagfunc'</A>, <A HREF="options.html#'omnifunc'">'omnifunc'</A>, etc.
For example consider the following <A HREF="#Lua">Lua</A> omnifunc handler:

<B>    function mymod.omnifunc(findstart, base)</B>
<B>      if findstart == 1 then</B>
<B>        return 0</B>
<B>      else</B>
<B>        return {'stuff', 'steam', 'strange things'}</B>
<B>      end</B>
<B>    end</B>
<B>    vim.api.nvim_buf_set_option(0, 'omnifunc', 'v:lua.mymod.omnifunc')</B>

Note: The module (&quot;mymod&quot; in the above example) must either be a <A HREF="#Lua">Lua</A> global,
or use the require <A HREF="syntax.html#syntax">syntax</A> <A HREF="motion.html#as">as</A> specified above to access <A HREF="motion.html#it">it</A> from a package.

Note: `v:lua` without a call is not allowed in a Vimscript <A HREF="eval.html#expression">expression</A>:
|<A HREF="eval.html#Funcref">Funcref</A>|<A HREF="change.html#s">s</A> cannot represent <A HREF="#Lua">Lua</A> <A HREF="eval.html#functions">functions</A>. The following are <A HREF="message.html#errors">errors</A>:

<B>    let g:Myvar = v:lua.myfunc        " Error</B>
<B>    call SomeFunc(v:lua.mycallback)   " Error</B>
<B>    let g:foo = v:lua                 " Error</B>
<B>    let g:foo = v:['lua']             " Error</B>
 
==============================================================================

<A HREF="#Lua">Lua</A> standard modules                                              *<A NAME="lua-stdlib"></A><B>lua-stdlib</B>*

The Nvim <A HREF="#Lua">Lua</A> &quot;standard library&quot; (stdlib) is the `vim` module, which exposes
various <A HREF="eval.html#functions">functions</A> and sub-modules. It is always loaded, thus `require(&quot;vim&quot;)`
is unnecessary.

You can peek at the module properties:

<B>    :lua print(vim.inspect(vim))</B>

Result is something like this:

<B>    {</B>
<B>      _os_proc_children = &lt;function 1&gt;,</B>
<B>      _os_proc_info = &lt;function 2&gt;,</B>
<B>      ...</B>
<B>      api = {</B>
<B>        nvim__id = &lt;function 5&gt;,</B>
<B>        nvim__id_array = &lt;function 6&gt;,</B>
<B>        ...</B>
<B>      },</B>
<B>      deepcopy = &lt;function 106&gt;,</B>
<B>      gsplit = &lt;function 107&gt;,</B>
<B>      ...</B>
<B>    }</B>

To find documentation on e.g. the &quot;deepcopy&quot; function:

<B>    :help vim.deepcopy()</B>

Note that underscore-prefixed <A HREF="eval.html#functions">functions</A> (e.g. &quot;_os_proc_children&quot;) are
internal/private and must not be used by plugins.

------------------------------------------------------------------------------

VIM.LOOP                                                   *<A NAME="lua-loop"></A><B>lua-loop</B>* *<A NAME="vim.loop"></A><B>vim.loop</B>*

`vim.loop` exposes all features of the Nvim event-loop. This is a low-level
<A HREF="api.html#API">API</A> that provides functionality for networking, filesystem, and process
management. Try this command to see available <A HREF="eval.html#functions">functions</A>:

<B>    :lua print(vim.inspect(vim.loop))</B>
 
Internally, `vim.loop` wraps the &quot;<A HREF="luvref.html#luv">luv</A>&quot; <A HREF="#Lua">Lua</A> bindings for the LibUV library;
see |<A HREF="luvref.html#luv-intro">luv-intro</A>| for a full reference manual.


                                                    *<A NAME="E5560"></A><B>E5560</B>* *<A NAME="lua-loop-callbacks"></A><B>lua-loop-callbacks</B>*
It is an error to directly invoke `vim.api` <A HREF="eval.html#functions">functions</A> (except |<A HREF="api.html#api-fast">api-fast</A>|) in
`vim.loop` callbacks. For example, this is an error:

<B>    local timer = vim.loop.new_timer()</B>
<B>    timer:start(1000, 0, function()</B>
<B>      vim.api.nvim_command('echomsg "test"')</B>
<B>    end)</B>
 
To avoid the error use |<A HREF="vim.html">vim.schedule_wrap()</A>| to defer the callback:

<B>    local timer = vim.loop.new_timer()</B>
<B>    timer:start(1000, 0, vim.schedule_wrap(function()</B>
<B>      vim.api.nvim_command('echomsg "test"')</B>
<B>    end))</B>
 
(For one-shot <A HREF="builtin.html#timers">timers</A>, see |<A HREF="vim.html">vim.defer_fn()</A>|, which automatically adds the
wrapping.)

Example: <A HREF="repeat.html#repeating">repeating</A> <A HREF="builtin.html#timer">timer</A>
    1. Save this code to a file.
    2. Execute <A HREF="motion.html#it">it</A> with &quot;<A HREF="#:luafile">:luafile</A> &#37;&quot;.

<B>    -- Create a timer handle (implementation detail: uv_timer_t).</B>
<B>    local timer = vim.loop.new_timer()</B>
<B>    local i = 0</B>
<B>    -- Waits 1000ms, then repeats every 750ms until timer:close().</B>
<B>    timer:start(1000, 750, function()</B>
<B>      print('timer invoked! i='..tostring(i))</B>
<B>      if i &gt; 4 then</B>
<B>        timer:close()  -- Always close handles to avoid leaks.</B>
<B>      end</B>
<B>      i = i + 1</B>
<B>    end)</B>
<B>    print('sleeping');</B>
 

Example: File-change detection                                    *<A NAME="watch-file"></A><B>watch-file</B>*
    1. Save this code to a file.
    2. Execute <A HREF="motion.html#it">it</A> with &quot;<A HREF="#:luafile">:luafile</A> &#37;&quot;.
    3. Use &quot;:Watch &#37;&quot; to watch any file.
    4. Try editing the file from another text editor.
    5. Observe that the file reloads in Nvim (because on_change() calls
       |<A HREF="editing.html#:checktime">:checktime</A>|).

<B>    local w = vim.loop.new_fs_event()</B>
<B>    local function on_change(err, fname, status)</B>
<B>      -- Do work...</B>
<B>      vim.api.nvim_command('checktime')</B>
<B>      -- Debounce: stop/start.</B>
<B>      w:stop()</B>
<B>      watch_file(fname)</B>
<B>    end</B>
<B>    function watch_file(fname)</B>
<B>      local fullpath = vim.api.nvim_call_function(</B>
<B>        'fnamemodify', {fname, ':p'})</B>
<B>      w:start(fullpath, {}, vim.schedule_wrap(function(...)</B>
<B>        on_change(...) end))</B>
<B>    end</B>
<B>    vim.api.nvim_command(</B>
<B>      "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('&lt;args&gt;'))")</B>
 

Example: TCP echo-server                                          *<A NAME="tcp-server"></A><B>tcp-server</B>*
    1. Save this code to a file.
    2. Execute <A HREF="motion.html#it">it</A> with &quot;<A HREF="#:luafile">:luafile</A> &#37;&quot;.
    3. Note the port number.
    4. Connect from any TCP client (e.g. &quot;nc 0.0.0.0 36795&quot;):

<B>    local function create_server(host, port, on_connect)</B>
<B>      local server = vim.loop.new_tcp()</B>
<B>      server:bind(host, port)</B>
<B>      server:listen(128, function(err)</B>
<B>        assert(not err, err)  -- Check for errors.</B>
<B>        local sock = vim.loop.new_tcp()</B>
<B>        server:accept(sock)  -- Accept client connection.</B>
<B>        on_connect(sock)  -- Start reading messages.</B>
<B>      end)</B>
<B>      return server</B>
<B>    end</B>
<B>    local server = create_server('0.0.0.0', 0, function(sock)</B>
<B>      sock:read_start(function(err, chunk)</B>
<B>        assert(not err, err)  -- Check for errors.</B>
<B>        if chunk then</B>
<B>          sock:write(chunk)  -- Echo received messages to the channel.</B>
<B>        else  -- EOF (stream closed).</B>
<B>          sock:close()  -- Always close handles to avoid leaks.</B>
<B>        end</B>
<B>      end)</B>
<B>    end)</B>
<B>    print('TCP echo-server listening on port: '..server:getsockname().port)</B>
 

Multithreading                                            *<A NAME="lua-loop-threading"></A><B>lua-loop-threading</B>*

Plugins can perform work in separate (os-level) threads using the threading
APIs in <A HREF="luvref.html#luv">luv</A>, for instance `vim.loop.new_thread`. Note that every thread
gets its own separate <A HREF="#lua">lua</A> interpreter state, with no access to <A HREF="#lua">lua</A> globals
in the main thread. Neither can the state of the editor (buffers, <A HREF="windows.html#windows">windows</A>,
etc) be directly accessed from threads.

A subset of the `vim.*` <A HREF="api.html#API">API</A> is available in threads. This includes:

- `vim.loop` with a separate event loop per thread.
- `vim.mpack` and `vim.json` (useful for serializing <A HREF="message.html#messages">messages</A> between threads)
- `require` in threads can use <A HREF="#lua">lua</A> <A HREF="repeat.html#packages">packages</A> from the global |<A HREF="package.html">package.path</A>|
- `print()` and `vim.inspect`
- `vim.diff`
- most utility <A HREF="eval.html#functions">functions</A> in `vim.*` for working with pure <A HREF="#lua">lua</A> values
  like `vim.split`, `vim.tbl_*`, `vim.list_*`, and so on.
- `vim.is_thread()` returns true from a non-main thread.

------------------------------------------------------------------------------

VIM.HIGHLIGHT                                                  *<A NAME="lua-highlight"></A><B>lua-highlight</B>*

Nvim includes a function for highlighting a selection on <A HREF="change.html#yank">yank</A> (see for example
https://github.com/machakann/vim-highlightedyank). To enable <A HREF="motion.html#it">it</A>, add

<B>    au TextYankPost * silent! lua vim.highlight.on_yank()</B>
 
to your `init.vim`. You can customize the highlight group and the duration of
the highlight via

<B>    au TextYankPost * silent! lua vim.highlight.on_yank {higroup="IncSearch", timeout=150}</B>
 
If you want to exclude visual selections from highlighting on <A HREF="change.html#yank">yank</A>, use

<B>    au TextYankPost * silent! lua vim.highlight.on_yank {on_visual=false}</B>
 

vim.highlight.on_yank({opts})                        *<A NAME="vim.highlight.on_yank()"></A><B>vim.highlight.on_yank()</B>*
    Highlights the yanked text. The fields of the optional <A HREF="eval.html#dict">dict</A> {opts}
    <A HREF="intro.html#control">control</A> the highlight:
      - {higroup} highlight group for yanked region (default |<A HREF="syntax.html#hl-IncSearch">hl-IncSearch</A>|)
      - {timeout} time in ms before highlight is cleared (default `150`)
      - {on_macro} highlight when executing <A HREF="map.html#macro">macro</A> (default `false`)
      - {on_visual} highlight when yanking visual selection (default `true`)
      - <A HREF="autocmd.html#{event}">{event}</A> event structure (default |<A HREF="eval.html#v:event">v:event</A>|)

vim.highlight.range({bufnr}, {ns}, {hlgroup}, {start}, {finish}, {opts})

                                                       *<A NAME="vim.highlight.range()"></A><B>vim.highlight.range()</B>*

    Apply highlight group to range of text.

<B><FONT COLOR="PURPLE">            Parameters: </FONT></B>
                {bufnr}   buffer number
                {ns}      <A HREF="api.html#namespace">namespace</A> for highlights
                {hlgroup} highlight group name
                {start}   starting position (tuple {line,col})
                {finish}  finish position (tuple {line,col})
                {opts}    optional parameters:
                          • `regtype`: type of range (characterwise, <A HREF="motion.html#linewise">linewise</A>,
                            or blockwise, see |<A HREF="builtin.html#setreg()">setreg()</A>|), default `'v'`
                          • `inclusive`: range includes end position,
                            default `false`
                          • `priority`: priority of highlight, default
                            `vim.highlight.user` (see below)


<A HREF="#vim.highlight.priorities">vim.highlight.priorities</A>                            *<A NAME="vim.highlight.priorities"></A><B>vim.highlight.priorities</B>*

    Table with default priorities used for highlighting:
        • `syntax`: `50`, used for standard <A HREF="syntax.html#syntax">syntax</A> highlighting
        • `treesitter`: `100`, used for tree-sitter-based highlighting
        • `diagnostics`: `150`, used for code analysis such <A HREF="motion.html#as">as</A> diagnostics
        • `user`: `200`, used for user-triggered highlights such <A HREF="motion.html#as">as</A> <A HREF="lsp.html#LSP">LSP</A> document
          symbols or `on_yank` autocommands

------------------------------------------------------------------------------

VIM.REGEX                                                          *<A NAME="lua-regex"></A><B>lua-regex</B>*

Vim regexes can be used directly from <A HREF="#lua">lua</A>. Currently they only allow
matching within a single line.


vim.regex({re})                                                  *<A NAME="vim.regex()"></A><B>vim.regex()</B>*
    Parse the Vim regex {re} and return a regex object. Regexes are &quot;magic&quot;
    and case-sensitive by default, regardless of <A HREF="options.html#'magic'">'magic'</A> and <A HREF="options.html#'ignorecase'">'ignorecase'</A>.
    They can be controlled with flags, see |<A HREF="pattern.html#/magic">/magic</A>| and |<A HREF="pattern.html#/ignorecase">/ignorecase</A>|.

Methods on the regex object:


regex:match_str({str})                                     *<A NAME="regex:match_str()"></A><B>regex:match_str()</B>*
    Match the <A HREF="eval.html#string">string</A> against the regex. If the <A HREF="eval.html#string">string</A> should match the regex
    precisely, surround the regex with `^` and `$`. If the was a match, the
    byte indices for the beginning and end of the match is returned. When
    there is no match, `nil` is returned. As any integer is truth-y,
    `regex:match()` can be directly used <A HREF="motion.html#as">as</A> a condition in an if-statement.


regex:match_line({bufnr}, {line_idx} [, {start}, {end}])  *<A NAME="regex:match_line()"></A><B>regex:match_line()</B>*
    Match line {line_idx} (zero-based) in buffer {bufnr}. If {start} and {end}
    are supplied, match only this byte index range. Otherwise see
    |<A HREF="#regex:match_str()">regex:match_str()</A>|. If {start} is used, then the returned byte indices
    will be relative {start}.

------------------------------------------------------------------------------

VIM.DIFF                                                            *<A NAME="lua-diff"></A><B>lua-diff</B>*


vim.diff({a}, {b}, {opts})                                        *<A NAME="vim.diff()"></A><B>vim.diff()</B>*
    Run <A HREF="diff.html#diff">diff</A> on strings {a} and {b}. Any indices returned by this function,
    either directly or via callback arguments, are 1-based.

    Examples:

<B>        vim.diff('a\n', 'b\nc\n')</B>
<B>        --&gt;</B>
<B>        @@ -1 +1,2 @@</B>
<B>        -a</B>
<B>        +b</B>
<B>        +c</B>

<B>        vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})</B>
<B>        --&gt;</B>
<B>        {</B>
<B>            {1, 1, 1, 2}</B>
<B>        }</B>
 
<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {a}      First <A HREF="eval.html#string">string</A> to compare
        {b}      Second <A HREF="eval.html#string">string</A> to compare
        {opts}   Optional parameters:
                 • `on_hunk` (callback):
                   Invoked for each hunk in the <A HREF="diff.html#diff">diff</A>. Return a negative number
                   to cancel the callback for any remaining hunks.
                   Args:
                   • `start_a` (integer): Start line of hunk in {a}.
                   • `count_a` (integer): Hunk size in {a}.
                   • `start_b` (integer): Start line of hunk in {b}.
                   • `count_b` (integer): Hunk size in {b}.
                 • `result_type` (string): Form of the returned <A HREF="diff.html#diff">diff</A>:
                   • &quot;unified&quot;: (default) <A HREF="eval.html#String">String</A> in unified format.
                   • &quot;indices&quot;: Array of hunk locations.
                   Note: This option is ignored if `on_hunk` is used.
                 • `algorithm` (string):
                   Diff algorithm to use. Values:
                   • &quot;myers&quot;      the default algorithm
                   • &quot;minimal&quot;    spend extra time to generate the
                                  smallest possible <A HREF="diff.html#diff">diff</A>
                   • &quot;patience&quot;   patience <A HREF="diff.html#diff">diff</A> algorithm
                   • &quot;histogram&quot;  histogram <A HREF="diff.html#diff">diff</A> algorithm
                 • `ctxlen` (integer): <A HREF="repeat.html#Context">Context</A> length
                 • `interhunkctxlen` (integer):
                   Inter hunk <A HREF="repeat.html#context">context</A> length
                 • `ignore_whitespace` (boolean):
                   Ignore <A HREF="pattern.html#whitespace">whitespace</A>
                 • `ignore_whitespace_change` (boolean):
                   Ignore <A HREF="pattern.html#whitespace">whitespace</A> change
                 • `ignore_whitespace_change_at_eol` (boolean)
                   Ignore <A HREF="pattern.html#whitespace">whitespace</A> change at end-of-line.
                 • `ignore_cr_at_eol` (boolean)
                   Ignore carriage return at end-of-line
                 • `ignore_blank_lines` (boolean)
                   Ignore blank lines
                 • `indent_heuristic` (boolean):
                   Use the indent heuristic for the internal
                   <A HREF="diff.html#diff">diff</A> library.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        See {opts.result_type}. nil if {opts.on_hunk} is given.

------------------------------------------------------------------------------

VIM.MPACK                                                          *<A NAME="lua-mpack"></A><B>lua-mpack</B>*


The *<A NAME="vim.mpack"></A><B>vim.mpack</B>* module provides encoding and decoding of <A HREF="#Lua">Lua</A> <A HREF="vimindex.html#objects">objects</A> to and
from msgpack-encoded strings. Supports |<A HREF="vim.html">vim.NIL</A>| and |<A HREF="vim.html">vim.empty_dict()</A>|.


vim.mpack.encode({obj})                                     *<A NAME="vim.mpack.encode"></A><B>vim.mpack.encode</B>*
    Encodes (or &quot;packs&quot;) <A HREF="#Lua">Lua</A> object {obj} <A HREF="motion.html#as">as</A> msgpack in a <A HREF="#Lua">Lua</A> <A HREF="eval.html#string">string</A>.


vim.mpack.decode({str})                                     *<A NAME="vim.mpack.decode"></A><B>vim.mpack.decode</B>*
    Decodes (or &quot;unpacks&quot;) the msgpack-encoded {str} to a <A HREF="#Lua">Lua</A> object.

------------------------------------------------------------------------------

VIM.SPELL                                                          *<A NAME="lua-spell"></A><B>lua-spell</B>*


vim.spell.check({str})                                     *<A NAME="vim.spell.check()"></A><B>vim.spell.check()</B>*
    Check {str} for spelling <A HREF="message.html#errors">errors</A>. Similar to the Vimscript function
    |<A HREF="builtin.html#spellbadword()">spellbadword()</A>|.

    Note: The behaviour of this function is dependent on: <A HREF="options.html#'spelllang'">'spelllang'</A>,
    <A HREF="options.html#'spellfile'">'spellfile'</A>, <A HREF="options.html#'spellcapcheck'">'spellcapcheck'</A> and <A HREF="options.html#'spelloptions'">'spelloptions'</A> which can all be local to
    the buffer. Consider calling this with |<A HREF="api.html#nvim_buf_call()">nvim_buf_call()</A>|.

    Example:

<B>        vim.spell.check("the quik brown fox")</B>
<B>        --&gt;</B>
<B>        {</B>
<B>            {'quik', 'bad', 4}</B>
<B>        }</B>
 
<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}    <A HREF="eval.html#String">String</A> to <A HREF="spell.html#spell">spell</A> check.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
      <A HREF="eval.html#List">List</A> of tuples with three items:
        - The badly spelled <A HREF="motion.html#word">word</A>.
        - The type of the spelling error:
            &quot;bad&quot;   spelling mistake
            &quot;rare&quot;  rare <A HREF="motion.html#word">word</A>
            &quot;local&quot; <A HREF="motion.html#word">word</A> only valid in another region
            &quot;caps&quot;  <A HREF="motion.html#word">word</A> should start with Capital
        - The position in {str} where the <A HREF="motion.html#word">word</A> begins.

------------------------------------------------------------------------------

VIM                                                              *<A NAME="lua-builtin"></A><B>lua-builtin</B>*


vim.api.{func}({...})                                                *<A NAME="vim.api"></A><B>vim.api</B>*
    Invokes Nvim |<A HREF="api.html#API">API</A>| function {func} with arguments {...}.
    Example: call the &quot;<A HREF="api.html#nvim_get_current_line()">nvim_get_current_line()</A>&quot; <A HREF="api.html#API">API</A> function:
<B>        print(tostring(vim.api.nvim_get_current_line()))</B>


vim.version()                                                    *<A NAME="vim.version"></A><B>vim.version</B>*
    Gets the version of the current Nvim build.


<A HREF="#vim.in_fast_event()">vim.in_fast_event()</A>                                      *<A NAME="vim.in_fast_event()"></A><B>vim.in_fast_event()</B>*
    Returns true if the code is executing <A HREF="motion.html#as">as</A> part of a &quot;fast&quot; event handler,
    where most of the <A HREF="api.html#API">API</A> is disabled. These are low-level <A HREF="autocmd.html#events">events</A> (e.g.
    |<A HREF="#lua-loop-callbacks">lua-loop-callbacks</A>|) which can be invoked whenever Nvim polls for input.
    When this is `false` most <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A> are callable (but may be subject
    to other restrictions such <A HREF="motion.html#as">as</A> |<A HREF="eval.html#textlock">textlock</A>|).


<A HREF="#vim.NIL">vim.NIL</A>                                                              *<A NAME="vim.NIL"></A><B>vim.NIL</B>*
    Special value representing NIL in |<A HREF="api.html#RPC">RPC</A>| and |<A HREF="eval.html#v:null">v:null</A>| in Vimscript
    conversion, and similar cases. <A HREF="#Lua">Lua</A> `nil` cannot be used <A HREF="motion.html#as">as</A> part of a <A HREF="#Lua">Lua</A>
    table representing a <A HREF="eval.html#Dictionary">Dictionary</A> or Array, because <A HREF="motion.html#it">it</A> is treated <A HREF="motion.html#as">as</A>
    missing: `{&quot;foo&quot;, nil}` is the same <A HREF="motion.html#as">as</A> `{&quot;foo&quot;}`.


<A HREF="#vim.empty_dict()">vim.empty_dict()</A>                                            *<A NAME="vim.empty_dict()"></A><B>vim.empty_dict()</B>*
    Creates a special empty table (marked with a metatable), which Nvim to an
    empty dictionary when translating <A HREF="#Lua">Lua</A> values to Vimscript or <A HREF="api.html#API">API</A> types.
    Nvim by default converts an empty table `{}` without this metatable to an
    list/array.

    Note: If numeric keys are present in the table, Nvim ignores the metatable
    marker and converts the <A HREF="eval.html#dict">dict</A> to a list/array anyway.


vim.rpcnotify({channel}, {method} [, {args}...])             *<A NAME="vim.rpcnotify()"></A><B>vim.rpcnotify()</B>*
    Sends <A HREF="autocmd.html#{event}">{event}</A> to {channel} via |<A HREF="api.html#RPC">RPC</A>| and returns immediately. If {channel}
    is 0, the event is broadcast to all channels.

    This function also works in a fast callback |<A HREF="#lua-loop-callbacks">lua-loop-callbacks</A>|.


vim.rpcrequest({channel}, {method} [, {args}...])           *<A NAME="vim.rpcrequest()"></A><B>vim.rpcrequest()</B>*
    Sends a request to {channel} to invoke {method} via |<A HREF="api.html#RPC">RPC</A>| and blocks until
    a response is received.

    Note: NIL values <A HREF="motion.html#as">as</A> part of the return value is represented <A HREF="motion.html#as">as</A> |<A HREF="vim.html">vim.NIL</A>|
    special value


vim.stricmp({a}, {b})                                          *<A NAME="vim.stricmp()"></A><B>vim.stricmp()</B>*
    Compares strings case-insensitively. Returns 0, 1 or -1 if strings are
    equal, {a} is greater than {b} or {a} is lesser than {b}, respectively.


vim.str_utfindex({str} [, {index}])                       *<A NAME="vim.str_utfindex()"></A><B>vim.str_utfindex()</B>*
    Convert byte index to UTF-32 and UTF-16 indices. If {index} is not
    supplied, the length of the <A HREF="eval.html#string">string</A> is used. All indices are zero-based.
    Returns two values: the UTF-32 and UTF-16 indices respectively.

    Embedded NUL bytes are treated <A HREF="motion.html#as">as</A> terminating the <A HREF="eval.html#string">string</A>. Invalid <A HREF="mbyte.html#UTF-8">UTF-8</A>
    bytes, and embedded surrogates are counted <A HREF="motion.html#as">as</A> one code point each. An
    {index} in the middle of a <A HREF="mbyte.html#UTF-8">UTF-8</A> sequence is rounded upwards to the end of
    that sequence.


vim.str_byteindex({str}, {index} [, {use_utf16}])        *<A NAME="vim.str_byteindex()"></A><B>vim.str_byteindex()</B>*
    Convert UTF-32 or UTF-16 {index} to byte index. If {use_utf16} is not
    supplied, <A HREF="motion.html#it">it</A> defaults to false (use UTF-32). Returns the byte index.

    Invalid <A HREF="mbyte.html#UTF-8">UTF-8</A> and NUL is treated like by |<A HREF="vim.html">vim.str_byteindex()</A>|.
    An {index} in the middle of a UTF-16 sequence is rounded upwards to
    the end of that sequence.


vim.iconv({str}, {from}, {to}[, {opts}])                        *<A NAME="vim.iconv()"></A><B>vim.iconv()</B>*
        The result is a <A HREF="eval.html#String">String</A>, which is the text {str} converted from
        encoding {from} to encoding {to}. When the conversion fails `nil` is
        returned.  When some characters could not be converted they
        are replaced with &quot;<A HREF="pattern.html#?">?</A>&quot;.
        The encoding names are whatever the <A HREF="builtin.html#iconv()">iconv()</A> library function
        can accept, see &quot;<A HREF="filetype.html#:Man">:Man</A> 3 iconv&quot;.

<B><FONT COLOR="PURPLE">        Parameters: </FONT></B>
            {str}   (string) Text to convert
            {from}  (string) Encoding of {str}
            {to}    (string) Target encoding

<B><FONT COLOR="PURPLE">        Returns: </FONT></B>
            Converted <A HREF="eval.html#string">string</A> if conversion succeeds, `nil` otherwise.


vim.schedule({callback})                                      *<A NAME="vim.schedule()"></A><B>vim.schedule()</B>*
    Schedules {callback} to be invoked soon by the main event-loop. Useful
    to avoid |<A HREF="eval.html#textlock">textlock</A>| or other temporary restrictions.



vim.defer_fn({fn}, {timeout})                                   *<A NAME="vim.defer_fn"></A><B>vim.defer_fn</B>*
    Defers calling {fn} until {timeout} ms passes. Use to <A HREF="diff.html#do">do</A> a one-shot <A HREF="builtin.html#timer">timer</A>
    that calls {fn}.

    Note: The {fn} is |vim.schedule_wrap()|ped automatically, so <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A> are
    safe to call.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {fn}        Callback to call once {timeout} expires
        {timeout}   Time in ms to wait before calling {fn}

<B><FONT COLOR="PURPLE">    Returns: </FONT></B>
        |<A HREF="vim.html">vim.loop</A>|.new_timer() object


vim.wait({time} [, {callback}, {interval}, {fast_only}])          *<A NAME="vim.wait()"></A><B>vim.wait()</B>*
    Wait for {time} in milliseconds until {callback} returns `true`.

    Executes {callback} immediately and at approximately {interval}
    milliseconds (default 200). Nvim still processes other <A HREF="autocmd.html#events">events</A> during
    this time.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {time}      <A HREF="eval.html#Number">Number</A> of milliseconds to wait
        {callback}  Optional callback. Waits until {callback} returns true
        {interval}  (Approximate) number of milliseconds to wait between polls
        {fast_only} If true, only |<A HREF="api.html#api-fast">api-fast</A>| <A HREF="autocmd.html#events">events</A> will be processed.
                        If called from while in an |<A HREF="api.html#api-fast">api-fast</A>| event, will
                        automatically be set to `true`.

<B><FONT COLOR="PURPLE">    Returns: </FONT></B>
        If {callback} returns `true` during the {time}:
            `true, nil`

        If {callback} never returns `true` during the {time}:
            `false, -1`

        If {callback} is interrupted during the {time}:
            `false, -2`

        If {callback} <A HREF="message.html#errors">errors</A>, the error is raised.

        Examples:

<B>    ---</B>
<B>    -- Wait for 100 ms, allowing other events to process</B>
<B>    vim.wait(100, function() end)</B>

<B>    ---</B>
<B>    -- Wait for 100 ms or until global variable set.</B>
<B>    vim.wait(100, function() return vim.g.waiting_for_var end)</B>

<B>    ---</B>
<B>    -- Wait for 1 second or until global variable set, checking every ~500 ms</B>
<B>    vim.wait(1000, function() return vim.g.waiting_for_var end, 500)</B>

<B>    ---</B>
<B>    -- Schedule a function to set a value in 100ms</B>
<B>    vim.defer_fn(function() vim.g.timer_result = true end, 100)</B>

<B>    -- Would wait ten seconds if results blocked. Actually only waits  100 ms</B>
<B>    if vim.wait(10000, function() return vim.g.timer_result end) then</B>
<B>      print('Only waiting a little bit of time!')</B>
<B>    end</B>
 


vim.ui_attach({ns}, {options}, {callback})                *<A NAME="vim.ui_attach()"></A><B>vim.ui_attach()</B>*
    Attach to ui <A HREF="autocmd.html#events">events</A>, similar to |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>| but receive <A HREF="autocmd.html#events">events</A>
    <A HREF="motion.html#as">as</A> <A HREF="#lua">lua</A> callback. Can be used to implement screen elements like
    popupmenu or message handling in <A HREF="#lua">lua</A>.

    {options} should be a dictionary-like table, where `ext_...` <A HREF="options.html#options">options</A> should
    be set to true to receive <A HREF="autocmd.html#events">events</A> for the respective external element.

    {callback} receives event name plus additional parameters. See |<A HREF="ui.html#ui-popupmenu">ui-popupmenu</A>|
    and the sections below for event format for respective <A HREF="autocmd.html#events">events</A>.

    WARNING: This <A HREF="api.html#api">api</A> is considered experimental.  Usability will vary for
    different screen elements. In particular `ext_messages` behavior is subject
    to further changes and usability improvements.  This is expected to be
    used to handle <A HREF="message.html#messages">messages</A> when setting <A HREF="options.html#'cmdheight'">'cmdheight'</A> to zero (which is
    likewise experimental).

    Example (stub for a |<A HREF="ui.html#ui-popupmenu">ui-popupmenu</A>| implementation):

<B>      ns = vim.api.nvim_create_namespace('my_fancy_pum')</B>

<B>      vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)</B>
<B>        if event == "popupmenu_show" then</B>
<B>          local items, selected, row, col, grid = ...</B>
<B>          print("display pum ", #items)</B>
<B>        elseif event == "popupmenu_select" then</B>
<B>          local selected = ...</B>
<B>          print("selected", selected)</B>
<B>        elseif event == "popupmenu_hide" then</B>
<B>          print("FIN")</B>
<B>        end</B>
<B>      end)</B>


vim.ui_detach({ns})                                           *<A NAME="vim.ui_detach()"></A><B>vim.ui_detach()</B>*
    Detach a callback previously attached with |<A HREF="vim.html">vim.ui_attach()</A>| for the
    given <A HREF="api.html#namespace">namespace</A> {ns}.


<A HREF="#vim.type_idx">vim.type_idx</A>                                                    *<A NAME="vim.type_idx"></A><B>vim.type_idx</B>*
    Type index for use in |<A HREF="#lua-special-tbl">lua-special-tbl</A>|. Specifying one of the values from
    |<A HREF="vim.html">vim.types</A>| allows typing the empty table (it is unclear whether empty <A HREF="#Lua">Lua</A>
    table represents empty <A HREF="eval.html#list">list</A> or empty array) and forcing integral numbers
    to be |<A HREF="eval.html#Float">Float</A>|. See |<A HREF="#lua-special-tbl">lua-special-tbl</A>| for more details.


<A HREF="#vim.val_idx">vim.val_idx</A>                                                      *<A NAME="vim.val_idx"></A><B>vim.val_idx</B>*
    Value index for tables representing |<A HREF="eval.html#Float">Float</A>|<A HREF="change.html#s">s</A>. A table representing
    floating-point value 1.0 looks like this:
<B>        {</B>
<B>          [vim.type_idx] = vim.types.float,</B>
<B>          [vim.val_idx] = 1.0,</B>
<B>        }</B>
     See also |<A HREF="vim.html">vim.type_idx</A>| and |<A HREF="#lua-special-tbl">lua-special-tbl</A>|.


<A HREF="#vim.types">vim.types</A>                                                          *<A NAME="vim.types"></A><B>vim.types</B>*
    Table with possible values for |<A HREF="vim.html">vim.type_idx</A>|. Contains two sets of
    key-value pairs: first maps possible values for |<A HREF="vim.html">vim.type_idx</A>| to
    human-readable strings, second maps human-readable type names to values
    for |<A HREF="vim.html">vim.type_idx</A>|. Currently contains pairs for `float`, `array` and
        `dictionary` types.

    Note: One must expect that values corresponding to `vim.types.float`,
    `vim.types.array` and `vim.types.dictionary` fall under only two following
    assumptions:
    1. Value may serve both <A HREF="motion.html#as">as</A> a key and <A HREF="motion.html#as">as</A> a value in a table. Given the
       properties of <A HREF="#Lua">Lua</A> tables this basically means “value is not `nil`”.
    2. For each value in `vim.types` table `vim.types[vim.types[value]]` is the
       same <A HREF="motion.html#as">as</A> `value`.
    No other restrictions are put on types, and <A HREF="motion.html#it">it</A> is not guaranteed that
    values corresponding to `vim.types.float`, `vim.types.array` and
    `vim.types.dictionary` will not change or that `vim.types` table will only
    contain values for these three types.


                                                   *<A NAME="log_levels"></A><B>log_levels</B>* *<A NAME="vim.log.levels"></A><B>vim.log.levels</B>*
Log levels are one of the values defined in `vim.log.levels`:

    vim.log.levels.DEBUG
    vim.log.levels.ERROR
    vim.log.levels.INFO
    vim.log.levels.TRACE
    vim.log.levels.WARN
    vim.log.levels.OFF

------------------------------------------------------------------------------

LUA-VIMSCRIPT BRIDGE                                           *<A NAME="lua-vimscript"></A><B>lua-vimscript</B>*

Nvim <A HREF="#Lua">Lua</A> provides an interface to Vimscript <A HREF="eval.html#variables">variables</A> and <A HREF="eval.html#functions">functions</A>, and
editor commands and <A HREF="options.html#options">options</A>.
See also https://github.com/nanotee/nvim-lua-guide.


vim.call({func}, {...})                                           *<A NAME="vim.call()"></A><B>vim.call()</B>*
    Invokes |<A HREF="eval.html#vim-function">vim-function</A>| or |<A HREF="eval.html#user-function">user-function</A>| {func} with arguments {...}.
    See also |<A HREF="#vim.fn">vim.fn</A>|.
    Equivalent to:
<B>        vim.fn[func]({...})</B>

vim.cmd({command})
    See |<A HREF="vim.html">vim.cmd()</A>|.


vim.fn.{func}({...})                                                  *<A NAME="vim.fn"></A><B>vim.fn</B>*
    Invokes |<A HREF="eval.html#vim-function">vim-function</A>| or |<A HREF="eval.html#user-function">user-function</A>| {func} with arguments {...}.
    To call <A HREF="userfunc.html#autoload">autoload</A> <A HREF="eval.html#functions">functions</A>, use the <A HREF="syntax.html#syntax">syntax</A>:
<B>        vim.fn['some#function']({...})</B>
 
    Unlike <A HREF="#vim.api">vim.api</A>.|<A HREF="api.html#nvim_call_function()">nvim_call_function()</A>| this converts directly between Vim
    <A HREF="vimindex.html#objects">objects</A> and <A HREF="#Lua">Lua</A> <A HREF="vimindex.html#objects">objects</A>. If the Vim function returns a float, <A HREF="motion.html#it">it</A> will be
    represented directly <A HREF="motion.html#as">as</A> a <A HREF="#Lua">Lua</A> number. Empty lists and dictionaries both
    are represented by an empty table.

    Note: |<A HREF="eval.html#v:null">v:null</A>| values <A HREF="motion.html#as">as</A> part of the return value is represented <A HREF="motion.html#as">as</A>
    |<A HREF="vim.html">vim.NIL</A>| special value

    Note: <A HREF="#vim.fn">vim.fn</A> keys are generated lazily, thus `pairs(vim.fn)` only
    enumerates <A HREF="eval.html#functions">functions</A> that were called at least once.

    Note: The majority of <A HREF="eval.html#functions">functions</A> cannot run in |<A HREF="api.html#api-fast">api-fast</A>| callbacks with some
    undocumented exceptions which are allowed.


                                                           *<A NAME="lua-vim-variables"></A><B>lua-vim-variables</B>*
The Vim editor global dictionaries |<A HREF="eval.html#g:">g:</A>| |<A HREF="eval.html#w:">w:</A>| |<A HREF="eval.html#b:">b:</A>| |<A HREF="eval.html#t:">t:</A>| |<A HREF="eval.html#v:">v:</A>| can be accessed
from <A HREF="#Lua">Lua</A> conveniently and idiomatically by referencing the `vim.*` <A HREF="#Lua">Lua</A> tables
described below. In this way you can easily read and modify global Vimscript
<A HREF="eval.html#variables">variables</A> from <A HREF="#Lua">Lua</A>.

Example:

<B>    vim.g.foo = 5     -- Set the g:foo Vimscript variable.</B>
<B>    print(vim.g.foo)  -- Get and print the g:foo Vimscript variable.</B>
<B>    vim.g.foo = nil   -- Delete (:unlet) the Vimscript variable.</B>
<B>    vim.b[2].foo = 6  -- Set b:foo for buffer 2</B>
 

Note that setting dictionary fields directly will not write them back into
Nvim. This is because the index into the <A HREF="api.html#namespace">namespace</A> simply returns a copy.
Instead the whole dictionary must be written <A HREF="motion.html#as">as</A> one. This can be achieved by
creating a short-lived temporary.

Example:

<B>    vim.g.my_dict.field1 = 'value'  -- Does not work</B>

<B>    local my_dict = vim.g.my_dict   --</B>
<B>    my_dict.field1 = 'value'        -- Instead do</B>
<B>    vim.g.my_dict = my_dict         --</B>


<A HREF="#vim.g">vim.g</A>                                                                  *<A NAME="vim.g"></A><B>vim.g</B>*
    Global (|<A HREF="eval.html#g:">g:</A>|) editor <A HREF="eval.html#variables">variables</A>.
    Key with no value returns `nil`.


<A HREF="#vim.b">vim.b</A>                                                                  *<A NAME="vim.b"></A><B>vim.b</B>*
    Buffer-scoped (|<A HREF="eval.html#b:">b:</A>|) <A HREF="eval.html#variables">variables</A> for the current buffer.
    Invalid or unset key returns `nil`. Can be indexed with
    an integer to access <A HREF="eval.html#variables">variables</A> for a specific buffer.


<A HREF="#vim.w">vim.w</A>                                                                  *<A NAME="vim.w"></A><B>vim.w</B>*
    Window-scoped (|<A HREF="eval.html#w:">w:</A>|) <A HREF="eval.html#variables">variables</A> for the current <A HREF="windows.html#window">window</A>.
    Invalid or unset key returns `nil`. Can be indexed with
    an integer to access <A HREF="eval.html#variables">variables</A> for a specific <A HREF="windows.html#window">window</A>.


<A HREF="#vim.t">vim.t</A>                                                                  *<A NAME="vim.t"></A><B>vim.t</B>*
    Tabpage-scoped (|<A HREF="eval.html#t:">t:</A>|) <A HREF="eval.html#variables">variables</A> for the current <A HREF="tabpage.html#tabpage">tabpage</A>.
    Invalid or unset key returns `nil`. Can be indexed with
    an integer to access <A HREF="eval.html#variables">variables</A> for a specific <A HREF="tabpage.html#tabpage">tabpage</A>.


<A HREF="#vim.v">vim.v</A>                                                                  *<A NAME="vim.v"></A><B>vim.v</B>*
    |<A HREF="eval.html#v:">v:</A>| <A HREF="eval.html#variables">variables</A>.
    Invalid or unset key returns `nil`.


<A HREF="#vim.env">vim.env</A>                                                              *<A NAME="vim.env"></A><B>vim.env</B>*
    Environment <A HREF="eval.html#variables">variables</A> defined in the editor session.
    See |<A HREF="options.html#expand-env">expand-env</A>| and |<A HREF="eval.html#:let-environment">:let-environment</A>| for the Vimscript behavior.
    Invalid or unset key returns `nil`.
    Example:
<B>        vim.env.FOO = 'bar'</B>
<B>        print(vim.env.TERM)</B>
 


                                                                 *<A NAME="lua-options"></A><B>lua-options</B>*

                                                             *<A NAME="lua-vim-options"></A><B>lua-vim-options</B>*

                                                                 *<A NAME="lua-vim-set"></A><B>lua-vim-set</B>*

                                                            *<A NAME="lua-vim-setlocal"></A><B>lua-vim-setlocal</B>*

Vim <A HREF="options.html#options">options</A> can be accessed through |<A HREF="#vim.o">vim.o</A>|, which behaves like Vimscript
|<A HREF="options.html#:set">:set</A>|.

<B><FONT COLOR="PURPLE">    Examples: </FONT></B>

    To set a <A HREF="options.html#boolean">boolean</A> toggle:
        Vimscript: `set number`
        <A HREF="#Lua">Lua</A>:       `vim.o.number = true`

    To set a <A HREF="eval.html#string">string</A> value:
        Vimscript: `set wildignore=*.o,*.a,__pycache__`
        <A HREF="#Lua">Lua</A>:       `vim.o.wildignore = '*.o,*.a,__pycache__'`

Similarly, there is |<A HREF="#vim.bo">vim.bo</A>| and |<A HREF="#vim.wo">vim.wo</A>| for setting buffer-scoped and
window-scoped <A HREF="options.html#options">options</A>. Note that this must NOT be confused with
|<A HREF="options.html#local-options">local-options</A>| and |<A HREF="options.html#:setlocal">:setlocal</A>|. There is also |<A HREF="#vim.go">vim.go</A>| that only accesses the
global value of a |<A HREF="options.html#global-local">global-local</A>| option, see |<A HREF="options.html#:setglobal">:setglobal</A>|.


<A HREF="#vim.o">vim.o</A>                                                                  *<A NAME="vim.o"></A><B>vim.o</B>*
    Get or set |<A HREF="options.html#options">options</A>|. Like `:set`. Invalid key is an error.

    Note: this works on both buffer-scoped and window-scoped <A HREF="options.html#options">options</A> using the
    current buffer and <A HREF="windows.html#window">window</A>.

    Example:
<B>        vim.o.cmdheight = 4</B>
<B>        print(vim.o.columns)</B>
<B>        print(vim.o.foo)     -- error: invalid key</B>
 

<A HREF="#vim.go">vim.go</A>                                                                *<A NAME="vim.go"></A><B>vim.go</B>*
    Get or set global |<A HREF="options.html#options">options</A>|. Like `:setglobal`. Invalid key is
    an error.

    Note: this is different from |<A HREF="#vim.o">vim.o</A>| because this accesses the global
    option value and thus is mostly useful for use with |<A HREF="options.html#global-local">global-local</A>|
    <A HREF="options.html#options">options</A>.

    Example:
<B>        vim.go.cmdheight = 4</B>
<B>        print(vim.go.columns)</B>
<B>        print(vim.go.bar)     -- error: invalid key</B>
 

vim.bo[{bufnr}]                                                                *<A NAME="vim.bo"></A><B>vim.bo</B>*
    Get or set buffer-scoped |<A HREF="options.html#options">options</A>| for the buffer with number {bufnr}.
    Like `:set` and `:setlocal`. If [{bufnr}] is omitted then the current
    buffer is used. Invalid {bufnr} or key is an error.

    Note: this is equivalent to both `:set` and `:setlocal`.

    Example:
<B>        local bufnr = vim.api.nvim_get_current_buf()</B>
<B>        vim.bo[bufnr].buflisted = true    -- same as vim.bo.buflisted = true</B>
<B>        print(vim.bo.comments)</B>
<B>        print(vim.bo.baz)                 -- error: invalid key</B>
 

vim.wo[{winid}]                                                                *<A NAME="vim.wo"></A><B>vim.wo</B>*
    Get or set window-scoped |<A HREF="options.html#options">options</A>| for the <A HREF="windows.html#window">window</A> with handle {winid}.
    Like `:set`. If [{winid}] is omitted then the current <A HREF="windows.html#window">window</A> is used.
    Invalid {winid} or key is an error.

    Note: this does not access |<A HREF="options.html#local-options">local-options</A>| (`:setlocal`) instead use:
<B>        nvim_get_option_value(OPTION, { scope = 'local', win = winid })</B>
<B>        nvim_set_option_value(OPTION, VALUE, { scope = 'local', win = winid }</B>
 
    Example:
<B>        local winid = vim.api.nvim_get_current_win()</B>
<B>        vim.wo[winid].number = true    -- same as vim.wo.number = true</B>
<B>        print(vim.wo.foldmarker)</B>
<B>        print(vim.wo.quux)             -- error: invalid key</B>
 




                                                                          *<A NAME="lua-vim-opt"></A><B>lua-vim-opt</B>*

                                                                     *<A NAME="lua-vim-optlocal"></A><B>lua-vim-optlocal</B>*

                                                                    *<A NAME="lua-vim-optglobal"></A><B>lua-vim-optglobal</B>*

                                                                              *<A NAME="vim.opt"></A><B>vim.opt</B>*


A special interface |<A HREF="vim.html">vim.opt</A>| exists for conveniently interacting with list-
and map-style option from <A HREF="#Lua">Lua</A>: It allows accessing them <A HREF="motion.html#as">as</A> <A HREF="#Lua">Lua</A> tables and
offers object-oriented <A HREF="eval.html#method">method</A> for adding and removing entries.

<B><FONT COLOR="PURPLE">    Examples: </FONT></B>

    The following methods of setting a list-style option are equivalent:
        In Vimscript:
            `set wildignore=*.o,*.a,__pycache__`

        In <A HREF="#Lua">Lua</A> using `vim.o`:
            `vim.o.wildignore = '*.o,*.a,__pycache__'`

        In <A HREF="#Lua">Lua</A> using `vim.opt`:
            `vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }`

    To replicate the behavior of |<A HREF="options.html#:set+=">:set+=</A>|, use:

<B>        vim.opt.wildignore:append { "*.pyc", "node_modules" }</B>
 
    To replicate the behavior of |<A HREF="options.html#:set^=">:set^=</A>|, use:

<B>        vim.opt.wildignore:prepend { "new_first_value" }</B>
 
    To replicate the behavior of |<A HREF="options.html#:set-=">:set-=</A>|, use:

<B>        vim.opt.wildignore:remove { "node_modules" }</B>
 
    The following methods of setting a map-style option are equivalent:
        In Vimscript:
            `set listchars=space:_,tab:&gt;~`

        In <A HREF="#Lua">Lua</A> using `vim.o`:
            `vim.o.listchars = 'space:_,tab:&gt;~'`

        In <A HREF="#Lua">Lua</A> using `vim.opt`:
            `vim.opt.listchars = { space = '<A HREF="motion.html#_">_</A>', <A HREF="intro.html#tab">tab</A> = '&gt;~' }`


Note that |<A HREF="vim.html">vim.opt</A>| returns an `Option` object, not the value of the option,
which is accessed through YXXYvim.opt:get()|:

<B><FONT COLOR="PURPLE">    Examples: </FONT></B>

    The following methods of getting a list-style option are equivalent:
        In Vimscript:
            `echo wildignore`

        In <A HREF="#Lua">Lua</A> using `vim.o`:
            `print(vim.o.wildignore)`

        In <A HREF="#Lua">Lua</A> using `vim.opt`:
            `vim.pretty_print(vim.opt.wildignore:get())`


In any of the above examples, to replicate the behavior |<A HREF="options.html#:setlocal">:setlocal</A>|, use
`vim.opt_local`. Additionally, to replicate the behavior of |<A HREF="options.html#:setglobal">:setglobal</A>|, use
`vim.opt_global`.




                                                               *<A NAME="vim.opt:get()"></A><B>vim.opt:get()</B>*
Option:get()

    Returns a lua-representation of the option. <A HREF="eval.html#Boolean">Boolean</A>, number and <A HREF="eval.html#string">string</A>
    values will be returned in exactly the same fashion.

    For values that are comma-separated lists, an array will be returned with
    the values <A HREF="motion.html#as">as</A> entries in the array:
<B>        vim.cmd [[set wildignore=*.pyc,*.o]]</B>

<B>        vim.pretty_print(vim.opt.wildignore:get())</B>
<B>        -- { "*.pyc", "*.o", }</B>

<B>        for _, ignore_pattern in ipairs(vim.opt.wildignore:get()) do</B>
<B>            print("Will ignore:", ignore_pattern)</B>
<B>        end</B>
<B>        -- Will ignore: *.pyc</B>
<B>        -- Will ignore: *.o</B>
 
    For values that are comma-separated maps, a table will be returned with
    the names <A HREF="motion.html#as">as</A> keys and the values <A HREF="motion.html#as">as</A> entries:
<B>        vim.cmd [[set listchars=space:_,tab:&gt;~]]</B>

<B>        vim.pretty_print(vim.opt.listchars:get())</B>
<B>        --  { space = "_", tab = "&gt;~", }</B>

<B>        for char, representation in pairs(vim.opt.listchars:get()) do</B>
<B>            print(char, "-&gt;", representation)</B>
<B>        end</B>
 
    For values that are lists of flags, a set will be returned with the flags
    <A HREF="motion.html#as">as</A> keys and `true` <A HREF="motion.html#as">as</A> entries.
<B>        vim.cmd [[set formatoptions=njtcroql]]</B>

<B>        vim.pretty_print(vim.opt.formatoptions:get())</B>
<B>        -- { n = true, j = true, c = true, ... }</B>

<B>        local format_opts = vim.opt.formatoptions:get()</B>
<B>        if format_opts.j then</B>
<B>            print("J is enabled!")</B>
<B>        end</B>
 

                                                            *<A NAME="vim.opt:append()"></A><B>vim.opt:append()</B>*
Option:append(value)

    Append a value to string-style <A HREF="options.html#options">options</A>. See |<A HREF="options.html#:set+=">:set+=</A>|

    These are equivalent:
        `vim.opt.formatoptions:append('j')`
        `vim.opt.formatoptions = vim.opt.formatoptions + 'j'`


                                                           *<A NAME="vim.opt:prepend()"></A><B>vim.opt:prepend()</B>*
Option:prepend(value)

    Prepend a value to string-style <A HREF="options.html#options">options</A>. See |<A HREF="options.html#:set^=">:set^=</A>|

    These are equivalent:
        `vim.opt.wildignore:prepend('*.o')`
        `vim.opt.wildignore = vim.opt.wildignore ^ '*.o'`


                                                            *<A NAME="vim.opt:remove()"></A><B>vim.opt:remove()</B>*
Option:remove(value)

    Remove a value from string-style <A HREF="options.html#options">options</A>. See |<A HREF="options.html#:set-=">:set-=</A>|

    These are equivalent:
        `vim.opt.wildignore:remove('*.pyc')`
        `vim.opt.wildignore = vim.opt.wildignore - '*.pyc'`


==============================================================================

<A HREF="#Lua">Lua</A> module: vim                                                      *<A NAME="lua-vim"></A><B>lua-vim</B>*


cmd({command})                                                     *<A NAME="vim.cmd()"></A><B>vim.cmd()</B>*
    Execute Vim <A HREF="usr_41.html#script">script</A> commands.

    Note that `vim.cmd` can be indexed with a command name to return a
    callable function to the command.

    Example:

<B>       vim.cmd('echo 42')</B>
<B>       vim.cmd([[</B>
<B>         augroup My_group</B>
<B>           autocmd!</B>
<B>           autocmd FileType c setlocal cindent</B>
<B>         augroup END</B>
<B>       ]])</B>

<B>       -- Ex command :echo "foo"</B>
<B>       -- Note string literals need to be double quoted.</B>
<B>       vim.cmd('echo "foo"')</B>
<B>       vim.cmd { cmd = 'echo', args = { '"foo"' } }</B>
<B>       vim.cmd.echo({ args = { '"foo"' } })</B>
<B>       vim.cmd.echo('"foo"')</B>

<B>       -- Ex command :write! myfile.txt</B>
<B>       vim.cmd('write! myfile.txt')</B>
<B>       vim.cmd { cmd = 'write', args = { "myfile.txt" }, bang = true }</B>
<B>       vim.cmd.write { args = { "myfile.txt" }, bang = true }</B>
<B>       vim.cmd.write { "myfile.txt", bang = true }</B>

<B>       -- Ex command :colorscheme blue</B>
<B>       vim.cmd('colorscheme blue')</B>
<B>       vim.cmd.colorscheme('blue')</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {command}  string|table Command(s) to execute. If a <A HREF="eval.html#string">string</A>, executes
                   multiple lines of Vim <A HREF="usr_41.html#script">script</A> at once. In this <A HREF="change.html#case">case</A>, <A HREF="motion.html#it">it</A> is
                   an alias to |<A HREF="api.html#nvim_exec()">nvim_exec()</A>|, where `output` is set to false.
                   Thus <A HREF="motion.html#it">it</A> works identical to |<A HREF="repeat.html#:source">:source</A>|. If a table, executes
                   a single command. In this <A HREF="change.html#case">case</A>, <A HREF="motion.html#it">it</A> is an alias to
                   |<A HREF="api.html#nvim_cmd()">nvim_cmd()</A>| where `opts` is empty.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vimindex.html#ex-cmd-index">ex-cmd-index</A>|


                                             *<A NAME="vim.connection_failure_errmsg()"></A><B>vim.connection_failure_errmsg()</B>*
connection_failure_errmsg({consequence})
    TODO: Documentation


defer_fn({fn}, {timeout})                                     *<A NAME="vim.defer_fn()"></A><B>vim.defer_fn()</B>*
    Defers calling `fn` until `timeout` ms passes.

    Use to <A HREF="diff.html#do">do</A> a one-shot <A HREF="builtin.html#timer">timer</A> that calls `fn` Note: The {fn} is |vim.schedule_wrap()|ped automatically, so <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A>
    are safe to call.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {fn}       Callback to call once `timeout` expires
        {timeout}  <A HREF="eval.html#Number">Number</A> of milliseconds to wait before calling `fn`

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="builtin.html#timer">timer</A> <A HREF="luvref.html#luv">luv</A> <A HREF="builtin.html#timer">timer</A> object


                                                             *<A NAME="vim.deprecate()"></A><B>vim.deprecate()</B>*
deprecate({name}, {alternative}, {version}, {plugin}, {backtrace})
    Display a deprecation notification to the user.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}         <A HREF="eval.html#string">string</A> Deprecated function.
        {alternative}  (string|nil) Preferred alternative function.
        {version}      <A HREF="eval.html#string">string</A> Version in which the <A HREF="deprecated.html#deprecated">deprecated</A> function will be
                       removed.
        {plugin}       string|nil Plugin name that the function will be
                       removed from. Defaults to &quot;Nvim&quot;.
        {backtrace}    boolean|nil Prints backtrace. Defaults to true.


inspect({object}, {options})                                   *<A NAME="vim.inspect()"></A><B>vim.inspect()</B>*
    Return a human-readable representation of the given object.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        https://github.com/kikito/inspect.lua
        https://github.com/mpeterv/vinspect


notify({msg}, {level}, {opts})                                  *<A NAME="vim.notify()"></A><B>vim.notify()</B>*
    Display a notification to the user.

    This function can be overridden by plugins to display notifications using
    a custom <A HREF="provider.html#provider">provider</A> (such <A HREF="motion.html#as">as</A> the system notification <A HREF="provider.html#provider">provider</A>). By default,
    writes to |<A HREF="message.html#:messages">:messages</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {msg}    (string) Content of the notification to show to the user.
        {level}  (number|nil) One of the values from |vim.log.levels|.|||
        {opts}   (table|nil) Optional parameters. Unused by default.


notify_once({msg}, {level}, {opts})                        *<A NAME="vim.notify_once()"></A><B>vim.notify_once()</B>*
    Display a notification only one time.

    Like |<A HREF="vim.html">vim.notify()</A>|, but subsequent calls with the same message will not
    display a notification.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {msg}    (string) Content of the notification to show to the user.
        {level}  (number|nil) One of the values from |vim.log.levels|.|||
        {opts}   (table|nil) Optional parameters. Unused by default.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) true if message was displayed, else false


on_key({fn}, {ns_id})                                           *<A NAME="vim.on_key()"></A><B>vim.on_key()</B>*
    Adds <A HREF="#Lua">Lua</A> function {fn} with <A HREF="api.html#namespace">namespace</A> id {ns_id} <A HREF="motion.html#as">as</A> a listener to every,
    yes every, input key.

    The Nvim command-line option |<A HREF="starting.html#-w">-w</A>| is related but does not support
    callbacks and cannot be toggled dynamically.

    Note:
        {fn} will not be cleared by |<A HREF="api.html#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>|

    Note:
        {fn} will receive the keys after mappings have been evaluated

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {fn}     function: Callback function. It should take one <A HREF="eval.html#string">string</A>
                 argument. On each key press, Nvim passes the key char to
                 fn(). |<A HREF="insert.html#i_CTRL-V">i_CTRL-V</A>| If {fn} is nil, <A HREF="motion.html#it">it</A> removes the callback for
                 the associated {ns_id}
        {ns_id}  number? Namespace ID. If nil or 0, generates and returns a
                 new |<A HREF="api.html#nvim_create_namespace()">nvim_create_namespace()</A>| id.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (number) Namespace id associated with {fn}. Or <A HREF="intro.html#count">count</A> of all callbacks
        if on_key() is called without arguments.

    Note:
        {fn} will be removed if an error occurs while calling.


paste({lines}, {phase})                                          *<A NAME="vim.paste()"></A><B>vim.paste()</B>*
    Paste handler, invoked by |<A HREF="api.html#nvim_paste()">nvim_paste()</A>| when a conforming <A HREF="ui.html#UI">UI</A> (such as the
    |<A HREF="term.html#TUI">TUI</A>|) pastes text into the editor.

    Example: To remove ANSI color codes when pasting:

<B>     vim.paste = (function(overridden)</B>
<B>       return function(lines, phase)</B>
<B>         for i,line in ipairs(lines) do</B>
<B>           -- Scrub ANSI color codes from paste input.</B>
<B>           lines[i] = line:gsub('\27%[[0-9;mK]+', '')</B>
<B>         end</B>
<B>         overridden(lines, phase)</B>
<B>       end</B>
<B>     end)(vim.paste)</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {lines}  |readfile()|-style list of lines to paste. |channel-lines||||
        {phase}  -1: &quot;non-streaming&quot; <A HREF="provider.html#paste">paste</A>: the call contains all lines. If
                 <A HREF="provider.html#paste">paste</A> is &quot;streamed&quot;, `phase` indicates the stream state:
                 • 1: starts the <A HREF="provider.html#paste">paste</A> (exactly once)
                 • 2: continues the <A HREF="provider.html#paste">paste</A> (zero or more times)
                 • 3: ends the <A HREF="provider.html#paste">paste</A> (exactly once)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        false if client should cancel the <A HREF="provider.html#paste">paste</A>.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="provider.html#paste">paste</A>|


pretty_print({...})                                       *<A NAME="vim.pretty_print()"></A><B>vim.pretty_print()</B>*
    Prints given arguments in human-readable format. Example:
<B>      -- Print highlight group Normal and store it's contents in a variable.</B>
<B>      local hl_normal = vim.pretty_print(vim.api.nvim_get_hl_by_name("Normal", true))</B>
 

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        given arguments.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vim.html">vim.inspect()</A>|


region({bufnr}, {pos1}, {pos2}, {regtype}, {inclusive})         *<A NAME="vim.region()"></A><B>vim.region()</B>*
    Get a table of lines with start, end columns for a region marked by two
    points

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {bufnr}      (number) of buffer
        {pos1}       (line, column) tuple marking beginning of region
        {pos2}       (line, column) tuple marking end of region
        {regtype}    type of selection, see |<A HREF="builtin.html#setreg()">setreg()</A>|
        {inclusive}  (boolean) indicating whether the selection is
                     end-inclusive

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        region <A HREF="#lua">lua</A> table of the form {linenr = {startcol,endcol}}


schedule_wrap({cb})                                      *<A NAME="vim.schedule_wrap()"></A><B>vim.schedule_wrap()</B>*
    Defers callback `cb` until the Nvim <A HREF="api.html#API">API</A> is safe to call.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#lua-loop-callbacks">lua-loop-callbacks</A>|
        |<A HREF="vim.html">vim.schedule()</A>|
        |<A HREF="vim.html">vim.in_fast_event()</A>|





deep_equal({a}, {b})                                        *<A NAME="vim.deep_equal()"></A><B>vim.deep_equal()</B>*
    Deep compare values for equality

    Tables are compared recursively unless they both provide the `eq` metamethod. All other types are compared using the equality `==` <A HREF="motion.html#operator">operator</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {a}  any First value
        {b}  any Second value

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if values are equals, else `false`


deepcopy({orig})                                              *<A NAME="vim.deepcopy()"></A><B>vim.deepcopy()</B>*
    Returns a deep copy of the given object. Non-table <A HREF="vimindex.html#objects">objects</A> are copied <A HREF="motion.html#as">as</A>
    in a typical <A HREF="#Lua">Lua</A> assignment, whereas table <A HREF="vimindex.html#objects">objects</A> are copied recursively.
    Functions are naively copied, so <A HREF="eval.html#functions">functions</A> in the copied table point to
    the same <A HREF="eval.html#functions">functions</A> <A HREF="motion.html#as">as</A> those in the input table. Userdata and threads are
    not copied and will throw an error.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {orig}  (table) Table to copy

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Table of copied keys and (nested) values.


defaulttable({create})                                    *<A NAME="vim.defaulttable()"></A><B>vim.defaulttable()</B>*
    Creates a table whose members are automatically created when accessed, if
    they don't already exist.

    They mimic defaultdict in <A HREF="if_pyth.html#python">python</A>.

    If {create} is `nil`, this will create a defaulttable whose constructor
    function is this function, effectively allowing to create nested tables on
    the fly:


<B>    local a = vim.defaulttable()</B>
<B>    a.b.c = 1</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {create}  (function|nil) The function called to create a missing
                  value.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Empty table with metamethod


endswith({s}, {suffix})                                       *<A NAME="vim.endswith()"></A><B>vim.endswith()</B>*
    Tests if `s` ends with `suffix`.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {s}       (string) <A HREF="eval.html#String">String</A>
        {suffix}  (string) Suffix to match

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if `suffix` is a suffix of `s`


gsplit({s}, {sep}, {plain})                                     *<A NAME="vim.gsplit()"></A><B>vim.gsplit()</B>*
    Splits a <A HREF="eval.html#string">string</A> at each instance of a separator.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {s}      (string) <A HREF="eval.html#String">String</A> to split
        {sep}    (string) Separator or <A HREF="pattern.html#pattern">pattern</A>
        {plain}  (boolean) If `true` use `sep` literally (passed to
                 string.find)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (function) Iterator over the split components

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vim.html">vim.split()</A>|
        https://www.lua.org/pil/20.2.html
	<A HREF="http://lua-users.org/wiki/StringLibraryTutorial">http://lua-users.org/wiki/StringLibraryTutorial</A>


is_callable({f})                                           *<A NAME="vim.is_callable()"></A><B>vim.is_callable()</B>*
    Returns true if object `f` can be called <A HREF="motion.html#as">as</A> a function.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {f}  any Any object

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if `f` is callable, else `false`


list_extend({dst}, {src}, {start}, {finish})               *<A NAME="vim.list_extend()"></A><B>vim.list_extend()</B>*
    Extends a list-like table with the values of another list-like table.

    NOTE: This mutates dst!

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {dst}     (table) <A HREF="eval.html#List">List</A> which will be modified and appended to
        {src}     (table) <A HREF="eval.html#List">List</A> from which values will be inserted
        {start}   (number) Start index on src. Defaults to 1
        {finish}  (number) Final index on src. Defaults to `#src`

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) dst

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vim.html">vim.tbl_extend()</A>|


list_slice({list}, {start}, {finish})                       *<A NAME="vim.list_slice()"></A><B>vim.list_slice()</B>*
    Creates a copy of a table containing only elements from start to end
    (inclusive)

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {list}    (table) Table
        {start}   (number) Start range of <A HREF="eval.html#slice">slice</A>
        {finish}  (number) End range of <A HREF="eval.html#slice">slice</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Copy of table sliced from start to finish (inclusive)


pesc({s})                                                         *<A NAME="vim.pesc()"></A><B>vim.pesc()</B>*
    Escapes magic chars in |<A HREF="#lua-patterns">lua-patterns</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {s}  (string) <A HREF="eval.html#String">String</A> to <A HREF="intro.html#escape">escape</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) &#37;-escaped <A HREF="pattern.html#pattern">pattern</A> <A HREF="eval.html#string">string</A>

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        https://github.com/rxi/lume


split({s}, {sep}, {kwargs})                                      *<A NAME="vim.split()"></A><B>vim.split()</B>*
    Splits a <A HREF="eval.html#string">string</A> at each instance of a separator.

    Examples:

<B>      split(":aa::b:", ":")     --&gt; {'','aa','','b',''}</B>
<B>      split("axaby", "ab?")     --&gt; {'','x','y'}</B>
<B>      split("x*yz*o", "*", {plain=true})  --&gt; {'x','yz','o'}</B>
<B>      split("|x|y|z|", "|", {trimempty=true}) --&gt; {'x', 'y', 'z'}</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {s}       (string) <A HREF="eval.html#String">String</A> to split
        {sep}     (string) Separator or <A HREF="pattern.html#pattern">pattern</A>
        {kwargs}  (table) Keyword arguments:
                  • plain: (boolean) If `true` use `sep` literally (passed to
                    string.find)
                  • trimempty: (boolean) If `true` remove empty items from the
                    front and back of the <A HREF="eval.html#list">list</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) <A HREF="eval.html#List">List</A> of split components

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vim.html">vim.gsplit()</A>|


startswith({s}, {prefix})                                   *<A NAME="vim.startswith()"></A><B>vim.startswith()</B>*
    Tests if `s` starts with `prefix`.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {s}       (string) <A HREF="eval.html#String">String</A>
        {prefix}  (string) Prefix to match

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if `prefix` is a prefix of `s`


tbl_add_reverse_lookup({o})                     *<A NAME="vim.tbl_add_reverse_lookup()"></A><B>vim.tbl_add_reverse_lookup()</B>*
    Add the reverse lookup values to an existing table. For example:
    `tbl_add_reverse_lookup { A = 1 } <A HREF="change.html#==">==</A> { [1] = '<A HREF="insert.html#A">A</A>', A = 1 }`

    Note that this modifies the input.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {o}  (table) Table to add the reverse to

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) <A HREF="insert.html#o">o</A>


tbl_contains({t}, {value})                                *<A NAME="vim.tbl_contains()"></A><B>vim.tbl_contains()</B>*
    Checks if a list-like (vector) table contains `value`.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}      (table) Table to check
        {value}  any Value to compare

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if `t` contains `value`


tbl_count({t})                                               *<A NAME="vim.tbl_count()"></A><B>vim.tbl_count()</B>*
    Counts the number of non-nil values in table `t`.


<B>    vim.tbl_count({ a=1, b=2 }) =&gt; 2</B>
<B>    vim.tbl_count({ 1, 2 }) =&gt; 2</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}  (table) Table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (number) <A HREF="eval.html#Number">Number</A> of non-nil values in table

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua


tbl_deep_extend({behavior}, {...})                     *<A NAME="vim.tbl_deep_extend()"></A><B>vim.tbl_deep_extend()</B>*
    Merges recursively two or more map-like tables.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {behavior}  (string) Decides what to <A HREF="diff.html#do">do</A> if a key is found in more than
                    one map:
                    • &quot;error&quot;: raise an error
                    • &quot;keep&quot;: use value from the leftmost map
                    • &quot;force&quot;: use value from the rightmost map
        {...}       (table) Two or more map-like tables

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Merged table

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vim.html">vim.tbl_extend()</A>|


tbl_extend({behavior}, {...})                               *<A NAME="vim.tbl_extend()"></A><B>vim.tbl_extend()</B>*
    Merges two or more map-like tables.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {behavior}  (string) Decides what to <A HREF="diff.html#do">do</A> if a key is found in more than
                    one map:
                    • &quot;error&quot;: raise an error
                    • &quot;keep&quot;: use value from the leftmost map
                    • &quot;force&quot;: use value from the rightmost map
        {...}       (table) Two or more map-like tables

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Merged table

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="builtin.html#extend()">extend()</A>|


tbl_filter({func}, {t})                                     *<A NAME="vim.tbl_filter()"></A><B>vim.tbl_filter()</B>*
    Filter a table using a predicate function

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {func}  function|table Function or callable table
        {t}     (table) Table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Table of filtered values


tbl_flatten({t})                                           *<A NAME="vim.tbl_flatten()"></A><B>vim.tbl_flatten()</B>*
    Creates a copy of a list-like table such that any nested tables are
    &quot;unrolled&quot; and appended to the result.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}  (table) List-like table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Flattened copy of the given list-like table

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        From https://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_get({o}, {...})                                            *<A NAME="vim.tbl_get()"></A><B>vim.tbl_get()</B>*
    Index into a table (first argument) via <A HREF="eval.html#string">string</A> keys passed <A HREF="motion.html#as">as</A> subsequent
    arguments. Return `nil` if the key does not exist.

    Examples:

<B>      vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true</B>
<B>      vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {o}    (table) Table to index
        {...}  (string) Optional strings (0 or more, variadic) via which to
               index the table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        any Nested value indexed by key (if <A HREF="motion.html#it">it</A> exists), else nil


tbl_isempty({t})                                           *<A NAME="vim.tbl_isempty()"></A><B>vim.tbl_isempty()</B>*
    Checks if a table is empty.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}  (table) Table to check

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if `t` is empty

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        https://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_islist({t})                                             *<A NAME="vim.tbl_islist()"></A><B>vim.tbl_islist()</B>*
    Tests if a <A HREF="#Lua">Lua</A> table can be treated <A HREF="motion.html#as">as</A> an array.

    Empty table `{}` is assumed to be an array, unless <A HREF="motion.html#it">it</A> was created by
    |<A HREF="vim.html">vim.empty_dict()</A>| or returned <A HREF="motion.html#as">as</A> a dict-like |<A HREF="api.html#API">API</A>| or Vimscript result,
    for example from |<A HREF="builtin.html#rpcrequest()">rpcrequest()</A>| or |<A HREF="#vim.fn">vim.fn</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}  (table) Table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (boolean) `true` if array-like table, else `false`


tbl_keys({t})                                                 *<A NAME="vim.tbl_keys()"></A><B>vim.tbl_keys()</B>*
    Return a <A HREF="eval.html#list">list</A> of all keys used in a table. However, the order of the
    return table of keys is not guaranteed.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}  (table) Table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) <A HREF="eval.html#List">List</A> of keys

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        From https://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_map({func}, {t})                                           *<A NAME="vim.tbl_map()"></A><B>vim.tbl_map()</B>*
    Apply a function to all values of a table.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {func}  function|table Function or callable table
        {t}     (table) Table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) Table of transformed values


tbl_values({t})                                             *<A NAME="vim.tbl_values()"></A><B>vim.tbl_values()</B>*
    Return a <A HREF="eval.html#list">list</A> of all values used in a table. However, the order of the
    return table of values is not guaranteed.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {t}  (table) Table

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) <A HREF="eval.html#List">List</A> of values


trim({s})                                                         *<A NAME="vim.trim()"></A><B>vim.trim()</B>*
    Trim <A HREF="pattern.html#whitespace">whitespace</A> (Lua <A HREF="pattern.html#pattern">pattern</A> &quot;&#37;s&quot;) from both sides of a <A HREF="eval.html#string">string</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {s}  (string) <A HREF="eval.html#String">String</A> to trim

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) <A HREF="eval.html#String">String</A> with <A HREF="pattern.html#whitespace">whitespace</A> removed from its beginning and end

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        https://www.lua.org/pil/20.2.html


validate({opt})                                               *<A NAME="vim.validate()"></A><B>vim.validate()</B>*
    Validates a parameter specification (types and values).

    Usage example:

<B>      function user.new(name, age, hobbies)</B>
<B>        vim.validate{</B>
<B>          name={name, 'string'},</B>
<B>          age={age, 'number'},</B>
<B>          hobbies={hobbies, 'table'},</B>
<B>        }</B>
<B>        ...</B>
<B>      end</B>
 

    Examples with explicit argument values (can be run directly):

<B>      vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}</B>
<B>         =&gt; NOP (success)</B>

<B>      vim.validate{arg1={1, 'table'}}</B>
<B>         =&gt; error('arg1: expected table, got number')</B>

<B>      vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}</B>
<B>         =&gt; error('arg1: expected even number, got 3')</B>
 

    If multiple types are valid they can be given <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A>.

<B>      vim.validate{arg1={{'foo'}, {'table', 'string'}}, arg2={'foo', {'table', 'string'}}}</B>
<B>         =&gt; NOP (success)</B>

<B>      vim.validate{arg1={1, {'string', table'}}}</B>
<B>         =&gt; error('arg1: expected string|table, got number')</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opt}  (table) Names of parameters to validate. Each key is a
               parameter name; each value is a tuple in one of these forms:
               1. (arg_value, type_name, optional)
                  • arg_value: argument value
                  • type_name: string|table type name, one of: (&quot;table&quot;, &quot;<A HREF="motion.html#t">t</A>&quot;,
                    &quot;<A HREF="eval.html#string">string</A>&quot;, &quot;<A HREF="change.html#s">s</A>&quot;, &quot;number&quot;, &quot;<A HREF="pattern.html#n">n</A>&quot;, &quot;<A HREF="options.html#boolean">boolean</A>&quot;, &quot;<A HREF="motion.html#b">b</A>&quot;, &quot;function&quot;,
                    &quot;<A HREF="motion.html#f">f</A>&quot;, &quot;nil&quot;, &quot;thread&quot;, &quot;userdata&quot;) or <A HREF="eval.html#list">list</A> of them.
                  • optional: (optional) <A HREF="options.html#boolean">boolean</A>, if true, `nil` is valid

               2. (arg_value, fn, msg)
                  • arg_value: argument value
                  • fn: any function accepting one argument, returns true if
                    and only if the argument is valid. Can optionally return
                    an additional informative error message <A HREF="motion.html#as">as</A> the second
                    returned value.
                  • msg: (optional) error <A HREF="eval.html#string">string</A> if validation fails


==============================================================================

<A HREF="#Lua">Lua</A> module: uri                                                      *<A NAME="lua-uri"></A><B>lua-uri</B>*


uri_from_bufnr({bufnr})                                 *<A NAME="vim.uri_from_bufnr()"></A><B>vim.uri_from_bufnr()</B>*
    Get a URI from a bufnr

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {bufnr}  (number)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) URI


uri_from_fname({path})                                  *<A NAME="vim.uri_from_fname()"></A><B>vim.uri_from_fname()</B>*
    Get a URI from a file path.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {path}  (string) Path to file

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) URI


uri_to_bufnr({uri})                                       *<A NAME="vim.uri_to_bufnr()"></A><B>vim.uri_to_bufnr()</B>*
    Get the buffer for a uri. Creates a new unloaded buffer if no buffer for
    the uri already exists.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {uri}  (string)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (number) bufnr


uri_to_fname({uri})                                       *<A NAME="vim.uri_to_fname()"></A><B>vim.uri_to_fname()</B>*
    Get a filename from a URI

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {uri}  (string)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) filename or unchanged URI for non-file URIs


==============================================================================

<A HREF="#Lua">Lua</A> module: <A HREF="ui.html#ui">ui</A>                                                        *<A NAME="lua-ui"></A><B>lua-ui</B>*


input({opts}, {on_confirm})                                   *<A NAME="vim.ui.input()"></A><B>vim.ui.input()</B>*
    Prompts the user for input

    Example:

<B>     vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)</B>
<B>         vim.o.shiftwidth = tonumber(input)</B>
<B>     end)</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opts}        (table) Additional <A HREF="options.html#options">options</A>. See |<A HREF="builtin.html#input()">input()</A>|
                      • prompt (string|nil) Text of the prompt
                      • default (string|nil) Default reply to the input
                      • completion (string|nil) Specifies type of completion
                        supported for input. Supported types are the same that
                        can be supplied to a user-defined command using the
                        &quot;-complete=&quot; argument. See |<A HREF="map.html#:command-completion">:command-completion</A>|
                      • highlight (function) Function that will be used for
                        highlighting user inputs.
        {on_confirm}  (function) ((input|nil) <A HREF="eval.html#-&gt;">-&gt;</A> ()) Called once the user
                      confirms or abort the input. `input` is what the user
                      typed. `nil` if the user aborted the dialog.


select({items}, {opts}, {on_choice})                         *<A NAME="vim.ui.select()"></A><B>vim.ui.select()</B>*
    Prompts the user to pick a single item from a collection of entries

    Example:

<B>     vim.ui.select({ 'tabs', 'spaces' }, {</B>
<B>         prompt = 'Select tabs or spaces:',</B>
<B>         format_item = function(item)</B>
<B>             return "I'd like to choose " .. item</B>
<B>         end,</B>
<B>     }, function(choice)</B>
<B>         if choice == 'spaces' then</B>
<B>             vim.o.expandtab = true</B>
<B>         else</B>
<B>             vim.o.expandtab = false</B>
<B>         end</B>
<B>     end)</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {items}      (table) Arbitrary items
        {opts}       (table) Additional <A HREF="options.html#options">options</A>
                     • prompt (string|nil) Text of the prompt. Defaults to
                       `Select one of:`
                     • format_item (function item <A HREF="eval.html#-&gt;">-&gt;</A> text) Function to format
                       an individual item from `items`. Defaults to
                       `tostring`.
                     • kind (string|nil) Arbitrary hint <A HREF="eval.html#string">string</A> indicating the
                       item shape. Plugins reimplementing `vim.ui.select` may
                       wish to use this to infer the structure or semantics of
                       `items`, or the <A HREF="repeat.html#context">context</A> in which select() was called.
        {on_choice}  (function) ((item|nil, idx|nil) <A HREF="eval.html#-&gt;">-&gt;</A> ()) Called once the
                     user made a choice. `idx` is the 1-based index of `item`
                     within `items`. `nil` if the user aborted the dialog.


==============================================================================

<A HREF="#Lua">Lua</A> module: <A HREF="filetype.html#filetype">filetype</A>                                            *<A NAME="lua-filetype"></A><B>lua-filetype</B>*


add({filetypes})                                          *<A NAME="vim.filetype.add()"></A><B>vim.filetype.add()</B>*
    Add new <A HREF="filetype.html#filetype">filetype</A> mappings.

    Filetype mappings can be added either by extension or by filename (either
    the &quot;tail&quot; or the full file path). The full file path is checked first,
    followed by the file name. If a match is not found using the filename,
    then the filename is matched against the <A HREF="eval.html#list">list</A> of |<A HREF="#lua-patterns">lua-patterns</A>| (sorted by
    priority) until a match is found. Lastly, if <A HREF="pattern.html#pattern">pattern</A> matching does not
    find a <A HREF="filetype.html#filetype">filetype</A>, then the file extension is used.

    The <A HREF="filetype.html#filetype">filetype</A> can be either a <A HREF="eval.html#string">string</A> (in which <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> is used <A HREF="motion.html#as">as</A> the
    <A HREF="filetype.html#filetype">filetype</A> directly) or a function. If a function, <A HREF="motion.html#it">it</A> takes the full path
    and buffer number of the file <A HREF="motion.html#as">as</A> arguments (along with captures from the
    matched <A HREF="pattern.html#pattern">pattern</A>, if any) and should return a <A HREF="eval.html#string">string</A> that will be used <A HREF="motion.html#as">as</A>
    the buffer's <A HREF="filetype.html#filetype">filetype</A>. Optionally, the function can return a second
    function value which, when called, modifies the state of the buffer. This
    can be used to, for example, set filetype-specific buffer <A HREF="eval.html#variables">variables</A>.

    Filename patterns can specify an optional priority to resolve cases when a
    file path matches multiple patterns. Higher priorities are matched first.
    When omitted, the priority defaults to 0. A <A HREF="pattern.html#pattern">pattern</A> can contain
    environment <A HREF="eval.html#variables">variables</A> of the form &quot;${SOME_VAR}&quot; that will be automatically
    expanded. If the environment variable is not set, the <A HREF="pattern.html#pattern">pattern</A> won't be
    matched.

    See $VIMRUNTIME/lua/vim/filetype.lua for more examples.

    Note that <A HREF="#Lua">Lua</A> filetype detection is disabled when |<A HREF="filetype.html#g:do_legacy_filetype">g:do_legacy_filetype</A>|
    is set.

    Example:

<B>      vim.filetype.add({</B>
<B>        extension = {</B>
<B>          foo = 'fooscript',</B>
<B>          bar = function(path, bufnr)</B>
<B>            if some_condition() then</B>
<B>              return 'barscript', function(bufnr)</B>
<B>                -- Set a buffer variable</B>
<B>                vim.b[bufnr].barscript_version = 2</B>
<B>              end</B>
<B>            end</B>
<B>            return 'bar'</B>
<B>          end,</B>
<B>        },</B>
<B>        filename = {</B>
<B>          ['.foorc'] = 'toml',</B>
<B>          ['/etc/foo/config'] = 'toml',</B>
<B>        },</B>
<B>        pattern = {</B>
<B>          ['.*/etc/foo/.*'] = 'fooscript',</B>
<B>          -- Using an optional priority</B>
<B>          ['.*/etc/foo/.*%.conf'] = { 'dosini', { priority = 10 } },</B>
<B>          -- A pattern containing an environment variable</B>
<B>          ['${XDG_CONFIG_HOME}/foo/git'] = 'git',</B>
<B>          ['README.(a+)$'] = function(path, bufnr, ext)</B>
<B>            if ext == 'md' then</B>
<B>              return 'markdown'</B>
<B>            elseif ext == 'rst' then</B>
<B>              return 'rst'</B>
<B>            end</B>
<B>          end,</B>
<B>        },</B>
<B>      })</B>
 

    To add a fallback match on contents (see |<A HREF="filetype.html#new-filetype-scripts">new-filetype-scripts</A>|), use

<B>     vim.filetype.add {</B>
<B>       pattern = {</B>
<B>         ['.*'] = {</B>
<B>           priority = -math.huge,</B>
<B>           function(path, bufnr)</B>
<B>             local content = vim.filetype.getlines(bufnr, 1)</B>
<B>             if vim.filetype.matchregex(content, [[^#!.*\&lt;mine\&gt;]]) then</B>
<B>               return 'mine'</B>
<B>             elseif vim.filetype.matchregex(content, [[\&lt;drawing\&gt;]]) then</B>
<B>               return 'drawing'</B>
<B>             end</B>
<B>           end,</B>
<B>         },</B>
<B>       },</B>
<B>     }</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {filetypes}  (table) A table containing new <A HREF="filetype.html#filetype">filetype</A> maps (see
                     example).


match({args})                                           *<A NAME="vim.filetype.match()"></A><B>vim.filetype.match()</B>*
    Perform <A HREF="filetype.html#filetype">filetype</A> detection.

    The <A HREF="filetype.html#filetype">filetype</A> can be detected using one of three methods:
    1. Using an existing buffer
    2. Using only a file name
    3. Using only file contents

    Of these, option 1 provides the most accurate result <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> uses both the
    buffer's filename and (optionally) the buffer contents. Options 2 and 3
    can be used without an existing buffer, but may not always provide a match
    in cases where the filename (or contents) cannot unambiguously determine
    the <A HREF="filetype.html#filetype">filetype</A>.

    Each of the three <A HREF="options.html#options">options</A> is specified using a key to the single argument
    of this function. Example:


<B>    -- Using a buffer number</B>
<B>    vim.filetype.match({ buf = 42 })</B>

<B>    -- Override the filename of the given buffer</B>
<B>    vim.filetype.match({ buf = 42, filename = 'foo.c' })</B>

<B>    -- Using a filename without a buffer</B>
<B>    vim.filetype.match({ filename = 'main.lua' })</B>

<B>    -- Using file contents</B>
<B>    vim.filetype.match({ contents = {'#!/usr/bin/env bash'} })</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {args}  (table) Table specifying which matching strategy to use.
                Accepted keys are:
                • buf (number): Buffer number to use for matching. Mutually
                  <A HREF="motion.html#exclusive">exclusive</A> with {contents}
                • filename (string): Filename to use for matching. When {buf}
                  is given, defaults to the filename of the given buffer
                  number. The file need not actually exist in the filesystem.
                  When used without {buf} only the name of the file is used
                  for <A HREF="filetype.html#filetype">filetype</A> matching. This may result in failure to detect
                  the <A HREF="filetype.html#filetype">filetype</A> in cases where the filename alone is not enough
                  to disambiguate the <A HREF="filetype.html#filetype">filetype</A>.
                • contents (table): An array of lines representing file
                  contents to use for matching. Can be used with {filename}.
                  Mutually <A HREF="motion.html#exclusive">exclusive</A> with {buf}.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string|nil) If a match was found, the matched <A HREF="filetype.html#filetype">filetype</A>.
        (function|nil) A function that modifies buffer state when called (for
        example, to set some <A HREF="filetype.html#filetype">filetype</A> specific buffer <A HREF="eval.html#variables">variables</A>). The function
        accepts a buffer number <A HREF="motion.html#as">as</A> its only argument.


==============================================================================

<A HREF="#Lua">Lua</A> module: keymap                                                *<A NAME="lua-keymap"></A><B>lua-keymap</B>*


del({modes}, <A HREF="map.html#{lhs}">{lhs}</A>, {opts})                                 *<A NAME="vim.keymap.del()"></A><B>vim.keymap.del()</B>*
    Remove an existing <A HREF="map.html#mapping">mapping</A>. Examples:

<B>       vim.keymap.del('n', 'lhs')</B>

<B>       vim.keymap.del({'n', 'i', 'v'}, '&lt;leader&gt;w', { buffer = 5 })</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opts}  (table|nil) A table of optional arguments:
                • buffer: (number or <A HREF="options.html#boolean">boolean</A>) Remove a <A HREF="map.html#mapping">mapping</A> from the given
                  buffer. When &quot;true&quot; or 0, use the current buffer.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="vim.html">vim.keymap.set()</A>|


set({mode}, <A HREF="map.html#{lhs}">{lhs}</A>, <A HREF="map.html#{rhs}">{rhs}</A>, {opts})                           *<A NAME="vim.keymap.set()"></A><B>vim.keymap.set()</B>*
    Add a new |<A HREF="map.html#mapping">mapping</A>|. Examples:

<B>       -- Can add mapping to Lua functions</B>
<B>       vim.keymap.set('n', 'lhs', function() print("real lua function") end)</B>

<B>       -- Can use it to map multiple modes</B>
<B>       vim.keymap.set({'n', 'v'}, '&lt;leader&gt;lr', vim.lsp.buf.references, { buffer=true })</B>

<B>       -- Can add mapping for specific buffer</B>
<B>       vim.keymap.set('n', '&lt;leader&gt;w', "&lt;cmd&gt;w&lt;cr&gt;", { silent = true, buffer = 5 })</B>

<B>       -- Expr mappings</B>
<B>       vim.keymap.set('i', '&lt;Tab&gt;', function()</B>
<B>         return vim.fn.pumvisible() == 1 and "&lt;C-n&gt;" or "&lt;Tab&gt;"</B>
<B>       end, { expr = true })</B>
<B>       -- &lt;Plug&gt; mappings</B>
<B>       vim.keymap.set('n', '[%', '&lt;Plug&gt;(MatchitNormalMultiBackward)')</B>
 

    Note that in a <A HREF="map.html#mapping">mapping</A> like:

<B>        vim.keymap.set('n', 'asdf', require('jkl').my_fun)</B>
 

    the `require('jkl')` gets evaluated during this call in order to access the function. If you
    want to avoid this cost at <A HREF="starting.html#startup">startup</A> you can wrap <A HREF="motion.html#it">it</A> in a function, for
    example:

<B>        vim.keymap.set('n', 'asdf', function() return require('jkl').my_fun() end)</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {mode}  string|table Same mode short names as |nvim_set_keymap()|. Can|||
                also be <A HREF="eval.html#list">list</A> of modes to create <A HREF="map.html#mapping">mapping</A> on multiple modes.
        {lhs}   (string) Left-hand side |<A HREF="map.html#{lhs}">{lhs}</A>| of the <A HREF="map.html#mapping">mapping</A>.
        {rhs}   string|function Right-hand side |{rhs}| of the mapping. Can|||
                also be a <A HREF="#Lua">Lua</A> function.
        {opts}  (table|nil) A table of |:map-arguments|.|||
                • Accepts <A HREF="options.html#options">options</A> accepted by the {opts} parameter in
                  |<A HREF="api.html#nvim_set_keymap()">nvim_set_keymap()</A>|, with the following notable differences:
                  • replace_keycodes: Defaults to `true` if &quot;<A HREF="eval.html#expr">expr</A>&quot; is `true`.
                  • noremap: Always overridden with the <A HREF="syntax.html#inverse">inverse</A> of &quot;remap&quot;
                    (see below).

                • In addition to those <A HREF="options.html#options">options</A>, the table accepts the
                  following keys:
                  • buffer: (number or <A HREF="options.html#boolean">boolean</A>) Add a <A HREF="map.html#mapping">mapping</A> to the given
                    buffer. When `0` or `true`, use the current buffer.
                  • remap: (boolean) Make the <A HREF="map.html#mapping">mapping</A> recursive. This is the
                    <A HREF="syntax.html#inverse">inverse</A> of the &quot;noremap&quot; option from |<A HREF="api.html#nvim_set_keymap()">nvim_set_keymap()</A>|.
                    Defaults to `false`.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="api.html#nvim_set_keymap()">nvim_set_keymap()</A>|


==============================================================================

<A HREF="#Lua">Lua</A> module: fs                                                        *<A NAME="lua-fs"></A><B>lua-fs</B>*


basename({file})                                           *<A NAME="vim.fs.basename()"></A><B>vim.fs.basename()</B>*
    Return the basename of the given file or directory

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        <A HREF="editing.html#{file}">{file}</A>  (string) File or directory

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) Basename of <A HREF="editing.html#{file}">{file}</A>


dir({path})                                                     *<A NAME="vim.fs.dir()"></A><B>vim.fs.dir()</B>*
    Return an iterator over the files and directories located in {path}

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {path}  (string) An absolute or relative path to the directory to
                iterate over. The path is first normalized
                |<A HREF="#vim.fs.normalize()">vim.fs.normalize()</A>|.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Iterator over files and directories in {path}. Each iteration yields
        two values: name and type. Each &quot;name&quot; is the basename of the file or
        directory relative to {path}. Type is one of &quot;file&quot; or &quot;directory&quot;.


dirname({file})                                             *<A NAME="vim.fs.dirname()"></A><B>vim.fs.dirname()</B>*
    Return the parent directory of the given file or directory

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        <A HREF="editing.html#{file}">{file}</A>  (string) File or directory

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) Parent directory of <A HREF="editing.html#{file}">{file}</A>


find({names}, {opts})                                          *<A NAME="vim.fs.find()"></A><B>vim.fs.find()</B>*
    Find files or directories in the given path.

    Finds any files or directories given in {names} starting from {path}. If
    {upward} is &quot;true&quot; then the search traverses upward through parent
    directories; otherwise, the search traverses downward. Note that downward
    searches are recursive and may search through many directories! If {stop}
    is non-nil, then the search stops when the directory given in {stop} is
    reached. The search terminates when {limit} (default 1) matches are found.
    The search can be narrowed to find only files or or only directories by
    specifying {type} to be &quot;file&quot; or &quot;directory&quot;, respectively.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {names}  (string|table|fun(name: string): <A HREF="options.html#boolean">boolean</A>) Names of the files
                 and directories to find. Must be base names, paths and globs
                 are not supported. If a function <A HREF="motion.html#it">it</A> is called per file and
                 dir within the traversed directories to test if they match.
        {opts}   (table) Optional keyword arguments:
                 • path (string): Path to begin searching from. If omitted,
                   the current working directory is used.
                 • upward (boolean, default false): If true, search upward
                   through parent directories. Otherwise, search through child
                   directories (recursively).
                 • stop (string): Stop searching when this directory is
                   reached. The directory itself is not searched.
                 • type (string): Find only files (&quot;file&quot;) or directories
                   (&quot;directory&quot;). If omitted, both files and directories that
                   match {name} are included.
                 • limit (number, default 1): Stop the search after finding
                   this many matches. Use `math.huge` to place no limit on the
                   number of matches.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (table) The paths of all matching files or directories


normalize({path})                                         *<A NAME="vim.fs.normalize()"></A><B>vim.fs.normalize()</B>*
    Normalize a path to a standard format. A tilde (~) character at the
    beginning of the path is expanded to the user's home directory and any
    <A HREF="intro.html#backslash">backslash</A> (\) characters are converted to forward slashes (/). Environment
    <A HREF="eval.html#variables">variables</A> are also expanded.

    Example:

<B>     vim.fs.normalize('C:\Users\jdoe')</B>
<B>     =&gt; 'C:/Users/jdoe'</B>

<B>     vim.fs.normalize('~/src/neovim')</B>
<B>     =&gt; '/home/jdoe/src/neovim'</B>

<B>     vim.fs.normalize('$XDG_CONFIG_HOME/nvim/init.vim')</B>
<B>     =&gt; '/Users/jdoe/.config/nvim/init.vim'</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {path}  (string) Path to normalize

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (string) Normalized path


parents({start})                                            *<A NAME="vim.fs.parents()"></A><B>vim.fs.parents()</B>*
    Iterate over all the parents of the given file or directory.

    Example:

<B>     local root_dir</B>
<B>     for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do</B>
<B>       if vim.fn.isdirectory(dir .. "/.git") == 1 then</B>
<B>         root_dir = dir</B>
<B>         break</B>
<B>       end</B>
<B>     end</B>

<B>     if root_dir then</B>
<B>       print("Found git repository at", root_dir)</B>
<B>     end</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {start}  (string) Initial file or directory.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (function) Iterator

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
