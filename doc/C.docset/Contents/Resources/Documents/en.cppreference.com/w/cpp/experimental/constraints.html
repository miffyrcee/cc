<html><!-- Online page at https://en.cppreference.com/w/cpp/experimental/constraints --><head><meta charset="utf-8"><title>Constraints and concepts</title><link rel="stylesheet" href="../../css_1.css" type="text/css"><link rel="stylesheet" href="../../css_2.css" type="text/css"><link rel="stylesheet" href="../../css_3.css" type="text/css"><link rel="stylesheet" href="../../css_4.css" type="text/css"><link rel="stylesheet" href="../../css_5.css" type="text/css"><link rel="stylesheet" href="../../css_6.css" type="text/css"><link rel="stylesheet" href="../../css_8.css" type="text/css"><link rel="stylesheet" href="../../css_9.css" type="text/css"><link rel="stylesheet" href="../../css_10.css" type="text/css"><link rel="stylesheet" href="../../css_11.css" type="text/css"><script type="text/javascript" src="../../js_1.js"></script><script type="text/javascript" src="../../js_2.js"></script><script type="text/javascript" src="../../js_1971.js"></script><script type="text/javascript" src="../../js_4.js"></script><script type="text/javascript" src="../../js_5.js"></script><script type="text/javascript" src="../../js_6.js"></script><script type="text/javascript" src="../../js_7.js"></script><script type="text/javascript" src="../../js_8.js"></script><script type="text/javascript" src="../../js_9.js"></script><script type="text/javascript" src="../../js_10.js"></script><script type="text/javascript" src="../../js_11.js"></script><script type="text/javascript" src="../../js_12.js"></script><script type="text/javascript" src="../../js_13.js"></script><script type="text/javascript" src="../../js_14.js"></script><script type="text/javascript" src="../../js_15.js"></script><style>.t-example-live-link {display:none !important} .t-sidebar-body {display:none}\nbody{min-width:0}\ndiv.mw-geshi{width:95%}\ndiv#content {width:auto !important} div#content{background-image:none; margin-left:0px;} .t-lines {background:inherit !important} pre, div.mw-geshi {width: 100% !important} body {background:white !important} div#content {width:100% !important} pre, div.mw-geshi {width:auto !important} .t-example-live-link, #mw-head, #cpp-footer-base {display:none !important} .t-navbar-menu > div {position:relative !important}</style></head><body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_experimental_constraints skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <div id="mw-head" class="noprint">
            <div id="cpp-head-first-base">
                <div id="cpp-head-first">
                    <h5><a href="https://en.cppreference.com/">
                        cppreference.com                        </a></h5>
                    <div id="cpp-head-search">
                        
<!-- 0 -->
<div id="p-search">
<form action="https://duckduckgo.com/" method="get">
  <input type="hidden" name="sites" value="cppreference.com">
  <input type="search" name="q">
  <input type="submit" value="Search">
</form>
</div>

<!-- /0 -->
                    </div>
                    <div id="cpp-head-personal">
                        
<!-- 0 -->
<div id="p-personal" class="">
<span id="pt-createaccount"><a href="https://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&amp;returnto=cpp%2Fexperimental%2Fconstraints&amp;type=signup">Create account</a></span>	<div class="menu">
        <ul>
<li id="pt-login"><a href="https://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&amp;returnto=cpp%2Fexperimental%2Fconstraints" title="You are encouraged to log in; however, it is not mandatory [ctrl-option-o]" accesskey="o">Log in</a></li>        </ul>
    </div>
</div>

<!-- /0 -->
                    </div>

                </div>
            </div>
            <div id="cpp-head-second-base">
                <div id="cpp-head-second">
                    <div id="cpp-head-tools-left">
                        
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="./constraints.html" title="View the content page [ctrl-option-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk" class="new"><span><a href="https://en.cppreference.com/mwiki/index.php?title=Talk:cpp/experimental/constraints&amp;action=edit&amp;redlink=1" title="Discussion about the content page [ctrl-option-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
                    </div>
                    <div id="cpp-head-tools-right">
                        
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="./constraints.html">View</a></span></li>
					<li id="ca-edit"><span><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit" title="You can edit this page. Please use the preview button before saving [ctrl-option-e]" accesskey="e">Edit</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=history" title="Past revisions of this page [ctrl-option-h]" accesskey="h">History</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async="" type="text/javascript" src="../../../../cdn.carbonads.com/carbon.js" id="_carbonads_js"></script>
                <h1 id="firstHeading" class="firstHeading">Constraints and concepts</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../experimental.html" title="cpp/experimental">experimental</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep">&nbsp;</div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tbody><tr class="t-nv"><td colspan="5"> <a href="../compiler_support.html" title="cpp/compiler support"> Compiler support</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../freestanding.html" title="cpp/freestanding"> Freestanding and hosted</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../standard_library.html" title="cpp/standard library"> Standard library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../named_req.html" title="cpp/named req"> Named requirements </a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../feature_test.html" title="cpp/feature test"> Feature test macros </a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#Language_support" title="cpp/utility"> Language support library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concepts.html" title="cpp/concepts"> Concepts library</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../meta.html" title="cpp/meta"> Metaprogramming library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error"> Diagnostics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> General utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../ranges.html" title="cpp/ranges"> Ranges library</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem"> Filesystem library</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Concurrency support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical specifications</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../symbol_index.html" title="cpp/symbol index"> Symbols index</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../links/libs.html" title="cpp/links/libs"> External libraries</a> </td></tr>
</tbody></table></div><div><span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&amp;action=edit">[edit]</a></span></div></div></div></div><div class="t-navbar-sep">&nbsp;</div><div class="t-navbar-head"><a href="../experimental.html" title="cpp/experimental"> Technical specifications</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="">
<tbody><tr class="t-nv"><td colspan="5"> <a href="./fs.html" title="cpp/experimental/fs">Filesystem library</a> <span class="t-mark-rev t-since-fs-ts t-mark-ts">(filesystem TS)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./lib_extensions.html" title="cpp/experimental/lib extensions">Library fundamentals</a> <span class="t-mark-rev t-since-libfund-ts t-mark-ts">(library fundamentals TS)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./lib_extensions_2.html" title="cpp/experimental/lib extensions 2">Library fundamentals 2</a> <span class="t-mark-rev t-since-libfund-ts-2 t-mark-ts">(library fundamentals TS v2)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./lib_extensions_3.html" title="cpp/experimental/lib extensions 3">Library fundamentals 3</a> <span class="t-mark-rev t-since-libfund-ts-3 t-mark-ts">(library fundamentals TS v3)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./parallelism.html" title="cpp/experimental/parallelism">Extensions for parallelism</a> <span class="t-mark-rev t-since-parallelism-ts t-mark-ts">(parallelism TS)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./parallelism_2.html" title="cpp/experimental/parallelism 2">Extensions for parallelism 2</a> <span class="t-mark-rev t-since-parallelism-ts-2 t-mark-ts">(parallelism TS v2)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./concurrency.html" title="cpp/experimental/concurrency">Extensions for concurrency</a> <span class="t-mark-rev t-since-concurrency-ts t-mark-ts">(concurrency TS)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/concurrency_2&amp;action=edit&amp;redlink=1" class="new" title="cpp/experimental/concurrency 2 (page does not exist)">Extensions for concurrency 2</a> <span class="t-mark-rev t-since-concurrency-ts-2 t-mark-ts">(concurrency TS v2)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink">Concepts</strong> <span class="t-mark-rev t-since-concepts-ts t-mark-ts">(concepts TS)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./ranges.html" title="cpp/experimental/ranges">Ranges</a> <span class="t-mark-rev t-since-ranges-ts t-mark-ts">(ranges TS)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./reflect.html" title="cpp/experimental/reflect">Reflection</a> <span class="t-mark-rev t-since-reflection-ts t-mark-ts">(reflection TS)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="./special_functions.html" title="cpp/experimental/special functions">Mathematical special functions</a> <span class="t-mark-rev t-since-special-math-tr t-mark-ts">(special functions TR)</span></td></tr>
</tbody></table></div><div><span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/experimental/navbar_content&amp;action=edit">[edit]</a></span></div></div></div></div><div class="t-navbar-sep">&nbsp;</div></div>
<p><br>
</p>
<table class="plainlinks fmbox fmbox-system noprint" style="font-size: 0.8em">
<tbody><tr>
<td class="mbox-image">
  <img alt="" src="../../../../upload.cppreference.com/mwiki/images/3/31/Imbox_notice.png" width="40" height="40"></td>
<td class="mbox-text" style=""> <b>Experimental Feature</b> The functionality described on this page is part of the Concepts Technical Specification ISO/IEC TS 19217:2015 <span class="t-mark-rev t-since-concepts-ts t-mark-ts">(concepts TS)</span>. For the version of this feature adopted in C++20, see <a href="../language/constraints.html" title="cpp/language/constraints">here</a>. </td>
</tr>
</tbody></table>
<p><span style="font-size:0.7em; line-height:130%">This page describes an experimental core language feature. For named type requirements used in the specification of the standard library, see <a href="../named_req.html" title="cpp/named req">named requirements</a> </span>
</p><p><a href="../language/class_template.html" title="cpp/language/class template">Class templates</a>, <a href="../language/function_template.html" title="cpp/language/function template">function templates</a>, and non-template functions (typically members of class templates) may be associated with a <i>constraint</i>, which specifies the requirements on template arguments, which can be used to select the most appropriate function overloads and template specializations.
</p><p>Constraints may also be used to limit automatic type deduction in variable declarations and function return types to only the types that satisfy specified requirements.
</p><p>Named sets of such requirements are called <i>concepts</i>. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi t-example-code" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;string&gt;</span>
<span class="co2">#include &lt;locale&gt;</span>
<span class="kw1">using</span> <span class="kw1">namespace</span> std<span class="sy4">::</span><span class="me2">literals</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// Declaration of the concept "EqualityComparable", which is satisfied by</span>
<span class="co1">// any type T such that for values a and b of type T,</span>
<span class="co1">// the expression a==b compiles and its result is convertible to bool</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> EqualityComparable <span class="sy1">=</span> requires<span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span>
    <span class="br0">{</span> a <span class="sy1">==</span> b <span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">bool</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span>EqualityComparable<span class="sy3">&amp;&amp;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// declaration of a constrained function template</span>
<span class="co1">// template&lt;typename T&gt;</span>
<span class="co1">// void f(T&amp;&amp;) requires EqualityComparable&lt;T&gt;; // long form of the same</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
  f<span class="br0">(</span><span class="st0">"abc"</span>s<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, std::string is EqualityComparable</span>
  f<span class="br0">(</span><a href="../locale/use_facet.html"><span class="kw1901">std::<span class="me2">use_facet</span></span></a><span class="sy1">&lt;</span><a href="../locale/ctype.html"><span class="kw1942">std::<span class="me2">ctype</span></span></a><span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;&gt;</span><span class="br0">(</span><a href="../locale/locale.html"><span class="kw1898">std::<span class="me2">locale</span></span></a><span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Error: not EqualityComparable </span>
<span class="br0">}</span></pre></div></div>
</div>
<p>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><a href="../container/list.html"><span class="kw1278">std::<span class="me2">list</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> l <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">3</span>,<span class="sy2">-</span><span class="nu0">1</span>,<span class="nu0">10</span><span class="br0">}</span><span class="sy4">;</span>
<a href="../algorithm/sort.html"><span class="kw1622">std::<span class="me2">sort</span></span></a><span class="br0">(</span>l.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, l.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> 
<span class="co1">//Typical compiler diagnostic without concepts:</span>
<span class="co1">//  invalid operands to binary expression ('std::_List_iterator&lt;int&gt;' and</span>
<span class="co1">//  'std::_List_iterator&lt;int&gt;')</span>
<span class="co1">//                           std::__lg(__last - __first) * 2);</span>
<span class="co1">//                                     ~~~~~~ ^ ~~~~~~~</span>
<span class="co1">// ... 50 lines of output ...</span>
<span class="co1">//</span>
<span class="co1">//Typical compiler diagnostic with concepts:</span>
<span class="co1">//  error: cannot call std::sort with std::_List_iterator&lt;int&gt;</span>
<span class="co1">//  note:  concept RandomAccessIterator&lt;std::_List_iterator&lt;int&gt;&gt; was not satisfied</span></pre></div></div>
<p>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics">ISO C++ core guideline T.20</a>, "The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint."
</p><p>If feature testing is supported, the features described here are indicated by the macro constant <span class="t-c"><span class="mw-geshi cpp source-cpp">__cpp_concepts</span></span> with a value equal or greater <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">201507</span></span></span>.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Placeholders"><span class="tocnumber">1</span> <span class="toctext">Placeholders</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Abbreviated_templates"><span class="tocnumber">2</span> <span class="toctext">Abbreviated templates</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Concepts"><span class="tocnumber">3</span> <span class="toctext">Concepts</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Constraints"><span class="tocnumber">4</span> <span class="toctext">Constraints</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Conjunctions"><span class="tocnumber">4.1</span> <span class="toctext">Conjunctions</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Disjunctions"><span class="tocnumber">4.2</span> <span class="toctext">Disjunctions</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Predicate_constraints"><span class="tocnumber">4.3</span> <span class="toctext">Predicate constraints</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Requirements"><span class="tocnumber">5</span> <span class="toctext">Requirements</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Simple_requirements"><span class="tocnumber">5.1</span> <span class="toctext">Simple requirements</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Type_requirements"><span class="tocnumber">5.2</span> <span class="toctext">Type requirements</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Compound_Requirements"><span class="tocnumber">5.3</span> <span class="toctext">Compound Requirements</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Nested_requirements"><span class="tocnumber">5.4</span> <span class="toctext">Nested requirements</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Concept_resolution"><span class="tocnumber">6</span> <span class="toctext">Concept resolution</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Partial_ordering_of_constraints"><span class="tocnumber">7</span> <span class="toctext">Partial ordering of constraints</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Keywords"><span class="tocnumber">8</span> <span class="toctext">Keywords</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Compiler_support"><span class="tocnumber">9</span> <span class="toctext">Compiler support</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=1" title="Edit section: Placeholders">edit</a>]</span> <span class="mw-headline" id="Placeholders">Placeholders</span></h3>
<p>The unconstrained placeholder <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span></span> and <i>constrained placeholders</i> which have the form <span class="t-spar">concept-name</span> <code><b>&lt;</b></code> <span class="t-spar">template-argument-list</span><span class="t-mark">(optional)</span><code><b>&gt;</b></code>, are placeholders for the type that is to be deduced.
</p><p>Placeholders may appear in variable declarations (in which case they are deduced from the initializer) or in function return types (in which case they are deduced from return statements)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><a href="../utility/pair.html"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">auto</span>, <span class="kw4">auto</span><span class="sy1">&gt;</span> p2 <span class="sy1">=</span> <a href="../utility/pair/make_pair.html"><span class="kw1100">std::<span class="me2">make_pair</span></span></a><span class="br0">(</span><span class="nu0">0</span>, <span class="st0">'a'</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// first auto is int,</span>
                                                   <span class="co1">// second auto is char</span>
&nbsp;
Sortable x <span class="sy1">=</span> f<span class="br0">(</span>y<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// the type of x is deduced from the return type of f, </span>
                   <span class="co1">// only compiles if the type satisfies the constraint Sortable</span>
&nbsp;
<span class="kw4">auto</span> f<span class="br0">(</span>Container<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> Sortable<span class="sy4">;</span> <span class="co1">// return type is deduced from the return statement</span>
                               <span class="co1">// only compiles if the type satisfies Sortable</span></pre></div></div>
<p>Placeholders may also appear in parameters, in which case they turn function declarations into template declarations (constrained if the placeholder is constrained)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><a href="../utility/pair.html"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">auto</span>, EqualityComparable<span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// this is a template with two parameters:</span>
       <span class="co1">// unconstrained type parameter and a constrained non-type parameter</span></pre></div></div>
<p>Constrained placeholders may be used anywhere <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">auto</span></span></span> may be used, for example, in generic lambda declarations
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">auto</span> gl <span class="sy1">=</span> <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span>Assignable<span class="sy3">&amp;</span> a, <span class="kw4">auto</span><span class="sy2">*</span> b<span class="br0">)</span> <span class="br0">{</span> a <span class="sy1">=</span> <span class="sy2">*</span>b<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>If constrained type specifier designates a non-type or a template, but is used as a constrained placeholder, the program is ill-formed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span>size_t N<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> Even <span class="sy1">=</span> <span class="br0">(</span>N<span class="sy2">%</span><span class="nu19">2</span> <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw1">struct</span> S1 <span class="br0">{</span> <span class="kw4">int</span> n<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span> Even<span class="sy4">::</span><span class="sy2">*</span> p2 <span class="sy1">=</span> <span class="sy3">&amp;</span>S1<span class="sy4">::</span><span class="me2">n</span><span class="sy4">;</span> <span class="co1">// error, invalid use of a non-type concept</span>
<span class="kw4">void</span> f<span class="br0">(</span><a href="../container/array.html"><span class="kw1271">std::<span class="me2">array</span></span></a><span class="sy1">&lt;</span><span class="kw4">auto</span>, Even<span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error, invalid use of a non-type concept</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>Even N<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span><a href="../container/array.html"><span class="kw1271">std::<span class="me2">array</span></span></a><span class="sy1">&lt;</span><span class="kw4">auto</span>, N<span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=2" title="Edit section: Abbreviated templates">edit</a>]</span> <span class="mw-headline" id="Abbreviated_templates">Abbreviated templates</span></h3>
<p>If one or more placeholders appears in a function parameter list, the function declaration is actually a function template declaration, whose template parameter list includes one invented parameter for every unique placeholder, in order of appearance
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// short form</span>
<span class="kw4">void</span> g1<span class="br0">(</span><span class="kw4">const</span> EqualityComparable<span class="sy2">*</span>, Incrementable<span class="sy3">&amp;</span><span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// long form:</span>
<span class="co1">// template&lt;EqualityComparable T, Incrementable U&gt; void g1(const T*, U&amp;);</span>
<span class="co1">// longer form:</span>
<span class="co1">// template&lt;typename T, typename U&gt;</span>
<span class="co1">// void g1(const T*, U&amp;) requires EqualityComparable&lt;T&gt; &amp;&amp; Incrementable&lt;U&gt;;</span>
&nbsp;
<span class="kw4">void</span> f2<span class="br0">(</span><a href="../container/vector.html"><span class="kw1272">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">auto</span><span class="sy2">*</span><span class="sy1">&gt;</span>...<span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// long form: template&lt;typename... T&gt; void f2(std::vector&lt;T*&gt;...);</span>
&nbsp;
<span class="kw4">void</span> f4<span class="br0">(</span><span class="kw4">auto</span> <span class="br0">(</span>auto<span class="sy4">::</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// long form: template&lt;typename T, typename U, typename V&gt; void f4(T (U::*)(V));</span></pre></div></div>
<p>All placeholders introduced by equivalent constrained type specifiers have the same invented template parameter. However, each unconstrained specifier (<code>auto</code>) always introduces a different template parameter
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f0<span class="br0">(</span>Comparable a, Comparable<span class="sy2">*</span> b<span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// long form: template&lt;Comparable T&gt; void f0(T a, T* b);</span>
&nbsp;
<span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">auto</span> a, <span class="kw4">auto</span><span class="sy2">*</span> b<span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// long form: template&lt;typename T, typename U&gt; f1(T a, U* b);</span></pre></div></div>
<p>Both function templates and class templates can be declared using a <i>template introduction</i>, which has the syntax <span class="t-spar">concept-name</span> <code><b>{</b></code> <span class="t-spar">parameter-list</span><span class="t-mark">(optional)</span><code><b>} </b></code>, in which case the keyword <code>template</code> is not needed: each parameter from the <span class="t-spar">parameter-list</span> of the template introduction becomes a template parameter whose kind (type, non-type, template) is determined by the kind of the corresponding parameter in the named concept.
</p><p>Besides declaring a template, template introduction associates a <i>predicate constraint</i> (see below) that names (for variable concepts) or invokes (for function concepts) the concept named by the introduction.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1">EqualityComparable<span class="br0">{</span>T<span class="br0">}</span> <span class="kw1">class</span> Foo<span class="sy4">;</span>
<span class="co1">// long form: template&lt;EqualityComparable T&gt; class Foo;</span>
<span class="co1">// longer form: template&lt;typename T&gt; requires EqualityComparable&lt;T&gt; class Foo;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T, <span class="kw4">int</span> N, <span class="kw1">typename</span>... <span class="me1">Xs</span><span class="sy1">&gt;</span> concept <span class="kw4">bool</span> Example <span class="sy1">=</span> ...<span class="sy4">;</span>
Example<span class="br0">{</span>A, B, ...<span class="me1">C</span><span class="br0">}</span> <span class="kw1">struct</span> S1<span class="sy4">;</span>
<span class="co1">// long form template&lt;class A, int B, class... C&gt; requires Example&lt;A,B,C...&gt; struct S1;</span></pre></div></div>
<p>For function templates, template introduction can be combined with placeholders:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1">Sortable<span class="br0">{</span>T<span class="br0">}</span> <span class="kw4">void</span> f<span class="br0">(</span>T, <span class="kw4">auto</span><span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// long form: template&lt;Sortable T, typename U&gt; void f(T, U);</span>
<span class="co1">// alternative using only placeholders: void f(Sortable, auto);</span></pre></div></div>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: touch up template declaration pages to link here </td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=3" title="Edit section: Concepts">edit</a>]</span> <span class="mw-headline" id="Concepts">Concepts</span></h3>
<p>A concept is a named set of requirements. The definition of a concept appears at namespace scope and has the form of a <a href="../language/function_template.html" title="cpp/language/function template">function template</a> definition (in which case it is called <i>function concept</i>) or <a href="../language/variable_template.html" title="cpp/language/variable template">variable template</a> definition (in which case it is called <i>variable concept</i>). The only difference is that the keyword <span class="t-c"><span class="mw-geshi cpp source-cpp">concept</span></span> appears in the <span class="t-spar">decl-specifier-seq</span>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// variable concept from the standard library (Ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Derived <span class="sy1">=</span> <a href="../types/is_base_of.html"><span class="kw592">std::<span class="me2">is_base_of</span></span></a><span class="sy1">&lt;</span>U, T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// function concept from the standard library (Ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> EqualityComparable<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> 
    <span class="kw1">return</span> requires<span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span> <span class="br0">{</span>a <span class="sy1">==</span> b<span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> Boolean<span class="sy4">;</span> <span class="br0">{</span>a <span class="sy3">!</span><span class="sy1">=</span> b<span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> Boolean<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>The following restrictions apply to function concepts:
</p>
<ul><li> <code>inline</code> and <code>constexpr</code> are not allowed, the function is automatically <code>inline</code> and <code>constexpr</code>
</li><li> <code>friend</code> and <code>virtual</code> are not allowed
</li><li> exception specification is not allowed, the function is automatically <code>noexcept(true)</code>.
</li><li> cannot be declared and defined later, cannot be redeclared
</li><li> the return type must be <code>bool</code>
</li><li> return type deduction is not allowed
</li><li> parameter list must be empty
</li><li> the function body must consist of only a <code>return</code> statement, whose argument must be a <i>constraint-expression</i> (predicate constraint, conjunction/disjunction of other constraints, or a requires-expression, see below)
</li></ul>
<p>The following restrictions apply to variable concepts:
</p>
<ul><li> Must have the type <code>bool</code>
</li><li> Cannot be declared without an initializer
</li><li> Cannot be declared or at class scope.
</li><li> <code>constexpr</code> is not allowed, the variable is automatically <code>constexpr</code>
</li><li> the initializer must be a constraint expression (predicate constraint, conjunction/disjunction of constraints, or a requires-expression, see below)
</li></ul>
<p>Concepts cannot recursively refer to themselves in the body of the function or in the initializer of the variable:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> F<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> F<span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy4">::</span><span class="me2">type</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// error</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> V <span class="sy1">=</span> V<span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// error</span></pre></div></div>
<p>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed)
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=4" title="Edit section: Constraints">edit</a>]</span> <span class="mw-headline" id="Constraints">Constraints</span></h3>
<p>A constraint is a sequence of logical operations that specifies requirements on template arguments. They can appear within <i>requires-expression</i>s (see below) and directly as bodies of concepts
</p><p>There are 9 types of constraints:
</p>
<div class="t-li1"><span class="t-li">1)</span> conjunctions</div>
<div class="t-li1"><span class="t-li">2)</span> disjunctions</div>
<div class="t-li1"><span class="t-li">3)</span> predicate constraints</div>
<div class="t-li1"><span class="t-li">4)</span> expression constraints (only in a <i>requires-expression</i>)</div>
<div class="t-li1"><span class="t-li">5)</span> type constraints (only in a <i>requires-expression</i>)</div>
<div class="t-li1"><span class="t-li">6)</span> implicit conversion constraints (only in a <i>requires-expression</i>)</div>
<div class="t-li1"><span class="t-li">7)</span> argument deduction constraints (only in a <i>requires-expression</i>)</div>
<div class="t-li1"><span class="t-li">8)</span> exception constraints (only in a <i>requires-expression</i>)</div>
<div class="t-li1"><span class="t-li">9)</span> parametrized constraints (only in a <i>requires-expression</i>)</div>
<p>The first three types of constraints may appear directly as the body of a concept or as an ad-hoc requires-clause: 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
requires <span class="co1">// requires-clause (ad-hoc constraint)</span>
sizeof<span class="br0">(</span>T<span class="br0">)</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> get_value<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="co1">// conjunction of two predicate constraints</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<p>When multiple constraints are attached to the same declaration, the total constraint is a conjunction in the following order: the constraint introduced by <i>template introduction</i>, constraints for each template parameter in order of appearance, the <i>requires</i> clause after the template parameter list, constraints for each function parameter in order of appearance, trailing <i>requires</i> clause:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// the declarations declare the same constrained function template </span>
<span class="co1">// with the constraint Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>Incrementable T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> requires Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> requires Incrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// ok</span>
&nbsp;
<span class="co1">// the following two declarations have different constraints:</span>
<span class="co1">// the first declaration has Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt;</span>
<span class="co1">// the second declaration has Decrementable&lt;T&gt; &amp;&amp; Incrementable&lt;T&gt;</span>
<span class="co1">// Even though they are logically equivalent.</span>
<span class="co1">// The second declaration is ill-formed, no diagnostic required</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Incrementable T<span class="sy1">&gt;</span> requires Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>Decrementable T<span class="sy1">&gt;</span> requires Incrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=5" title="Edit section: Conjunctions">edit</a>]</span> <span class="mw-headline" id="Conjunctions">Conjunctions</span></h4>
<p>Conjunction of constraints <code>P</code> and <code>Q</code> is specified as <span class="t-c"><span class="mw-geshi cpp source-cpp">P <span class="sy3">&amp;&amp;</span> Q</span></span>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// example concepts from the standard library (Ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Integral <span class="sy1">=</span> <a href="../types/is_integral.html"><span class="kw462">std::<span class="me2">is_integral</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> SignedIntegral <span class="sy1">=</span> Integral<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> <a href="../types/is_signed.html"><span class="kw522">std::<span class="me2">is_signed</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> UnsignedIntegral <span class="sy1">=</span> Integral<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> <span class="sy3">!</span>SignedIntegral<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span></pre></div></div>
<p>A conjunction of two constraints is satisfied only if both constraints are satisfied. Conjunctions are evaluated left to right and short-circuited (if the left constraint is not satisfied, template argument substitution into the right constraint is not attempted: this prevents failures due to substitution outside of immediate context). User-defined overloads of <code>operator&amp;&amp;</code> are not allowed in constraint conjunctions.
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=6" title="Edit section: Disjunctions">edit</a>]</span> <span class="mw-headline" id="Disjunctions">Disjunctions</span></h4>
<p>Disjunction of constraints <code>P</code> and <code>Q</code> is specified as <span class="t-c"><span class="mw-geshi cpp source-cpp">P <span class="sy3">||</span> Q</span></span>.
</p><p>A disjunction of two constraints is satisfied if either constraint is satisfied. Disjunctions are evaluated left to right and short-circuited (if the left constraint is satisfied, template argument deduction into the right constraint is not attempted). User-defined overloads of <code>operator||</code> are not allowed in constraint disjunctions.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// example constraint from the standard library (Ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T <span class="sy1">=</span> <span class="kw4">void</span><span class="sy1">&gt;</span>
requires EqualityComparable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">||</span> Same<span class="sy1">&lt;</span>T, <span class="kw4">void</span><span class="sy1">&gt;</span>
<span class="kw1">struct</span> equal_to<span class="sy4">;</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=7" title="Edit section: Predicate constraints">edit</a>]</span> <span class="mw-headline" id="Predicate_constraints">Predicate constraints</span></h4>
<p>A predicate constraint is a constant expression of type <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span></span>. It is satisfied only if it evaluates to <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> Size32 <span class="sy1">=</span> sizeof<span class="br0">(</span>T<span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">4</span><span class="sy4">;</span></pre></div></div>
<p>Predicate constraints can specify requirements on non-type template parameters and on template template arguments.
</p><p>Predicate constraints must evaluate directly to <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span></span>, no conversions allowed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> S <span class="br0">{</span>
    <span class="kw4">constexpr</span> <span class="kw1">explicit</span> operator <span class="kw4">bool</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
requires S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span> <span class="co1">// bad predicate constraint: S&lt;T&gt;{} is not bool</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span>
f<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: constraint never satisfied</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=8" title="Edit section: Requirements">edit</a>]</span> <span class="mw-headline" id="Requirements">Requirements</span></h3>
<p>The keyword <span class="t-c"><span class="mw-geshi cpp source-cpp">requires</span></span> is used in two ways:
</p>
<div class="t-li1"><span class="t-li">1)</span> To introduce a <i>requires-clause</i>, which specifies constraints on template arguments or on a function declaration.
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="sy3">&amp;&amp;</span><span class="br0">)</span> requires Eq<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// can appear as the last element of a function declarator</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> requires Addable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="co1">// or right after a template parameter list</span>
T add<span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a <span class="sy2">+</span> b<span class="sy4">;</span> <span class="br0">}</span></pre></div></div></div>
<div class="t-li1"><span class="t-li"></span> In this case, the keyword <i>requires</i> must be followed by some constant expression (so it's possible to write "requires true;"), but the intent is that a named concept (as in the example above) or a conjunction/disjunction of named concepts or a <i>requires-expression</i> is used.</div>
<div class="t-li1"><span class="t-li">2)</span> To begin a <i>requires-expression</i>, which is a prvalue expression of type <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span></span> that describes the constraints on some template arguments. Such expression is <code>true</code> if the corresponding concept is satisfied, and false otherwise:
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Addable <span class="sy1">=</span> requires <span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span> x <span class="sy2">+</span> x<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// requires-expression</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> requires Addable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="co1">// requires-clause, not requires-expression</span>
T add<span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a <span class="sy2">+</span> b<span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
requires requires <span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span> x <span class="sy2">+</span> x<span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// ad-hoc constraint, note keyword used twice</span>
T add<span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a <span class="sy2">+</span> b<span class="sy4">;</span> <span class="br0">}</span></pre></div></div></div>
<p>The syntax of <i>requires-expession</i> is as follows:
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <code><b>requires</b></code> <code><b>(</b></code> <span class="t-spar">parameter-list</span><span class="t-mark">(optional)</span> <code><b>)</b></code> <code><b>{ </b></code> <span class="t-spar">requirement-seq</span> <code><b>} </b></code>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td>  <span class="t-spar">parameter-list</span>
</td>
<td> -
</td>
<td>  a comma-separated list of parameters like in a function declaration, except that default arguments are not allowed and the last parameter cannot be an ellipsis. These parameters have no storage, linkage or lifetime. These parameters are in scope until the closing <code><b>} </b></code> of the <span class="t-spar">requirement-seq</span>. If no parameters are used, the round parentheses may be omitted as well
</td></tr>
<tr class="t-par">
<td>  <span class="t-spar">requirement-seq</span>
</td>
<td> -
</td>
<td>  whitespace-separated sequence of <i>requirements</i>, described below (each requirement ends with a semicolon). Each requirement adds another constraint to the <i>conjunction</i> of constraints that this requires-expression defines.
</td></tr></tbody></table>
<p>Each requirement in the <span class="t-spar">requirements-seq</span> is one of the following:
</p>
<ul><li> simple requirement
</li><li> type requirements
</li><li> compound requirements
</li><li> nested requirements
</li></ul>
<p>Requirements may refer to the template parameters that are in scope and to the local parameters introduced in the <span class="t-spar">parameter-list</span>. When parametrized, a requires-expression is said to introduce a <i>parametrized constraint</i>
</p><p>The substitution of template arguments into a requires-expression may result in the formation
of invalid types or expressions in its requirements. In such cases,
</p>
<ul><li> If a substitution failure occurs in a requires-expression that is used outside of a <a href="../language/templates.html#Templated_entity" title="cpp/language/templates">templated entity</a> declaration, then the program is ill-formed.
</li><li> If the requires-expression is used in a declaration of a <a href="../language/templates.html#Templated_entity" title="cpp/language/templates">templated entity</a>, the corresponding constraint is treated as "not satisfied" and the <a href="../language/sfinae.html" title="cpp/language/sfinae">substitution failure is not an error</a>, however
</li><li> If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C <span class="sy1">=</span> requires <span class="br0">{</span>
    new <span class="kw4">int</span><span class="br0">[</span><span class="sy2">-</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>sizeof<span class="br0">(</span>T<span class="br0">)</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// invalid for every T: ill-formed, no diagnostic required</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=9" title="Edit section: Simple requirements">edit</a>]</span> <span class="mw-headline" id="Simple_requirements">Simple requirements</span></h4>
<p>A simple requirement is an arbitrary expression statement. The requirement is that the expression is valid (this is an <i>expression constraint</i>). Unlike with predicate constraints, evaluation does not take place, only language correctness is checked.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Addable <span class="sy1">=</span>
requires <span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span>
    a <span class="sy2">+</span> b<span class="sy4">;</span> <span class="co1">// "the expression a+b is a valid expression that will compile"</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// example constraint from the standard library (ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U <span class="sy1">=</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Swappable <span class="sy1">=</span> requires<span class="br0">(</span>T<span class="sy3">&amp;&amp;</span> t, U<span class="sy3">&amp;&amp;</span> u<span class="br0">)</span> <span class="br0">{</span>
    swap<span class="br0">(</span><a href="../utility/forward.html"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span>t<span class="br0">)</span>, <a href="../utility/forward.html"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>U<span class="sy1">&gt;</span><span class="br0">(</span>u<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    swap<span class="br0">(</span><a href="../utility/forward.html"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>U<span class="sy1">&gt;</span><span class="br0">(</span>u<span class="br0">)</span>, <a href="../utility/forward.html"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span>t<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=10" title="Edit section: Type requirements">edit</a>]</span> <span class="mw-headline" id="Type_requirements">Type requirements</span></h4>
<p>A type requirement is the keyword <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">typename</span></span></span> followed by a type name, optionally qualified. The requirement is that the named type exists (a <i>type constraint</i>): this can be used to verify that a certain named nested type exists, or that a class template specialization names a type, or that an alias template names a type.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> <span class="kw1">using</span> Ref <span class="sy1">=</span> T<span class="sy3">&amp;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C <span class="sy1">=</span>
requires <span class="br0">{</span>
    <span class="kw1">typename</span> T<span class="sy4">::</span><span class="me2">inner</span><span class="sy4">;</span> <span class="co1">// required nested member name</span>
    <span class="kw1">typename</span> S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>     <span class="co1">// required class template specialization</span>
    <span class="kw1">typename</span> Ref<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>   <span class="co1">// required alias template substitution</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">//Example concept from the standard library (Ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> <span class="kw1">using</span> CommonType <span class="sy1">=</span> <a href="../types/common_type.html"><span class="kw638">std::<span class="me2">common_type_t</span></span></a><span class="sy1">&lt;</span>T, U<span class="sy1">&gt;</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> Common <span class="sy1">=</span>
requires <span class="br0">(</span>T t, U u<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">typename</span> CommonType<span class="sy1">&lt;</span>T, U<span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// CommonType&lt;T, U&gt; is valid and names a type</span>
    <span class="br0">{</span> CommonType<span class="sy1">&lt;</span>T, U<span class="sy1">&gt;</span><span class="br0">{</span><a href="../utility/forward.html"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span>t<span class="br0">)</span><span class="br0">}</span> <span class="br0">}</span><span class="sy4">;</span> 
    <span class="br0">{</span> CommonType<span class="sy1">&lt;</span>T, U<span class="sy1">&gt;</span><span class="br0">{</span><a href="../utility/forward.html"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>U<span class="sy1">&gt;</span><span class="br0">(</span>u<span class="br0">)</span><span class="br0">}</span> <span class="br0">}</span><span class="sy4">;</span> 
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=11" title="Edit section: Compound Requirements">edit</a>]</span> <span class="mw-headline" id="Compound_Requirements">Compound Requirements</span></h4>
<p>A compound requirement has the form 
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <code><b>{</b></code> <span class="t-spar">expression</span> <code><b>} </b></code> <code><b>noexcept</b></code><span class="t-mark">(optional)</span> <span class="t-spar">trailing-return-type</span><span class="t-mark">(optional)</span> <code><b>;</b></code>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<p>and specifies a conjunction of the following constraints:
</p>
<div class="t-li1"><span class="t-li">1)</span> <span class="t-spar">expression</span> is a valid expression (<i>expression constraint</i>)</div>
<div class="t-li1"><span class="t-li">2)</span> If <code>noexcept</code> is used, expression must also be noexcept (<i>exception constraint</i>)</div>
<div class="t-li1"><span class="t-li">3)</span> If <span class="t-spar">trailing-return-type</span> that names a type that uses placeholders, the type must be deducible from the type of the expression (<i>argument deduction constraint</i>)</div>
<div class="t-li1"><span class="t-li">4)</span> If <span class="t-spar">trailing-return-type</span> that names a type that does not use placeholders, then two more constraints are added:</div>
<div class="t-li2"><span class="t-li">4a)</span> the type named by <span class="t-spar">trailing-return-type</span> is valid (<i>type constraint</i>)</div>
<div class="t-li2"><span class="t-li">4b)</span> the result of the expression is <a href="../language/implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">implicitly convertible</a> to that type (<i>implicit conversion constraint</i>)</div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C2 <span class="sy1">=</span>
requires<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span>
    <span class="br0">{</span><span class="sy2">*</span>x<span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw1">typename</span> T<span class="sy4">::</span><span class="me2">inner</span><span class="sy4">;</span> <span class="co1">// the expression *x must be valid</span>
                               <span class="co1">// AND the type T::inner must be valid</span>
                               <span class="co1">// AND the result of *x must be convertible to T::inner</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// Example concept from the standard library (Ranges TS)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> Same <span class="sy1">=</span> <a href="../types/is_same.html"><span class="kw590">std::<span class="me2">is_same</span></span></a><span class="sy1">&lt;</span>T,U<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> B<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> Boolean <span class="sy1">=</span>
requires<span class="br0">(</span>B b1, B b2<span class="br0">)</span> <span class="br0">{</span>
    <span class="br0">{</span> <span class="kw4">bool</span><span class="br0">(</span>b1<span class="br0">)</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// direct initialization constraint has to use expression</span>
    <span class="br0">{</span> <span class="sy3">!</span>b1 <span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <span class="kw4">bool</span><span class="sy4">;</span> <span class="co1">// compound constraint</span>
    requires Same<span class="sy1">&lt;</span>decltype<span class="br0">(</span>b1 <span class="sy3">&amp;&amp;</span> b2<span class="br0">)</span>, <span class="kw4">bool</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// nested constraint, see below</span>
    requires Same<span class="sy1">&lt;</span>decltype<span class="br0">(</span>b1 <span class="sy3">||</span> b2<span class="br0">)</span>, <span class="kw4">bool</span><span class="sy1">&gt;</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=12" title="Edit section: Nested requirements">edit</a>]</span> <span class="mw-headline" id="Nested_requirements">Nested requirements</span></h4>
<p>A nested requirement is another <i>requires-clause</i>, terminated with a semicolon. This is used to introduce <i>predicate constraints</i> (see above) expressed in terms of other named concepts applied to the local parameters (outside a requires clause, predicate constraints can't use parameters, and placing an expression directly in a requires clause makes it an expression constraint which means it is not evaluated)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// example constraint from Ranges TS</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Semiregular <span class="sy1">=</span> DefaultConstructible<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
    CopyConstructible<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Destructible<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> CopyAssignable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
requires<span class="br0">(</span>T a, size_t n<span class="br0">)</span> <span class="br0">{</span>  
    requires Same<span class="sy1">&lt;</span>T<span class="sy2">*</span>, decltype<span class="br0">(</span><span class="sy3">&amp;</span>a<span class="br0">)</span><span class="sy1">&gt;</span><span class="sy4">;</span>  <span class="co1">// nested: "Same&lt;...&gt; evaluates to true"</span>
    <span class="br0">{</span> a.~T<span class="br0">(</span><span class="br0">)</span> <span class="br0">}</span> <span class="kw1">noexcept</span><span class="sy4">;</span>  <span class="co1">// compound: "a.~T()" is a valid expression that doesn't throw</span>
    requires Same<span class="sy1">&lt;</span>T<span class="sy2">*</span>, decltype<span class="br0">(</span>new T<span class="br0">)</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// nested: "Same&lt;...&gt; evaluates to true"</span>
    requires Same<span class="sy1">&lt;</span>T<span class="sy2">*</span>, decltype<span class="br0">(</span>new T<span class="br0">[</span>n<span class="br0">]</span><span class="br0">)</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// nested</span>
    <span class="br0">{</span> delete new T <span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// compound</span>
    <span class="br0">{</span> delete new T<span class="br0">[</span>n<span class="br0">]</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// compound</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=13" title="Edit section: Concept resolution">edit</a>]</span> <span class="mw-headline" id="Concept_resolution">Concept resolution</span></h3>
<p>Like any other function template, a function concept (but not variable concept) can be overloaded: multiple concept definitions may be provided that all use the same <span class="t-spar">concept-name</span>.
</p><p>Concept resolution is performed when a <span class="t-spar">concept-name</span> (which may be qualified) appears in 
</p>
<div class="t-li1"><span class="t-li">1)</span> a constrained type specifier <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span> f<span class="br0">(</span>Concept<span class="br0">)</span><span class="sy4">;</span> <a href="../container/vector.html"><span class="kw1272">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span>Concept<span class="sy1">&gt;</span> x <span class="sy1">=</span> ...<span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">2)</span> a constrained parameter <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span>Concept T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">3)</span> a template introduction <span class="t-c"><span class="mw-geshi cpp source-cpp">Concept<span class="br0">{</span>T<span class="br0">}</span> <span class="kw1">struct</span> X<span class="sy4">;</span></span></span></div>
<div class="t-li1"><span class="t-li">4)</span> a <i>constraint-expression</i> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> requires Concept<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span></span></span></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T, <span class="kw1">typename</span> U<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #2</span>
<span class="kw4">void</span> f<span class="br0">(</span>C<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// the set of concepts referred to by C includes both #1 and #2;</span>
           <span class="co1">// concept resolution (see below) selects #1.</span></pre></div></div>
<p>In order to perform concept resolution, <i>template parameters</i> of each concept that matches the name (and the qualification, if any) is matched against a sequence of <i>concept arguments</i>, which are template arguments and <i>wildcards</i>. A wildcard can match a template parameter of any kind (type, non-type, template). The argument set is constructed differently, depending on the context
</p>
<div class="t-li1"><span class="t-li">1)</span> For a concept name used as part of a constrained type specifier or parameter, if the concept name is used without a parameter list, the argument list is a single wildcard.
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C1<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T, <span class="kw1">typename</span> U<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C1<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #2</span>
<span class="kw4">void</span> f1<span class="br0">(</span><span class="kw4">const</span> C1<span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// &lt;wildcard&gt; matches &lt;T&gt;, selects #1</span></pre></div></div></div>
<div class="t-li1"><span class="t-li">2)</span> For a concept name used as part of a constrained type specifier or parameter, if the concept name is used with a template argument list, the argument list is a single wildcard followed by that argument list.
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C1<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T, <span class="kw1">typename</span> U<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C1<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #2</span>
<span class="kw4">void</span> f2<span class="br0">(</span>C1<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// &lt;wildcard, char&gt; matches &lt;T, U&gt;, selects #2</span></pre></div></div></div>
<div class="t-li1"><span class="t-li">3)</span> If a concept appears in a template introduction, the argument list is a sequence of placeholders as long as the list of parameters in the template introduction
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span>... <span class="me1">Ts</span><span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> C3 <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
C3<span class="br0">{</span>T<span class="br0">}</span> <span class="kw4">void</span> q2<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// OK: &lt;T&gt; matches &lt;...Ts&gt;</span>
C3<span class="br0">{</span>...<span class="me1">Ts</span><span class="br0">}</span> <span class="kw4">void</span> q1<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: &lt;...Ts&gt; matches &lt;...Ts&gt;</span></pre></div></div></div>
<div class="t-li1"><span class="t-li">4)</span> If a concept appears as the name of a template-id, the concept argument list is exactly the sequence of arguments of that template-id
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T, <span class="kw1">typename</span> U<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// #2</span>
&nbsp;
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> requires C<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// matches #1</span></pre></div></div></div>
<p>Concept resolution is performed by matching each argument against the corresponding parameter of each visible concept. Default template arguments (if used) are instantiated for each paramter that doesn't correspond to an argument, and are then appended to the argument list. Template parameter matches an argument only if it has the same kind (type, non-type, template), unless the argument is a wildcard. A parameter pack matches zero or more arguments as long as all arguments match the pattern in kind (unless they are wildcards).
</p><p>If any argument does not match its corresponding parameter or if there are more arguments than parameters and the last parameter is not a pack, the concept is not viable. If there is zero or more than one viable concept, the program is ill-formed.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C2<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> T<span class="sy1">&gt;</span> concept <span class="kw4">bool</span> C2<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>C2<span class="sy1">&lt;</span><span class="nu0">0</span><span class="sy1">&gt;</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> S1<span class="sy4">;</span> <span class="co1">// error: &lt;wildcard, 0&gt; matches </span>
                             <span class="co1">// neither &lt;typename T&gt; nor &lt;int T&gt;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>C2 T<span class="sy1">&gt;</span> <span class="kw1">struct</span> S2<span class="sy4">;</span> <span class="co1">// both #1 and #2 match: error</span></pre></div></div>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: needs an example with meaningful concepts, not these 'return true' placeholders </td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=14" title="Edit section: Partial ordering of constraints">edit</a>]</span> <span class="mw-headline" id="Partial_ordering_of_constraints">Partial ordering of constraints</span></h3>
<p>Before any further analysis, constraints are <i>normalized</i> by substituting the body of every name concept and every requires expression until what is left is a sequence of conjunctions and disjunctions on atomic constraints, which are predicate constraints, expression constraints, type constraints, implicit conversion constraints, argument deduction constraints, and exception constraints.
</p><p>Concept <code>P</code> is said to <i>subsume</i> concept <code>Q</code> if it can be proven that <code>P</code> <a href="https://en.wikipedia.org/wiki/Logical_consequence" class="extiw" title="enwiki:Logical consequence">implies</a> <code>Q</code> without analyzing types and expressions for equivalence (so <code>N &gt;= 0</code> does not subsume <code>N &gt; 0</code>)
</p><p>Specifically, first <code>P</code> is converted to disjunctive normal form and <code>Q</code> is converted to conjunctive normal form, and they are compared as follows:
</p>
<ul><li> each atomic constraint <code>A</code> subsumes equivalent atomic constraint <code>A</code>
</li><li> each atomic constraint <code>A</code> subsumes a disjunction <code>A||B</code> and does not subsume a conjunction <code>A&amp;&amp;B</code>
</li><li> each conjunction <code>A&amp;&amp;B</code> subsumes <code>A</code>, but a disjunction <code>A||B</code> does not subsume <code>A</code>
</li></ul>
<p>Subsumption relationship defines partial order of constraints, which is used to determine:
</p>
<ul><li> the best viable candidate for a non-template function in <a href="../language/overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>
</li><li> the <a href="../language/overloaded_address.html" title="cpp/language/overloaded address">address of a non-template function</a> in an overload set
</li><li> the best match for a template template argument
</li><li> partial ordering of class template specializations
</li><li> <a href="../language/function_template.html#Function_template_overloading" title="cpp/language/function template">partial ordering</a> of function templates
</li></ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: backlinks from the above to here </td></tr></tbody></table>
<p>If declarations <code>D1</code> and <code>D2</code> are constrained and D1's normalized constraints subsume D2's normalized constraints (or if D1 is constrained and D2 is unconstrained), then D1 is said to be <i>at least as constrained</i> as D2. If D1 is at least as constrained as D2 and D2 is not at least as constrained as D1, then D1 is <i>more constrained</i> than D2.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> Decrementable <span class="sy1">=</span> requires<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="sy2">--</span>t<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept <span class="kw4">bool</span> RevIterator <span class="sy1">=</span> Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> requires<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="sy2">*</span>t<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// RevIterator subsumes Decrementable, but not the other way around</span>
<span class="co1">// RevIterator is more constrained as Decrementable</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span>Decrementable<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #1</span>
<span class="kw4">void</span> f<span class="br0">(</span>RevIterator<span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// #2</span>
&nbsp;
f<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>       <span class="co1">// int only satisfies Decrementable, selects #1</span>
f<span class="br0">(</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// int* satisfies both constraints, selects #2 as more constrained</span>
&nbsp;
<span class="kw4">void</span> g<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span><span class="sy4">;</span>          <span class="co1">// #3 (unconstrained)</span>
<span class="kw4">void</span> g<span class="br0">(</span>Decrementable<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #4</span>
&nbsp;
g<span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// bool does not satisfy Decrementable, selects #3</span>
g<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// int satisfies Decrementable, selects #4 because it is more constrained</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=15" title="Edit section: Keywords">edit</a>]</span> <span class="mw-headline" id="Keywords">Keywords</span></h3>
<p><a href="../keyword/concept.html" title="cpp/keyword/concept"><tt>concept</tt></a>,
<a href="../keyword/requires.html" title="cpp/keyword/requires"><tt>requires</tt></a>
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=edit&amp;section=16" title="Edit section: Compiler support">edit</a>]</span> <span class="mw-headline" id="Compiler_support">Compiler support</span></h3>
<p>GCC &gt;= 6.1 supports this technical specification (required option <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">-</span>fconcepts</span></span>)
</p>
<!-- 
NewPP limit report
Preprocessor visited node count: 3247/1000000
Preprocessor generated node count: 9261/1000000
Post‐expand include size: 54570/2097152 bytes
Template argument size: 21296/2097152 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:17698-0!*!0!!en!2!* and timestamp 20220801140833 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;oldid=129405">https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;oldid=129405</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://en.cppreference.com/w/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://en.cppreference.com/mwiki/index.php?title=Category:Noindexed_pages&amp;action=edit&amp;redlink=1" class="new" title="Category:Noindexed pages (page does not exist)">Noindexed pages</a></li><li><a href="https://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>Navigation</h5>
            <ul>
<li id="n-Support-us"><a href="http://www.cppreference.com/support" rel="nofollow">Support us</a></li><li id="n-recentchanges"><a href="https://en.cppreference.com/w/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-FAQ"><a href="https://en.cppreference.com/w/Cppreference:FAQ">FAQ</a></li><li id="n-Offline-version"><a href="https://en.cppreference.com/w/Cppreference:Archives">Offline version</a></li>            </ul>
        </div>
                        <div id="cpp-toolbox">
            <h5><span>Toolbox</span><a href="#"></a></h5>
            <ul>
<li id="t-whatlinkshere"><a href="https://en.cppreference.com/w/Special:WhatLinksHere/cpp/experimental/constraints" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="https://en.cppreference.com/w/Special:RecentChangesLinked/cpp/experimental/constraints" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-upload"><a href="http://upload.cppreference.com/w/Special:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a href="https://en.cppreference.com/w/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;oldid=129405" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/experimental/constraints&amp;action=info">Page information</a></li>            </ul>
        </div>
                        <div id="cpp-languages">
            <div><ul><li>In other languages</li></ul></div>
            <div><ul>
<li class="interwiki-de"><a href="http://de.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="de" hreflang="de">Deutsch</a></li><li class="interwiki-es"><a href="http://es.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="es" hreflang="es">Español</a></li><li class="interwiki-fr"><a href="http://fr.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="fr" hreflang="fr">Français</a></li><li class="interwiki-it"><a href="http://it.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="it" hreflang="it">Italiano</a></li><li class="interwiki-ja"><a href="http://ja.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="ja" hreflang="ja">日本語</a></li><li class="interwiki-pt"><a href="http://pt.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="pt" hreflang="pt">Português</a></li><li class="interwiki-ru"><a href="http://ru.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="ru" hreflang="ru">Русский</a></li><li class="interwiki-zh"><a href="http://zh.cppreference.com/w/cpp/experimental/constraints" title="cpp/experimental/constraints" lang="zh" hreflang="zh">中文</a></li>            </ul></div>
        </div>
            <ul id="footer-info">
                                    <li id="footer-info-lastmod"> This page was last modified on 5 June 2021, at 14:03.</li>
                                    <li id="footer-info-viewcount">This page has been accessed 69,230 times.</li>
                            </ul>
                    <ul id="footer-places">
                                    <li id="footer-places-privacy"><a href="https://en.cppreference.com/w/Cppreference:Privacy_policy" title="Cppreference:Privacy policy">Privacy policy</a></li>
                                    <li id="footer-places-about"><a href="https://en.cppreference.com/w/Cppreference:About" title="Cppreference:About">About cppreference.com</a></li>
                                    <li id="footer-places-disclaimer"><a href="https://en.cppreference.com/w/Cppreference:General_disclaimer" title="Cppreference:General disclaimer">Disclaimers</a></li>
                            </ul>
                                    <ul id="footer-icons" class="noprint">
                                    <li id="footer-poweredbyico">
                                            <a href="https://www.mediawiki.org/"><img src="../../../mwiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31"></a>                                            <a href="http://qbnz.com/highlighter/"><img src="../../../../upload.cppreference.com/mwiki/images/2/2b/powered_by_geshi_88x31.png" alt="Powered by GeSHi" height="31" width="88"></a>                                            <a href="http://www.tigertech.net/referral/cppreference.com"><img src="../../../../upload.cppreference.com/mwiki/images/9/94/powered_by_tigertech_88x31.png" alt="Hosted by Tiger Technologies" height="31" width="88"></a>                                        </li>
                                </ul>
                        <div style="clear:both">
            </div>
            </div>
        </div>
        <!-- /footer -->
        



<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 5.664 secs. -->
	
<!-- Cached 20220801140833 -->

</body></html>