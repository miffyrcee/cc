<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Nvim documentation: eval</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Nvim documentation: eval</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="eval.txt"></A><B>eval.txt</B>*	Nvim


		  VIM REFERENCE MANUAL	  by Bram Moolenaar



Expression evaluation			*<A NAME="expression"></A><B>expression</B>* *<A NAME="expr"></A><B>expr</B>* *<A NAME="E15"></A><B>E15</B>* *<A NAME="eval"></A><B>eval</B>*

Using expressions is introduced in chapter 41 of the user manual |<A HREF="usr_41.html">usr_41.txt</A>|.

				      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

1. Variables						*<A NAME="variables"></A><B>variables</B>*

<B><FONT COLOR="PURPLE">1.1 Variable types </FONT></B>

						*<A NAME="E712"></A><B>E712</B>* *<A NAME="E896"></A><B>E896</B>* *<A NAME="E897"></A><B>E897</B>* *<A NAME="E899"></A><B>E899</B>*
There are seven types of <A HREF="#variables">variables</A>:


							*<A NAME="Number"></A><B>Number</B>* *<A NAME="Integer"></A><B>Integer</B>*
<A HREF="#Number">Number</A>		A 32 or 64 bit signed number.  |<A HREF="#expr-number">expr-number</A>|
		The number of bits is available in |<A HREF="#v:numbersize">v:numbersize</A>|.
		Examples:  -123  0x10  0177  0o177  0b1011


<A HREF="#Float">Float</A>		A floating point number. |<A HREF="#floating-point-format">floating-point-format</A>| *<A NAME="Float"></A><B>Float</B>*
		Examples: 123.456  1.15e-6  -1.1e3

<A HREF="#String">String</A>		A NUL terminated <A HREF="#string">string</A> of 8-bit unsigned characters (bytes).
		|<A HREF="#expr-string">expr-string</A>| Examples: &quot;ab\txx\&quot;--&quot;  'x-z''a,c'

Funcref		A reference to a function |<A HREF="#Funcref">Funcref</A>|.
		Example: function(&quot;strlen&quot;)
		It can be bound to a dictionary and arguments, <A HREF="motion.html#it">it</A> then works
		like a <A HREF="#Partial">Partial</A>.
		Example: function(&quot;Callback&quot;, [arg], myDict)

List		An ordered sequence of items, see |<A HREF="#List">List</A>| for details.
		Example: [1, 2, ['a', 'b']]

<A HREF="#Dictionary">Dictionary</A>	An associative, unordered array: Each entry has a key and a
		value. |<A HREF="#Dictionary">Dictionary</A>|
		Examples:
			{&quot;blue&quot;: &quot;#0000ff&quot;, &quot;red&quot;: &quot;#ff0000&quot;}
			#{blue: &quot;#0000ff&quot;, red: &quot;#ff0000&quot;}

Blob		Binary Large Object. Stores any sequence of bytes.  See |<A HREF="#Blob">Blob</A>|
		for details.
		Example: 0zFF00ED015DAF
		0z is an empty <A HREF="#Blob">Blob</A>.

The <A HREF="#Number">Number</A> and <A HREF="#String">String</A> types are converted automatically, depending on how they
are used.

Conversion from a <A HREF="#Number">Number</A> to a <A HREF="#String">String</A> is by making the ASCII representation of
the <A HREF="#Number">Number</A>.  Examples:
<B><FONT COLOR="PURPLE">	Number 123	--&gt;	String "123" </FONT></B>
<B><FONT COLOR="PURPLE">	Number 0	--&gt;	String "0" </FONT></B>
<B><FONT COLOR="PURPLE">	Number -1	--&gt;	String "-1" </FONT></B>

							*<A NAME="octal"></A><B>octal</B>*
Conversion from a <A HREF="#String">String</A> to a <A HREF="#Number">Number</A> is done by converting the first digits to
a number.  Hexadecimal &quot;0xf9&quot;, Octal &quot;017&quot; or &quot;0o17&quot;, and Binary &quot;0b10&quot;
numbers are recognized.  If the <A HREF="#String">String</A> doesn't start with digits, the result
is zero. Examples:
<B><FONT COLOR="PURPLE">	String "456"	--&gt;	Number 456 </FONT></B>
<B><FONT COLOR="PURPLE">	String "6bar"	--&gt;	Number 6 </FONT></B>
<B><FONT COLOR="PURPLE">	String "foo"	--&gt;	Number 0 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0xf1"	--&gt;	Number 241 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0100"	--&gt;	Number 64 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0o100"	--&gt;	Number 64 </FONT></B>
<B><FONT COLOR="PURPLE">	String "0b101"	--&gt;	Number 5 </FONT></B>
<B><FONT COLOR="PURPLE">	String "-8"	--&gt;	Number -8 </FONT></B>
<B><FONT COLOR="PURPLE">	String "+8"	--&gt;	Number 0 </FONT></B>

To force conversion from <A HREF="#String">String</A> to <A HREF="#Number">Number</A>, add zero to <A HREF="motion.html#it">it</A>:
<B>	:echo "0100" + 0</B>
<B><FONT COLOR="PURPLE"> 	64 </FONT></B>

To avoid a leading zero to cause <A HREF="#octal">octal</A> conversion, or for using a different
base, use |<A HREF="builtin.html#str2nr()">str2nr()</A>|.


						*<A NAME="TRUE"></A><B>TRUE</B>* *<A NAME="FALSE"></A><B>FALSE</B>* *<A NAME="Boolean"></A><B>Boolean</B>*
For <A HREF="options.html#boolean">boolean</A> operators Numbers are used.  Zero is <A HREF="#FALSE">FALSE</A>, non-zero is <A HREF="#TRUE">TRUE</A>.
You can also use |<A HREF="#v:false">v:false</A>| and |<A HREF="#v:true">v:true</A>|.
When <A HREF="#TRUE">TRUE</A> is returned from a function <A HREF="motion.html#it">it</A> is the <A HREF="#Number">Number</A> one, <A HREF="#FALSE">FALSE</A> is the
number zero.

Note that in the command:
<B>	:if "foo"</B>
<B>	:" NOT executed</B>
&quot;foo&quot; is converted to 0, which means <A HREF="#FALSE">FALSE</A>.  If the <A HREF="#string">string</A> starts with a
non-zero number <A HREF="motion.html#it">it</A> means <A HREF="#TRUE">TRUE</A>:
<B>	:if "8foo"</B>
<B>	:" executed</B>
To test for a non-empty <A HREF="#string">string</A>, use <A HREF="builtin.html#empty()">empty()</A>:
<B>	:if !empty("foo")</B>
 

							*<A NAME="non-zero-arg"></A><B>non-zero-arg</B>*
Function arguments often behave slightly different from |TRUE|: If the
argument is present and <A HREF="motion.html#it">it</A> evaluates to a non-zero <A HREF="#Number">Number</A>, |<A HREF="#v:true">v:true</A>| or a
non-empty <A HREF="#String">String</A>, then the value is considered to be <A HREF="#TRUE">TRUE</A>.
Note that &quot; &quot; and &quot;<A HREF="motion.html#0">0</A>&quot; are also non-empty strings, thus considered to be <A HREF="#TRUE">TRUE</A>.
A <A HREF="#List">List</A>, <A HREF="#Dictionary">Dictionary</A> or <A HREF="#Float">Float</A> is not a <A HREF="#Number">Number</A> or <A HREF="#String">String</A>, thus evaluate to <A HREF="#FALSE">FALSE</A>.


				*<A NAME="E745"></A><B>E745</B>* *<A NAME="E728"></A><B>E728</B>* *<A NAME="E703"></A><B>E703</B>* *<A NAME="E729"></A><B>E729</B>* *<A NAME="E730"></A><B>E730</B>* *<A NAME="E731"></A><B>E731</B>*

				*<A NAME="E974"></A><B>E974</B>* *<A NAME="E975"></A><B>E975</B>* *<A NAME="E976"></A><B>E976</B>*
|<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>|, |<A HREF="#Funcref">Funcref</A>|, and |<A HREF="#Blob">Blob</A>| types are not automatically
converted.


							*<A NAME="E805"></A><B>E805</B>* *<A NAME="E806"></A><B>E806</B>* *<A NAME="E808"></A><B>E808</B>*
When mixing <A HREF="#Number">Number</A> and <A HREF="#Float">Float</A> the <A HREF="#Number">Number</A> is converted to <A HREF="#Float">Float</A>.  Otherwise
there is no automatic conversion of <A HREF="#Float">Float</A>.  You can use <A HREF="builtin.html#str2float()">str2float()</A> for <A HREF="#String">String</A>
to <A HREF="#Float">Float</A>, <A HREF="builtin.html#printf()">printf()</A> for <A HREF="#Float">Float</A> to <A HREF="#String">String</A> and <A HREF="builtin.html#float2nr()">float2nr()</A> for <A HREF="#Float">Float</A> to <A HREF="#Number">Number</A>.


					*<A NAME="E362"></A><B>E362</B>* *<A NAME="E891"></A><B>E891</B>* *<A NAME="E892"></A><B>E892</B>* *<A NAME="E893"></A><B>E893</B>* *<A NAME="E894"></A><B>E894</B>* *<A NAME="E907"></A><B>E907</B>*
When expecting a <A HREF="#Float">Float</A> a <A HREF="#Number">Number</A> can also be used, but nothing else.


					*<A NAME="no-type-checking"></A><B>no-type-checking</B>*
You will not get an error if you try to change the type of a variable.


<B><FONT COLOR="PURPLE">1.2 Function references </FONT></B>

							*<A NAME="Funcref"></A><B>Funcref</B>* *<A NAME="E695"></A><B>E695</B>* *<A NAME="E718"></A><B>E718</B>*
A <A HREF="#Funcref">Funcref</A> variable is obtained with the |<A HREF="builtin.html#function()">function()</A>| function, the |<A HREF="builtin.html#funcref()">funcref()</A>|
function or created with the lambda <A HREF="#expression">expression</A> |<A HREF="#expr-lambda">expr-lambda</A>|.  It can be used
in an <A HREF="#expression">expression</A> in the place of a function name, before the parenthesis
around the arguments, to invoke the function <A HREF="motion.html#it">it</A> refers to.  Example:

<B>	:let Fn = function("MyFunc")</B>
<B>	:echo Fn()</B>

 							*<A NAME="E704"></A><B>E704</B>* *<A NAME="E705"></A><B>E705</B>* *<A NAME="E707"></A><B>E707</B>*
A <A HREF="#Funcref">Funcref</A> variable must start with a capital, &quot;s:&quot;, &quot;<A HREF="#w:">w:</A>&quot;, &quot;<A HREF="#t:">t:</A>&quot; or &quot;<A HREF="#b:">b:</A>&quot;.  You
can use &quot;<A HREF="#g:">g:</A>&quot; but the following name must still start with a capital.  You
cannot have both a <A HREF="#Funcref">Funcref</A> variable and a function with the same name.

A special <A HREF="change.html#case">case</A> is defining a function and directly assigning its <A HREF="#Funcref">Funcref</A> to a
<A HREF="#Dictionary">Dictionary</A> entry.  Example:
<B>	:function dict.init() dict</B>
<B>	:   let self.val = 0</B>
<B>	:endfunction</B>

The key of the <A HREF="#Dictionary">Dictionary</A> can start with a lower <A HREF="change.html#case">case</A> <A HREF="print.html#letter">letter</A>.  The actual
function name is not used here.  Also see |<A HREF="#numbered-function">numbered-function</A>|.

A <A HREF="#Funcref">Funcref</A> can also be used with the |<A HREF="userfunc.html#:call">:call</A>| command:
<B>	:call Fn()</B>
<B>	:call dict.init()</B>

The name of the referenced function can be obtained with |<A HREF="builtin.html#string()">string()</A>|.
<B>	:let func = string(Fn)</B>

You can use |<A HREF="builtin.html#call()">call()</A>| to invoke a <A HREF="#Funcref">Funcref</A> and use a <A HREF="#list">list</A> variable for the
arguments:
<B>	:let r = call(Fn, mylist)</B>
 

								*<A NAME="Partial"></A><B>Partial</B>*
A <A HREF="#Funcref">Funcref</A> optionally binds a <A HREF="#Dictionary">Dictionary</A> and/or arguments.  This is also called
a <A HREF="#Partial">Partial</A>.  This is created by passing the <A HREF="#Dictionary">Dictionary</A> and/or arguments to
<A HREF="builtin.html#function()">function()</A> or <A HREF="builtin.html#funcref()">funcref()</A>.  When calling the function the <A HREF="#Dictionary">Dictionary</A> and/or
arguments will be passed to the function.  Example:

<B>	let Cb = function('Callback', ['foo'], myDict)</B>
<B>	call Cb('bar')</B>

This will invoke the function <A HREF="motion.html#as">as</A> if using:
<B>	call myDict.Callback('foo', 'bar')</B>

Note that binding a function to a <A HREF="#Dictionary">Dictionary</A> also happens when the function is
a member of the <A HREF="#Dictionary">Dictionary</A>:

<B>	let myDict.myFunction = MyFunction</B>
<B>	call myDict.myFunction()</B>

Here MyFunction() will get myDict passed <A HREF="motion.html#as">as</A> &quot;<A HREF="#self">self</A>&quot;.  This happens when the
&quot;myFunction&quot; member is accessed.  When assigning &quot;myFunction&quot; to otherDict
and calling <A HREF="motion.html#it">it</A>, <A HREF="motion.html#it">it</A> will be bound to otherDict:

<B>	let otherDict.myFunction = myDict.myFunction</B>
<B>	call otherDict.myFunction()</B>

Now &quot;<A HREF="#self">self</A>&quot; will be &quot;otherDict&quot;.  But when the dictionary was bound explicitly
this won't happen:

<B>	let myDict.myFunction = function(MyFunction, myDict)</B>
<B>	let otherDict.myFunction = myDict.myFunction</B>
<B>	call otherDict.myFunction()</B>

Here &quot;<A HREF="#self">self</A>&quot; will be &quot;myDict&quot;, because <A HREF="motion.html#it">it</A> was bound explicitly.


<B><FONT COLOR="PURPLE">1.3 Lists </FONT></B>

						*<A NAME="list"></A><B>list</B>* *<A NAME="List"></A><B>List</B>* *<A NAME="Lists"></A><B>Lists</B>* *<A NAME="E686"></A><B>E686</B>*
A <A HREF="#List">List</A> is an ordered sequence of items.  An item can be of any type.  Items
can be accessed by their index number.  Items can be added and removed at any
position in the sequence.


<B><FONT COLOR="PURPLE">List creation </FONT></B>

							*<A NAME="E696"></A><B>E696</B>* *<A NAME="E697"></A><B>E697</B>*
A <A HREF="#List">List</A> is created with a comma-separated <A HREF="#list">list</A> of items in square brackets.
Examples:
<B>	:let mylist = [1, two, 3, "four"]</B>
<B>	:let emptylist = []</B>

An item can be any <A HREF="#expression">expression</A>.  Using a <A HREF="#List">List</A> for an item creates a
<A HREF="#List">List</A> of <A HREF="#Lists">Lists</A>:
<B>	:let nestlist = [[11, 12], [21, 22], [31, 32]]</B>

An extra comma after the last item is ignored.


<B><FONT COLOR="PURPLE">List index </FONT></B>

							*<A NAME="list-index"></A><B>list-index</B>* *<A NAME="E684"></A><B>E684</B>*
An item in the <A HREF="#List">List</A> can be accessed by putting the index in square brackets
after the <A HREF="#List">List</A>.  Indexes are zero-based, thus the first item has index zero.
<B>	:let item = mylist[0]		" get the first item: 1</B>
<B>	:let item = mylist[2]		" get the third item: 3</B>

When the resulting item is a <A HREF="#list">list</A> this can be repeated:
<B>	:let item = nestlist[0][1]	" get the first list, second item: 12</B>
 
A negative index is counted from the end.  Index -1 refers to the last item in
the <A HREF="#List">List</A>, -2 to the last but one item, etc.
<B>	:let last = mylist[-1]		" get the last item: "four"</B>

To avoid an error for an invalid index use the |<A HREF="builtin.html#get()">get()</A>| function.  When an item
is not available <A HREF="motion.html#it">it</A> returns zero or the default value you specify:
<B>	:echo get(mylist, idx)</B>
<B>	:echo get(mylist, idx, "NONE")</B>


<B><FONT COLOR="PURPLE">List concatenation </FONT></B>

Two lists can be concatenated with the &quot;<A HREF="motion.html#+">+</A>&quot; <A HREF="motion.html#operator">operator</A>:
<B>	:let longlist = mylist + [5, 6]</B>
<B>	:let mylist += [7, 8]</B>

To prepend or append an item turn the item into a <A HREF="#list">list</A> by putting <A HREF="motion.html#[]">[]</A> around
<A HREF="motion.html#it">it</A>.  To change a list in-place see |<A HREF="#list-modification">list-modification</A>| below.


<B><FONT COLOR="PURPLE">Sublist </FONT></B>

							*<A NAME="sublist"></A><B>sublist</B>*
A part of the <A HREF="#List">List</A> can be obtained by specifying the first and last index,
separated by a colon in square brackets:
<B>	:let shortlist = mylist[2:-1]	" get List [3, "four"]</B>

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1.
<B>	:let endlist = mylist[2:]	" from item 2 to the end: [3, "four"]</B>
<B>	:let shortlist = mylist[2:2]	" List with one item: [3]</B>
<B>	:let otherlist = mylist[:]	" make a copy of the List</B>

If the first index is beyond the last item of the <A HREF="#List">List</A> or the second item is
before the first item, the result is an empty <A HREF="#list">list</A>.  There is no error
message.

If the second index is equal to or greater than the length of the <A HREF="#list">list</A> the
length minus one is used:
<B>	:let mylist = [0, 1, 2, 3]</B>
<B>	:echo mylist[2:8]		" result: [2, 3]</B>

NOTE: mylist[s:e] means using the variable &quot;s:e&quot; <A HREF="motion.html#as">as</A> index.  Watch out for
using a single <A HREF="print.html#letter">letter</A> variable before the &quot;<A HREF="cmdline.html#:">:</A>&quot;.  <A HREF="insert.html#Insert">Insert</A> a space when needed:
mylist[s : e].


<B><FONT COLOR="PURPLE">List identity </FONT></B>

							*<A NAME="list-identity"></A><B>list-identity</B>*
When variable &quot;aa&quot; is a <A HREF="#list">list</A> and you assign <A HREF="motion.html#it">it</A> to another variable &quot;bb&quot;, both
<A HREF="#variables">variables</A> refer to the same <A HREF="#list">list</A>.  Thus <A HREF="change.html#changing">changing</A> the <A HREF="#list">list</A> &quot;aa&quot; will also
change &quot;bb&quot;:
<B>	:let aa = [1, 2, 3]</B>
<B>	:let bb = aa</B>
<B>	:call add(aa, 4)</B>
<B>	:echo bb</B>
 	[1, 2, 3, 4]

Making a copy of a <A HREF="#list">list</A> is done with the |<A HREF="builtin.html#copy()">copy()</A>| function.  Using [:] also
works, <A HREF="motion.html#as">as</A> explained above.  This creates a shallow copy of the <A HREF="#list">list</A>: Changing
a <A HREF="#list">list</A> item in the <A HREF="#list">list</A> will also change the item in the copied <A HREF="#list">list</A>:
<B>	:let aa = [[1, 'a'], 2, 3]</B>
<B>	:let bb = copy(aa)</B>
<B>	:call add(aa, 4)</B>
<B>	:let aa[0][1] = 'aaa'</B>
<B>	:echo aa</B>
 	[[1, aaa], 2, 3, 4]
<B>	:echo bb</B>
 	[[1, aaa], 2, 3]

To make a completely independent <A HREF="#list">list</A> use |<A HREF="builtin.html#deepcopy()">deepcopy()</A>|.  This also makes a
copy of the values in the <A HREF="#list">list</A>, recursively.  Up to a hundred levels deep.

The <A HREF="motion.html#operator">operator</A> &quot;is&quot; can be used to check if two <A HREF="#variables">variables</A> refer to the same
<A HREF="#List">List</A>.  &quot;isnot&quot; does the opposite.  In contrast &quot;<A HREF="change.html#==">==</A>&quot; compares if two lists have
the same value.
<B>	:let alist = [1, 2, 3]</B>
<B>	:let blist = [1, 2, 3]</B>
<B>	:echo alist is blist</B>
 	0
<B>	:echo alist == blist</B>
 	1

Note about comparing lists: Two lists are considered equal if they have the
same length and all items compare equal, <A HREF="motion.html#as">as</A> with using &quot;<A HREF="change.html#==">==</A>&quot;.  There is one
exception: When comparing a number with a <A HREF="#string">string</A> they are considered
different.  There is no automatic type conversion, <A HREF="motion.html#as">as</A> with using &quot;<A HREF="change.html#==">==</A>&quot; on
<A HREF="#variables">variables</A>.  Example:
<B>	echo 4 == "4"</B>
 	1
<B>	echo [4] == ["4"]</B>
 	0

Thus comparing <A HREF="#Lists">Lists</A> is more strict than comparing numbers and strings.  You
can compare simple values this way too by putting them in a <A HREF="#list">list</A>:

<B>	:let a = 5</B>
<B>	:let b = "5"</B>
<B>	:echo a == b</B>
 	1
<B>	:echo [a] == [b]</B>
 	0


<B><FONT COLOR="PURPLE">List unpack </FONT></B>

To unpack the items in a <A HREF="#list">list</A> to individual <A HREF="#variables">variables</A>, put the <A HREF="#variables">variables</A> in
square brackets, like <A HREF="#list">list</A> items:
<B>	:let [var1, var2] = mylist</B>

When the number of <A HREF="#variables">variables</A> does not match the number of items in the <A HREF="#list">list</A>
this produces an error.  To handle any extra items from the <A HREF="#list">list</A> append &quot;<A HREF="motion.html#;">;</A>&quot;
and a variable name:
<B>	:let [var1, var2; rest] = mylist</B>

This works like:
<B>	:let var1 = mylist[0]</B>
<B>	:let var2 = mylist[1]</B>
<B>	:let rest = mylist[2:]</B>

Except that there is no error if there are only two items.  &quot;rest&quot; will be an
empty <A HREF="#list">list</A> then.


<B><FONT COLOR="PURPLE">List modification </FONT></B>

							*<A NAME="list-modification"></A><B>list-modification</B>*
To change a specific item of a <A HREF="#list">list</A> use |<A HREF="#:let">:let</A>| this way:
<B>	:let list[4] = "four"</B>
<B>	:let listlist[0][3] = item</B>

To change part of a <A HREF="#list">list</A> you can specify the first and last item to be
modified.  The value must at least have the number of items in the range:
<B>	:let list[3:5] = [3, 4, 5]</B>

Adding and removing items from a <A HREF="#list">list</A> is done with <A HREF="#functions">functions</A>.  Here are a few
examples:
<B>	:call insert(list, 'a')		" prepend item 'a'</B>
<B>	:call insert(list, 'a', 3)	" insert item 'a' before list[3]</B>
<B>	:call add(list, "new")		" append String item</B>
<B>	:call add(list, [1, 2])		" append a List as one new item</B>
<B>	:call extend(list, [1, 2])	" extend the list with two more items</B>
<B>	:let i = remove(list, 3)	" remove item 3</B>
<B>	:unlet list[3]			" idem</B>
<B>	:let l = remove(list, 3, -1)	" remove items 3 to last item</B>
<B>	:unlet list[3 : ]		" idem</B>
<B>	:call filter(list, 'v:val !~ "x"')  " remove items with an 'x'</B>

Changing the order of items in a <A HREF="#list">list</A>:
<B>	:call sort(list)		" sort a list alphabetically</B>
<B>	:call reverse(list)		" reverse the order of items</B>
<B>	:call uniq(sort(list))		" sort and remove duplicates</B>


<B><FONT COLOR="PURPLE">For loop </FONT></B>

The |<A HREF="#:for">:for</A>| loop executes commands for each item in a |<A HREF="#List">List</A>|, |<A HREF="#String">String</A>| or |<A HREF="#Blob">Blob</A>|.
A variable is set to each item in sequence.  Example with a <A HREF="#List">List</A>:
<B>	:for item in mylist</B>
<B>	:   call Doit(item)</B>
<B>	:endfor</B>

This works like:
<B>	:let index = 0</B>
<B>	:while index &lt; len(mylist)</B>
<B>	:   let item = mylist[index]</B>
<B>	:   :call Doit(item)</B>
<B>	:   let index = index + 1</B>
<B>	:endwhile</B>

If all you want to <A HREF="diff.html#do">do</A> is modify each item in the <A HREF="#list">list</A> then the |<A HREF="builtin.html#map()">map()</A>|
function will be a simpler <A HREF="#method">method</A> than a for loop.

Just like the |<A HREF="#:let">:let</A>| command, |<A HREF="#:for">:for</A>| also accepts a <A HREF="#list">list</A> of <A HREF="#variables">variables</A>.  This
requires the argument to be a <A HREF="#List">List</A> of <A HREF="#Lists">Lists</A>.
<B>	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]</B>
<B>	:   call Doit(lnum, col)</B>
<B>	:endfor</B>

This works like a |<A HREF="#:let">:let</A>| command is done for each <A HREF="#list">list</A> item.  Again, the types
must remain the same to avoid an error.

It is also possible to put remaining items in a <A HREF="#List">List</A> variable:
<B>	:for [i, j; rest] in listlist</B>
<B>	:   call Doit(i, j)</B>
<B>	:   if !empty(rest)</B>
<B>	:      echo "remainder: " .. string(rest)</B>
<B>	:   endif</B>
<B>	:endfor</B>

For a <A HREF="#Blob">Blob</A> one byte at a time is used.

For a <A HREF="#String">String</A> one character, including any composing characters, is used <A HREF="motion.html#as">as</A> a
<A HREF="#String">String</A>.  Example:
<B>	for c in text</B>
<B>	  echo 'This character is ' .. c</B>
<B>	endfor</B>


<B><FONT COLOR="PURPLE">List functions </FONT></B>

						*<A NAME="E714"></A><B>E714</B>*
Functions that are useful with a <A HREF="#List">List</A>:
<B>	:let r = call(funcname, list)	" call a function with an argument list</B>
<B>	:if empty(list)			" check if list is empty</B>
<B>	:let l = len(list)		" number of items in list</B>
<B>	:let big = max(list)		" maximum value in list</B>
<B>	:let small = min(list)		" minimum value in list</B>
<B>	:let xs = count(list, 'x')	" count nr of times 'x' appears in list</B>
<B>	:let i = index(list, 'x')	" index of first 'x' in list</B>
<B>	:let lines = getline(1, 10)	" get ten text lines from buffer</B>
<B>	:call append('$', lines)	" append text lines in buffer</B>
<B>	:let list = split("a b c")	" create list from items in a string</B>
<B>	:let string = join(list, ', ')	" create string from list items</B>
<B>	:let s = string(list)		" String representation of list</B>
<B>	:call map(list, '"&gt;&gt; " .. v:val')  " prepend "&gt;&gt; " to each item</B>

Don't forget that a combination of features can make things simple.  For
example, to add up all the numbers in a <A HREF="#list">list</A>:
<B>	:exe 'let sum = ' .. join(nrlist, '+')</B>


<B><FONT COLOR="PURPLE">1.4 Dictionaries </FONT></B>

				 *<A NAME="Dict"></A><B>Dict</B>* *<A NAME="dict"></A><B>dict</B>* *<A NAME="Dictionaries"></A><B>Dictionaries</B>* *<A NAME="Dictionary"></A><B>Dictionary</B>*
A <A HREF="#Dictionary">Dictionary</A> is an associative array: Each entry has a key and a value.  The
entry can be located with the key.  The entries are stored without a specific
ordering.


<B><FONT COLOR="PURPLE">Dictionary creation </FONT></B>

						*<A NAME="E720"></A><B>E720</B>* *<A NAME="E721"></A><B>E721</B>* *<A NAME="E722"></A><B>E722</B>* *<A NAME="E723"></A><B>E723</B>*
A <A HREF="#Dictionary">Dictionary</A> is created with a comma-separated <A HREF="#list">list</A> of entries in curly
braces.  Each entry has a key and a value, separated by a colon.  Each key can
only appear once.  Examples:
<B>	:let mydict = {1: 'one', 2: 'two', 3: 'three'}</B>
<B>	:let emptydict = {}</B>

 							*<A NAME="E713"></A><B>E713</B>* *<A NAME="E716"></A><B>E716</B>* *<A NAME="E717"></A><B>E717</B>*
A key is always a <A HREF="#String">String</A>.  You can use a <A HREF="#Number">Number</A>, <A HREF="motion.html#it">it</A> will be converted to a
<A HREF="#String">String</A> automatically.  Thus the <A HREF="#String">String</A> '4' and the number 4 will find the same
entry.  Note that the <A HREF="#String">String</A> '04' and the <A HREF="#Number">Number</A> 04 are different, since the
<A HREF="#Number">Number</A> will be converted to the <A HREF="#String">String</A> '4', leading zeros are dropped.  The
empty <A HREF="#string">string</A> can also be used <A HREF="motion.html#as">as</A> a key.

						*<A NAME="literal-Dict"></A><B>literal-Dict</B>* *<A NAME="#{}"></A><B>#{}</B>*
To avoid having to put quotes around every key the <A HREF="##{}">#{}</A> form can be used.  This
does require the key to consist only of ASCII letters, digits, '<A HREF="motion.html#-">-</A>' and '<A HREF="motion.html#_">_</A>'.
Example:
<B>	:let mydict = #{zero: 0, one_key: 1, two-key: 2, 333: 3}</B>
Note that 333 here is the <A HREF="#string">string</A> &quot;333&quot;.  Empty keys are not possible with <A HREF="##{}">#{}</A>.

A value can be any <A HREF="#expression">expression</A>.  Using a <A HREF="#Dictionary">Dictionary</A> for a value creates a
nested <A HREF="#Dictionary">Dictionary</A>:
<B>	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}</B>

An extra comma after the last entry is ignored.


<B><FONT COLOR="PURPLE">Accessing entries </FONT></B>

The normal way to access an entry is by putting the key in square brackets:
<B>	:let val = mydict["one"]</B>
<B>	:let mydict["four"] = 4</B>

You can add new entries to an existing <A HREF="#Dictionary">Dictionary</A> this way, unlike <A HREF="#Lists">Lists</A>.

For keys that consist entirely of letters, digits and underscore the following
form can be used YXXYexpr-entry|:
<B>	:let val = mydict.one</B>
<B>	:let mydict.four = 4</B>

Since an entry can be any type, also a <A HREF="#List">List</A> and a <A HREF="#Dictionary">Dictionary</A>, the indexing and
key lookup can be repeated:
<B>	:echo dict.key[idx].key</B>


<B><FONT COLOR="PURPLE">Dictionary to List conversion </FONT></B>

You may want to loop over the entries in a dictionary.  For this you need to
turn the <A HREF="#Dictionary">Dictionary</A> into a <A HREF="#List">List</A> and pass <A HREF="motion.html#it">it</A> to |<A HREF="#:for">:for</A>|.

Most often you want to loop over the keys, using the |<A HREF="builtin.html#keys()">keys()</A>| function:
<B>	:for key in keys(mydict)</B>
<B>	:   echo key .. ': ' .. mydict[key]</B>
<B>	:endfor</B>

The <A HREF="#List">List</A> of keys is unsorted.  You may want to sort them first:
<B>	:for key in sort(keys(mydict))</B>

To loop over the values use the |<A HREF="builtin.html#values()">values()</A>| function: 
<B>	:for v in values(mydict)</B>
<B>	:   echo "value: " .. v</B>
<B>	:endfor</B>

If you want both the key and the value use the |<A HREF="builtin.html#items()">items()</A>| function.  It returns
a <A HREF="#List">List</A> in which each item is a <A HREF="#List">List</A> with two items, the key and the value:
<B>	:for [key, value] in items(mydict)</B>
<B>	:   echo key .. ': ' .. value</B>
<B>	:endfor</B>


<B><FONT COLOR="PURPLE">Dictionary identity </FONT></B>

							*<A NAME="dict-identity"></A><B>dict-identity</B>*
Just like <A HREF="#Lists">Lists</A> you need to use |<A HREF="builtin.html#copy()">copy()</A>| and |<A HREF="builtin.html#deepcopy()">deepcopy()</A>| to make a copy of a
<A HREF="#Dictionary">Dictionary</A>.  Otherwise, assignment results in referring to the same
<A HREF="#Dictionary">Dictionary</A>:
<B>	:let onedict = {'a': 1, 'b': 2}</B>
<B>	:let adict = onedict</B>
<B>	:let adict['a'] = 11</B>
<B>	:echo onedict['a']</B>
<B>	11</B>

Two <A HREF="#Dictionaries">Dictionaries</A> compare equal if all the key-value pairs compare equal.  For
more info see |<A HREF="#list-identity">list-identity</A>|.


<B><FONT COLOR="PURPLE">Dictionary modification </FONT></B>

							*<A NAME="dict-modification"></A><B>dict-modification</B>*
To change an already existing entry of a <A HREF="#Dictionary">Dictionary</A>, or to add a new entry,
use |<A HREF="#:let">:let</A>| this way:
<B>	:let dict[4] = "four"</B>
<B>	:let dict['one'] = item</B>

Removing an entry from a <A HREF="#Dictionary">Dictionary</A> is done with |<A HREF="builtin.html#remove()">remove()</A>| or |<A HREF="#:unlet">:unlet</A>|.
Three ways to remove the entry with key &quot;aaa&quot; from <A HREF="#dict">dict</A>:
<B>	:let i = remove(dict, 'aaa')</B>
<B>	:unlet dict.aaa</B>
<B>	:unlet dict['aaa']</B>

Merging a <A HREF="#Dictionary">Dictionary</A> with another is done with YXXYextend()|:
<B>	:call extend(adict, bdict)</B>
This extends adict with all entries from bdict.  Duplicate keys cause entries
in adict to be overwritten.  An optional third argument can change this.
Note that the order of entries in a <A HREF="#Dictionary">Dictionary</A> is irrelevant, thus don't
expect &quot;<A HREF="#:echo">:echo</A> adict&quot; to show the items from bdict after the older entries in
adict.

Weeding out entries from a <A HREF="#Dictionary">Dictionary</A> can be done with YXXYfilter()|:
<B>	:call filter(dict, 'v:val =~ "x"')</B>
This removes all entries from &quot;<A HREF="#dict">dict</A>&quot; with a value not matching '<A HREF="change.html#x">x</A>'.
This can also be used to remove all entries:
<B>	call filter(dict, 0)</B>


<B><FONT COLOR="PURPLE">Dictionary function </FONT></B>

				*<A NAME="Dictionary-function"></A><B>Dictionary-function</B>* *<A NAME="self"></A><B>self</B>* *<A NAME="E725"></A><B>E725</B>* *<A NAME="E862"></A><B>E862</B>*
When a function is defined with the &quot;<A HREF="#dict">dict</A>&quot; attribute <A HREF="motion.html#it">it</A> can be used in a
special way with a dictionary.  Example:
<B>	:function Mylen() dict</B>
<B>	:   return len(self.data)</B>
<B>	:endfunction</B>
<B>	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}</B>
<B>	:echo mydict.len()</B>

This is like a <A HREF="#method">method</A> in object oriented programming.  The entry in the
<A HREF="#Dictionary">Dictionary</A> is a |<A HREF="#Funcref">Funcref</A>|.  The local variable &quot;<A HREF="#self">self</A>&quot; refers to the dictionary
the function was invoked from.

It is also possible to add a function without the &quot;<A HREF="#dict">dict</A>&quot; attribute <A HREF="motion.html#as">as</A> a
<A HREF="#Funcref">Funcref</A> to a <A HREF="#Dictionary">Dictionary</A>, but the &quot;<A HREF="#self">self</A>&quot; variable is not available then.


				*<A NAME="numbered-function"></A><B>numbered-function</B>* *<A NAME="anonymous-function"></A><B>anonymous-function</B>*
To avoid the extra name for the function <A HREF="motion.html#it">it</A> can be defined and directly
assigned to a <A HREF="#Dictionary">Dictionary</A> in this way:
<B>	:let mydict = {'data': [0, 1, 2, 3]}</B>
<B>	:function mydict.len()</B>
<B>	:   return len(self.data)</B>
<B>	:endfunction</B>
<B>	:echo mydict.len()</B>

The function will then get a number and the value of dict.len is a |<A HREF="#Funcref">Funcref</A>|
that references this function.  The function can only be used through a
|<A HREF="#Funcref">Funcref</A>|.  It will automatically be deleted when there is no |<A HREF="#Funcref">Funcref</A>|
remaining that refers to <A HREF="motion.html#it">it</A>.

It is not necessary to use the &quot;<A HREF="#dict">dict</A>&quot; attribute for a numbered function.

If you get an error for a numbered function, you can find out what <A HREF="motion.html#it">it</A> is with
a trick.  Assuming the function is <A HREF="usr_42.html#42">42</A>, the command is:
<B>	:function g:42</B>


<B><FONT COLOR="PURPLE">Functions for Dictionaries </FONT></B>

							*<A NAME="E715"></A><B>E715</B>*
Functions that can be used with a <A HREF="#Dictionary">Dictionary</A>:
<B>	:if has_key(dict, 'foo')	" TRUE if dict has entry with key "foo"</B>
<B>	:if empty(dict)			" TRUE if dict is empty</B>
<B>	:let l = len(dict)		" number of items in dict</B>
<B>	:let big = max(dict)		" maximum value in dict</B>
<B>	:let small = min(dict)		" minimum value in dict</B>
<B>	:let xs = count(dict, 'x')	" count nr of times 'x' appears in dict</B>
<B>	:let s = string(dict)		" String representation of dict</B>
<B>	:call map(dict, '"&gt;&gt; " .. v:val')  " prepend "&gt;&gt; " to each item</B>


<B><FONT COLOR="PURPLE">1.5 Blobs </FONT></B>

						*<A NAME="blob"></A><B>blob</B>* *<A NAME="Blob"></A><B>Blob</B>* *<A NAME="Blobs"></A><B>Blobs</B>* *<A NAME="E978"></A><B>E978</B>*
A <A HREF="#Blob">Blob</A> is a binary object.  It can be used to read an image from a file and
send <A HREF="motion.html#it">it</A> over a <A HREF="channel.html#channel">channel</A>, for example.

A <A HREF="#Blob">Blob</A> mostly behaves like a |<A HREF="#List">List</A>| of numbers, where each number has the
value of an 8-bit byte, from 0 to 255.


<B><FONT COLOR="PURPLE">Blob creation </FONT></B>

A <A HREF="#Blob">Blob</A> can be created with a YXXYblob-literal|:
<B>	:let b = 0zFF00ED015DAF</B>
Dots can be inserted between bytes (pair of hex characters) for readability,
they don't change the value:
<B>	:let b = 0zFF00.ED01.5DAF</B>

A <A HREF="#blob">blob</A> can be read from a file with |<A HREF="builtin.html#readfile()">readfile()</A>| passing the {type} argument
set to &quot;<A HREF="motion.html#B">B</A>&quot;, for example:
<B>	:let b = readfile('image.png', 'B')</B>


<B><FONT COLOR="PURPLE">Blob index </FONT></B>

							*<A NAME="blob-index"></A><B>blob-index</B>* *<A NAME="E979"></A><B>E979</B>*
A byte in the <A HREF="#Blob">Blob</A> can be accessed by putting the index in square brackets
after the <A HREF="#Blob">Blob</A>.  Indexes are zero-based, thus the first byte has index zero.
<B>	:let myblob = 0z00112233</B>
<B>	:let byte = myblob[0]		" get the first byte: 0x00</B>
<B>	:let byte = myblob[2]		" get the third byte: 0x22</B>

A negative index is counted from the end.  Index -1 refers to the last byte in
the <A HREF="#Blob">Blob</A>, -2 to the last but one byte, etc.
<B>	:let last = myblob[-1]		" get the last byte: 0x33</B>

To avoid an error for an invalid index use the |<A HREF="builtin.html#get()">get()</A>| function.  When an item
is not available <A HREF="motion.html#it">it</A> returns -1 or the default value you specify:
<B>	:echo get(myblob, idx)</B>
<B>	:echo get(myblob, idx, 999)</B>


<B><FONT COLOR="PURPLE">Blob iteration </FONT></B>

The |<A HREF="#:for">:for</A>| loop executes commands for each byte of a <A HREF="#Blob">Blob</A>.  The loop variable is
set to each byte in the <A HREF="#Blob">Blob</A>.  Example:
<B>	:for byte in 0z112233</B>
<B>	:   call Doit(byte)</B>
<B>	:endfor</B>
This calls Doit() with 0x11, 0x22 and 0x33.


<B><FONT COLOR="PURPLE">Blob concatenation </FONT></B>

Two blobs can be concatenated with the &quot;<A HREF="motion.html#+">+</A>&quot; <A HREF="motion.html#operator">operator</A>:
<B>	:let longblob = myblob + 0z4455</B>
<B>	:let myblob += 0z6677</B>

To change a blob in-place see |<A HREF="#blob-modification">blob-modification</A>| below.


<B><FONT COLOR="PURPLE">Part of a blob </FONT></B>

A part of the <A HREF="#Blob">Blob</A> can be obtained by specifying the first and last index,
separated by a colon in square brackets:
<B>	:let myblob = 0z00112233</B>
<B>	:let shortblob = myblob[1:2]	" get 0z1122</B>
<B>	:let shortblob = myblob[2:-1]	" get 0z2233</B>

Omitting the first index is similar to zero.  Omitting the last index is
similar to -1.
<B>	:let endblob = myblob[2:]	" from item 2 to the end: 0z2233</B>
<B>	:let shortblob = myblob[2:2]	" Blob with one byte: 0z22</B>
<B>	:let otherblob = myblob[:]	" make a copy of the Blob</B>

If the first index is beyond the last byte of the <A HREF="#Blob">Blob</A> or the second index is
before the first index, the result is an empty <A HREF="#Blob">Blob</A>.  There is no error
message.

If the second index is equal to or greater than the length of the <A HREF="#Blob">Blob</A> the
length minus one is used:
<B>	:echo myblob[2:8]		" result: 0z2233</B>


<B><FONT COLOR="PURPLE">Blob modification </FONT></B>

							*<A NAME="blob-modification"></A><B>blob-modification</B>*
To change a specific byte of a <A HREF="#blob">blob</A> use |<A HREF="#:let">:let</A>| this way:
<B>	:let blob[4] = 0x44</B>

When the index is just one beyond the end of the <A HREF="#Blob">Blob</A>, <A HREF="motion.html#it">it</A> is appended. Any
higher index is an error.

To change a sequence of bytes the [:] <A HREF="intro.html#notation">notation</A> can be used:
<B>	let blob[1:3] = 0z445566</B>
The length of the replaced bytes must be exactly the same <A HREF="motion.html#as">as</A> the value

provided. *<A NAME="E972"></A><B>E972</B>*

To change part of a <A HREF="#blob">blob</A> you can specify the first and last byte to be
modified.  The value must have the same number of bytes in the range:
<B>	:let blob[3:5] = 0z334455</B>

You can also use the <A HREF="#functions">functions</A> |<A HREF="builtin.html#add()">add()</A>|, |<A HREF="builtin.html#remove()">remove()</A>| and |<A HREF="builtin.html#insert()">insert()</A>|.


<B><FONT COLOR="PURPLE">Blob identity </FONT></B>

<A HREF="#Blobs">Blobs</A> can be compared for equality:
<B>	if blob == 0z001122</B>
And for equal identity:
<B>	if blob is otherblob</B>

 							*<A NAME="blob-identity"></A><B>blob-identity</B>* *<A NAME="E977"></A><B>E977</B>*
When variable &quot;aa&quot; is a <A HREF="#Blob">Blob</A> and you assign <A HREF="motion.html#it">it</A> to another variable &quot;bb&quot;, both
<A HREF="#variables">variables</A> refer to the same <A HREF="#Blob">Blob</A>.  Then the &quot;is&quot; <A HREF="motion.html#operator">operator</A> returns true.

When making a copy using [:] or |<A HREF="builtin.html#copy()">copy()</A>| the values are the same, but the
identity is different:
<B>	:let blob = 0z112233</B>
<B>	:let blob2 = blob</B>
<B>	:echo blob == blob2</B>
 	1
<B>	:echo blob is blob2</B>
 	1
<B>	:let blob3 = blob[:]</B>
<B>	:echo blob == blob3</B>
 	1
<B>	:echo blob is blob3</B>
 	0

Making a copy of a <A HREF="#Blob">Blob</A> is done with the |<A HREF="builtin.html#copy()">copy()</A>| function.  Using [:] also
works, <A HREF="motion.html#as">as</A> explained above.


<B><FONT COLOR="PURPLE">1.6 More about variables </FONT></B>

							*<A NAME="more-variables"></A><B>more-variables</B>*
If you need to know the type of a variable or <A HREF="#expression">expression</A>, use the |<A HREF="builtin.html#type()">type()</A>|
function.

When the '<A HREF="change.html#!">!</A>' flag is included in the <A HREF="options.html#'shada'">'shada'</A> option, global <A HREF="#variables">variables</A> that
start with an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A>, and don't contain a <A HREF="change.html#lowercase">lowercase</A> <A HREF="print.html#letter">letter</A>, are
stored in the shada file |<A HREF="starting.html#shada-file">shada-file</A>|.

When the <A HREF="options.html#'sessionoptions'">'sessionoptions'</A> option contains &quot;global&quot;, global <A HREF="#variables">variables</A> that
start with an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A> and contain at least one <A HREF="change.html#lowercase">lowercase</A> <A HREF="print.html#letter">letter</A> are
stored in the session file |<A HREF="starting.html#session-file">session-file</A>|.

<B><FONT COLOR="PURPLE">variable name		can be stored where </FONT></B>
my_var_6		not
My_Var_6		session file
MY_VAR_6		<A HREF="starting.html#shada">shada</A> file


It's possible to form a variable name with curly braces, see
|<A HREF="#curly-braces-names">curly-braces-names</A>|.

==============================================================================

2. Expression <A HREF="syntax.html#syntax">syntax</A>					*<A NAME="expression-syntax"></A><B>expression-syntax</B>*

Expression <A HREF="syntax.html#syntax">syntax</A> summary, from least to most significant:

|<A HREF="#expr1">expr1</A>|	<A HREF="#expr2">expr2</A>
	<A HREF="#expr2">expr2</A> ? <A HREF="#expr1">expr1</A> : <A HREF="#expr1">expr1</A>	if-then-else

|<A HREF="#expr2">expr2</A>|	<A HREF="#expr3">expr3</A>
	<A HREF="#expr3">expr3</A> &#124;&#124; <A HREF="#expr3">expr3</A> <A HREF="userfunc.html#...">...</A>	logical OR

|<A HREF="#expr3">expr3</A>|	<A HREF="#expr4">expr4</A>
	<A HREF="#expr4">expr4</A> &amp;&amp; <A HREF="#expr4">expr4</A> <A HREF="userfunc.html#...">...</A>	logical AND

|<A HREF="#expr4">expr4</A>|	<A HREF="#expr5">expr5</A>
	<A HREF="#expr5">expr5</A> <A HREF="change.html#==">==</A> <A HREF="#expr5">expr5</A>		equal
	<A HREF="#expr5">expr5</A> != <A HREF="#expr5">expr5</A>		not equal
	<A HREF="#expr5">expr5</A> <A HREF="change.html#&gt;">&gt;</A>	 <A HREF="#expr5">expr5</A>		greater than
	<A HREF="#expr5">expr5</A> &gt;= <A HREF="#expr5">expr5</A>		greater than or equal
	<A HREF="#expr5">expr5</A> <A HREF="change.html#&lt;">&lt;</A>	 <A HREF="#expr5">expr5</A>		smaller than
	<A HREF="#expr5">expr5</A> &lt;= <A HREF="#expr5">expr5</A>		smaller than or equal
	<A HREF="#expr5">expr5</A> =~ <A HREF="#expr5">expr5</A>		<A HREF="pattern.html#regexp">regexp</A> matches
	<A HREF="#expr5">expr5</A> !~ <A HREF="#expr5">expr5</A>		<A HREF="pattern.html#regexp">regexp</A> doesn't match

	<A HREF="#expr5">expr5</A> <A HREF="change.html#==">==</A>? <A HREF="#expr5">expr5</A>		equal, ignoring <A HREF="change.html#case">case</A>
	<A HREF="#expr5">expr5</A> ==# <A HREF="#expr5">expr5</A>		equal, match <A HREF="change.html#case">case</A>
	etc.			As above, append ? for ignoring <A HREF="change.html#case">case</A>, # for
				matching <A HREF="change.html#case">case</A>

	<A HREF="#expr5">expr5</A> is <A HREF="#expr5">expr5</A>		same |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>| instance
	<A HREF="#expr5">expr5</A> isnot <A HREF="#expr5">expr5</A>	different |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>|
				instance

|<A HREF="#expr5">expr5</A>|	<A HREF="#expr6">expr6</A>
	<A HREF="#expr6">expr6</A> +	 <A HREF="#expr6">expr6</A> <A HREF="userfunc.html#...">...</A>	number addition, <A HREF="#list">list</A> or <A HREF="#blob">blob</A> concatenation
	<A HREF="#expr6">expr6</A> -	 <A HREF="#expr6">expr6</A> <A HREF="userfunc.html#...">...</A>	number subtraction
	<A HREF="#expr6">expr6</A> .	 <A HREF="#expr6">expr6</A> <A HREF="userfunc.html#...">...</A>	<A HREF="#string">string</A> concatenation
	<A HREF="#expr6">expr6</A> .. <A HREF="#expr6">expr6</A> <A HREF="userfunc.html#...">...</A>	<A HREF="#string">string</A> concatenation

|<A HREF="#expr6">expr6</A>|	<A HREF="#expr7">expr7</A>
	<A HREF="#expr7">expr7</A> &#42;	 <A HREF="#expr7">expr7</A> <A HREF="userfunc.html#...">...</A>	number multiplication
	<A HREF="#expr7">expr7</A> /	 <A HREF="#expr7">expr7</A> <A HREF="userfunc.html#...">...</A>	number division
	<A HREF="#expr7">expr7</A> <A HREF="motion.html#&#37;">&#37;</A>	 <A HREF="#expr7">expr7</A> <A HREF="userfunc.html#...">...</A>	number modulo

|<A HREF="#expr7">expr7</A>|	<A HREF="#expr8">expr8</A>
	! <A HREF="#expr7">expr7</A>			logical NOT
	- <A HREF="#expr7">expr7</A>			unary minus
	+ <A HREF="#expr7">expr7</A>			unary plus

|<A HREF="#expr8">expr8</A>|	<A HREF="#expr9">expr9</A>
	expr8[expr1]		byte of a <A HREF="#String">String</A> or item of a |<A HREF="#List">List</A>|
	expr8[expr1 : expr1]	<A HREF="#substring">substring</A> of a <A HREF="#String">String</A> or <A HREF="#sublist">sublist</A> of a |<A HREF="#List">List</A>|
	expr8.name		entry in a |<A HREF="#Dictionary">Dictionary</A>|
	expr8(expr1, <A HREF="userfunc.html#...">...</A>)	function call with |<A HREF="#Funcref">Funcref</A>| variable
	expr8-&gt;name(expr1, <A HREF="userfunc.html#...">...</A>)	|<A HREF="#method">method</A>| call

|<A HREF="#expr9">expr9</A>|	number			number constant
	&quot;<A HREF="#string">string</A>&quot;		<A HREF="#string">string</A> constant, <A HREF="intro.html#backslash">backslash</A> is special
	'<A HREF="#string">string</A>'		<A HREF="#string">string</A> constant, '' is doubled
	[expr1, ...]		|<A HREF="#List">List</A>|
	{expr1: <A HREF="#expr1">expr1</A>, ...}	|<A HREF="#Dictionary">Dictionary</A>|
	#{key: <A HREF="#expr1">expr1</A>, ...}	|<A HREF="#Dictionary">Dictionary</A>|
	&amp;option			option value
	(expr1)			nested <A HREF="#expression">expression</A>
	variable		internal variable
	va{ria}ble		internal variable with curly braces
	$VAR			environment variable
	<A HREF="#@r">@r</A>			contents of <A HREF="intro.html#register">register</A> '<A HREF="change.html#r">r</A>'
	function(expr1, <A HREF="userfunc.html#...">...</A>)	function call
	func{ti}on(expr1, <A HREF="userfunc.html#...">...</A>)	function call with curly braces
	{args <A HREF="#-&gt;">-&gt;</A> expr1}		<A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>


&quot;<A HREF="userfunc.html#...">...</A>&quot; indicates that the operations in this level can be concatenated.
Example:
<B>	&amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</B>

All expressions within one level are parsed from left to right.



<A HREF="#expr1">expr1</A>							*<A NAME="expr1"></A><B>expr1</B>* *<A NAME="ternary"></A><B>ternary</B>* *<A NAME="E109"></A><B>E109</B>*

<A HREF="#expr2">expr2</A> ? <A HREF="#expr1">expr1</A> : <A HREF="#expr1">expr1</A>

The <A HREF="#expression">expression</A> before the '<A HREF="pattern.html#?">?</A>' is evaluated to a number.  If <A HREF="motion.html#it">it</A> evaluates to
|<A HREF="#TRUE">TRUE</A>|, the result is the value of the <A HREF="#expression">expression</A> between the '<A HREF="pattern.html#?">?</A>' and '<A HREF="cmdline.html#:">:</A>',
otherwise the result is the value of the <A HREF="#expression">expression</A> after the '<A HREF="cmdline.html#:">:</A>'.
Example:
<B>	:echo lnum == 1 ? "top" : lnum</B>

Since the first <A HREF="#expression">expression</A> is an &quot;<A HREF="#expr2">expr2</A>&quot;, <A HREF="motion.html#it">it</A> cannot contain another ?:.  The
other two expressions can, thus allow for recursive use of ?:.
Example:
<B>	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum</B>

To keep this readable, using |<A HREF="repeat.html#line-continuation">line-continuation</A>| is suggested:
<B>	:echo lnum == 1</B>
<B>	:\	? "top"</B>
<B>	:\	: lnum == 1000</B>
<B>	:\		? "last"</B>
<B>	:\		: lnum</B>

You should always put a space before the '<A HREF="cmdline.html#:">:</A>', otherwise <A HREF="motion.html#it">it</A> can be mistaken for
use in a variable such <A HREF="motion.html#as">as</A> &quot;<A HREF="userfunc.html#a:1">a:1</A>&quot;.



<A HREF="#expr2">expr2</A> and <A HREF="#expr3">expr3</A>						*<A NAME="expr2"></A><B>expr2</B>* *<A NAME="expr3"></A><B>expr3</B>*


<A HREF="#expr3">expr3</A> &#124;&#124; <A HREF="#expr3">expr3</A> ..	logical OR		*<A NAME="expr-barbar"></A><B>expr-barbar</B>*

<A HREF="#expr4">expr4</A> &amp;&amp; <A HREF="#expr4">expr4</A> ..	logical AND		*<A NAME="expr-&amp;&amp;"></A><B>expr-&amp;&amp;</B>*

The &quot;&#124;&#124;&quot; and &quot;&amp;&amp;&quot; operators take one argument on each side.  The arguments
are (converted to) Numbers.  The result is:

<B><FONT COLOR="PURPLE">    input			 output </FONT></B>
<B><FONT COLOR="PURPLE">n1	n2		n1 || n2	n1 &amp;&amp; n2 </FONT></B>
|<A HREF="#FALSE">FALSE</A>|	|<A HREF="#FALSE">FALSE</A>|		|<A HREF="#FALSE">FALSE</A>|		|<A HREF="#FALSE">FALSE</A>|
|<A HREF="#FALSE">FALSE</A>|	|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#FALSE">FALSE</A>|
|<A HREF="#TRUE">TRUE</A>|	|<A HREF="#FALSE">FALSE</A>|		|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#FALSE">FALSE</A>|
|<A HREF="#TRUE">TRUE</A>|	|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#TRUE">TRUE</A>|		|<A HREF="#TRUE">TRUE</A>|

The operators can be concatenated, for example:

<B>	&amp;nu || &amp;list &amp;&amp; &amp;shell == "csh"</B>

Note that &quot;&amp;&amp;&quot; takes precedence over &quot;&#124;&#124;&quot;, so this has the meaning of:

<B>	&amp;nu || (&amp;list &amp;&amp; &amp;shell == "csh")</B>

Once the result is known, the <A HREF="#expression">expression</A> &quot;short-circuits&quot;, that is, further
arguments are not evaluated.  This is like what happens in C.  For example:

<B>	let a = 1</B>
<B>	echo a || b</B>

This is valid even if there is no variable called &quot;<A HREF="motion.html#b">b</A>&quot; because &quot;<A HREF="insert.html#a">a</A>&quot; is |<A HREF="#TRUE">TRUE</A>|,
so the result must be |<A HREF="#TRUE">TRUE</A>|.  Similarly below:

<B>	echo exists("b") &amp;&amp; b == "yes"</B>

This is valid whether &quot;<A HREF="motion.html#b">b</A>&quot; has been defined or not.  The second clause will
only be evaluated if &quot;<A HREF="motion.html#b">b</A>&quot; has been defined.



<A HREF="#expr4">expr4</A>							*<A NAME="expr4"></A><B>expr4</B>*

<A HREF="#expr5">expr5</A> {cmp} <A HREF="#expr5">expr5</A>

Compare two <A HREF="#expr5">expr5</A> expressions, resulting in a 0 if <A HREF="motion.html#it">it</A> evaluates to false, or 1
if <A HREF="motion.html#it">it</A> evaluates to true.


			*<A NAME="expr-=="></A><B>expr-==</B>*  *<A NAME="expr-!="></A><B>expr-!=</B>*  *<A NAME="expr-&gt;"></A><B>expr-&gt;</B>*	 *<A NAME="expr-&gt;="></A><B>expr-&gt;=</B>*

			*<A NAME="expr-&lt;"></A><B>expr-&lt;</B>*   *<A NAME="expr-&lt;="></A><B>expr-&lt;=</B>*  *<A NAME="expr-=~"></A><B>expr-=~</B>*  *<A NAME="expr-!~"></A><B>expr-!~</B>*

			*<A NAME="expr-==#"></A><B>expr-==#</B>* *<A NAME="expr-!=#"></A><B>expr-!=#</B>* *<A NAME="expr-&gt;#"></A><B>expr-&gt;#</B>*  *<A NAME="expr-&gt;=#"></A><B>expr-&gt;=#</B>*

			*<A NAME="expr-&lt;#"></A><B>expr-&lt;#</B>*  *<A NAME="expr-&lt;=#"></A><B>expr-&lt;=#</B>* *<A NAME="expr-=~#"></A><B>expr-=~#</B>* *<A NAME="expr-!~#"></A><B>expr-!~#</B>*

			*<A NAME="expr-==?"></A><B>expr-==?</B>* *<A NAME="expr-!=?"></A><B>expr-!=?</B>* *<A NAME="expr-&gt;?"></A><B>expr-&gt;?</B>*  *<A NAME="expr-&gt;=?"></A><B>expr-&gt;=?</B>*

			*<A NAME="expr-&lt;?"></A><B>expr-&lt;?</B>*  *<A NAME="expr-&lt;=?"></A><B>expr-&lt;=?</B>* *<A NAME="expr-=~?"></A><B>expr-=~?</B>* *<A NAME="expr-!~?"></A><B>expr-!~?</B>*

			*<A NAME="expr-is"></A><B>expr-is</B>* *<A NAME="expr-isnot"></A><B>expr-isnot</B>* *<A NAME="expr-is#"></A><B>expr-is#</B>* *<A NAME="expr-isnot#"></A><B>expr-isnot#</B>*

			*<A NAME="expr-is?"></A><B>expr-is?</B>* *<A NAME="expr-isnot?"></A><B>expr-isnot?</B>*
<B><FONT COLOR="PURPLE">		use 'ignorecase'    match case	   ignore case </FONT></B>
equal			<A HREF="change.html#==">==</A>		==#		<A HREF="change.html#==">==</A>?
not equal		!=		!=#		!=?
greater than		<A HREF="change.html#&gt;">&gt;</A>		&gt;#		<A HREF="change.html#&gt;">&gt;</A>?
greater than or equal	&gt;=		&gt;=#		&gt;=?
smaller than		<A HREF="change.html#&lt;">&lt;</A>		&lt;#		<A HREF="change.html#&lt;">&lt;</A>?
smaller than or equal	&lt;=		&lt;=#		&lt;=?
<A HREF="pattern.html#regexp">regexp</A> matches		=~		=~#		=~?
<A HREF="pattern.html#regexp">regexp</A> doesn't match	!~		!~#		!~?
same instance		is		is#		is?
different instance	isnot		isnot#		isnot?

Examples:
&quot;abc&quot; ==# &quot;Abc&quot;	  evaluates to 0
&quot;abc&quot; <A HREF="change.html#==">==</A>? &quot;Abc&quot;	  evaluates to 1
&quot;abc&quot; <A HREF="change.html#==">==</A> &quot;Abc&quot;	  evaluates to 1 if <A HREF="options.html#'ignorecase'">'ignorecase'</A> is set, 0 otherwise


							*<A NAME="E691"></A><B>E691</B>* *<A NAME="E692"></A><B>E692</B>*
A |<A HREF="#List">List</A>| can only be compared with a |<A HREF="#List">List</A>| and only &quot;equal&quot;, &quot;not equal&quot;,
&quot;is&quot; and &quot;isnot&quot; can be used.  This compares the values of the <A HREF="#list">list</A>,
recursively.  Ignoring <A HREF="change.html#case">case</A> means <A HREF="change.html#case">case</A> is ignored when comparing item values.


							*<A NAME="E735"></A><B>E735</B>* *<A NAME="E736"></A><B>E736</B>*
A |<A HREF="#Dictionary">Dictionary</A>| can only be compared with a |<A HREF="#Dictionary">Dictionary</A>| and only &quot;equal&quot;, &quot;not
equal&quot;, &quot;is&quot; and &quot;isnot&quot; can be used.  This compares the key/values of the
|<A HREF="#Dictionary">Dictionary</A>| recursively.  Ignoring <A HREF="change.html#case">case</A> means <A HREF="change.html#case">case</A> is ignored when comparing
item values.


							*<A NAME="E694"></A><B>E694</B>*
A |<A HREF="#Funcref">Funcref</A>| can only be compared with a |<A HREF="#Funcref">Funcref</A>| and only &quot;equal&quot;, &quot;not
equal&quot;, &quot;is&quot; and &quot;isnot&quot; can be used.  Case is never ignored.  Whether
arguments or a <A HREF="#Dictionary">Dictionary</A> are bound (with a <A HREF="builtin.html#partial">partial</A>) matters.  The
<A HREF="#Dictionaries">Dictionaries</A> must also be equal (or the same, in <A HREF="change.html#case">case</A> of &quot;is&quot;) and the
arguments must be equal (or the same).

To compare Funcrefs to see if they refer to the same function, ignoring bound
<A HREF="#Dictionary">Dictionary</A> and arguments, use |<A HREF="builtin.html#get()">get()</A>| to get the function name:
<B>	if get(Part1, 'name') == get(Part2, 'name')</B>
<B>	   " Part1 and Part2 refer to the same function</B>

Using &quot;is&quot; or &quot;isnot&quot; with a |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>| checks whether
the expressions are referring to the same |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>|
instance.  A copy of a |<A HREF="#List">List</A>| is different from the original |<A HREF="#List">List</A>|.  When
using &quot;is&quot; without a |<A HREF="#List">List</A>|, |<A HREF="#Dictionary">Dictionary</A>| or |<A HREF="#Blob">Blob</A>|, <A HREF="motion.html#it">it</A> is equivalent to
using &quot;equal&quot;, using &quot;isnot&quot; is equivalent to using &quot;not equal&quot;.  Except that
a different type means the values are different:
<B>	echo 4 == '4'</B>
<B>	1</B>
<B>	echo 4 is '4'</B>
<B>	0</B>
<B>	echo 0 is []</B>
<B>	0</B>
&quot;is#&quot;/&quot;isnot#&quot; and &quot;is?&quot;/&quot;isnot?&quot; can be used to match and ignore <A HREF="change.html#case">case</A>.

When comparing a <A HREF="#String">String</A> with a <A HREF="#Number">Number</A>, the <A HREF="#String">String</A> is converted to a <A HREF="#Number">Number</A>,
and the comparison is done on Numbers.  This means that:
<B>	echo 0 == 'x'</B>
<B>	1</B>
because '<A HREF="change.html#x">x</A>' converted to a <A HREF="#Number">Number</A> is zero.  However:
<B>	echo [0] == ['x']</B>
<B>	0</B>
Inside a <A HREF="#List">List</A> or <A HREF="#Dictionary">Dictionary</A> this conversion is not used.

When comparing two Strings, this is done with strcmp() or stricmp().  This
results in the mathematical difference (comparing byte values), not
necessarily the alphabetical difference in the local language.

When using the operators with a trailing '<A HREF="pattern.html##">#</A>', or the short version and
<A HREF="options.html#'ignorecase'">'ignorecase'</A> is off, the comparing is done with strcmp(): <A HREF="change.html#case">case</A> matters.

When using the operators with a trailing '<A HREF="pattern.html#?">?</A>', or the short version and
<A HREF="options.html#'ignorecase'">'ignorecase'</A> is set, the comparing is done with stricmp(): <A HREF="change.html#case">case</A> is ignored.

<A HREF="options.html#'smartcase'">'smartcase'</A> is not used.

The &quot;=~&quot; and &quot;!~&quot; operators match the lefthand argument with the righthand
argument, which is used <A HREF="motion.html#as">as</A> a pattern.  See |<A HREF="pattern.html#pattern">pattern</A>| for what a pattern is.
This matching is always done like <A HREF="options.html#'magic'">'magic'</A> was set and <A HREF="options.html#'cpoptions'">'cpoptions'</A> is empty, no
matter what the actual value of <A HREF="options.html#'magic'">'magic'</A> or <A HREF="options.html#'cpoptions'">'cpoptions'</A> is.  This makes scripts
portable.  To avoid backslashes in the <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A> to be doubled, use a
single-quote string, see |<A HREF="#literal-string">literal-string</A>|.
Since a <A HREF="#string">string</A> is considered to be a single line, a multi-line <A HREF="pattern.html#pattern">pattern</A>
(containing \n, backslash-n) will not match.  However, a literal NL character
can be matched like an ordinary character.  Examples:
	&quot;foo\nbar&quot; =~ &quot;\n&quot;	evaluates to 1
	&quot;foo\nbar&quot; =~ &quot;\\n&quot;	evaluates to 0



<A HREF="#expr5">expr5</A> and <A HREF="#expr6">expr6</A>						*<A NAME="expr5"></A><B>expr5</B>* *<A NAME="expr6"></A><B>expr6</B>*

<A HREF="#expr6">expr6</A> + <A HREF="#expr6">expr6</A>   <A HREF="#Number">Number</A> addition, |<A HREF="#List">List</A>| or |<A HREF="#Blob">Blob</A>| concatenation	*<A NAME="expr-+"></A><B>expr-+</B>*

<A HREF="#expr6">expr6</A> - <A HREF="#expr6">expr6</A>   <A HREF="#Number">Number</A> subtraction				*<A NAME="expr--"></A><B>expr--</B>*

<A HREF="#expr6">expr6</A> . <A HREF="#expr6">expr6</A>   <A HREF="#String">String</A> concatenation				*<A NAME="expr-."></A><B>expr-.</B>*

<A HREF="#expr6">expr6</A> .. <A HREF="#expr6">expr6</A>  <A HREF="#String">String</A> concatenation				*<A NAME="expr-.."></A><B>expr-..</B>*

For |<A HREF="#Lists">Lists</A>| only &quot;<A HREF="motion.html#+">+</A>&quot; is possible and then both <A HREF="#expr6">expr6</A> must be a <A HREF="#list">list</A>.  The
result is a new <A HREF="#list">list</A> with the two lists Concatenated.

For <A HREF="#String">String</A> concatenation &quot;..&quot; is preferred, since &quot;<A HREF="repeat.html#.">.</A>&quot; is ambiguous, <A HREF="motion.html#it">it</A> is also
used for |<A HREF="#Dict">Dict</A>| member access and floating point numbers.


<A HREF="#expr7">expr7</A> &#42; <A HREF="#expr7">expr7</A>  <A HREF="#Number">Number</A> multiplication				*<A NAME="expr-star"></A><B>expr-star</B>*

<A HREF="#expr7">expr7</A> / <A HREF="#expr7">expr7</A>  <A HREF="#Number">Number</A> division					*<A NAME="expr-/"></A><B>expr-/</B>*

<A HREF="#expr7">expr7</A> <A HREF="motion.html#&#37;">&#37;</A> <A HREF="#expr7">expr7</A>  <A HREF="#Number">Number</A> modulo					*<A NAME="expr-&#37;"></A><B>expr-&#37;</B>*

For all, except &quot;<A HREF="repeat.html#.">.</A>&quot; and &quot;..&quot;, Strings are converted to Numbers.
For bitwise operators see |<A HREF="builtin.html#and()">and()</A>|, |<A HREF="builtin.html#or()">or()</A>| and |<A HREF="builtin.html#xor()">xor()</A>|.

Note the difference between &quot;<A HREF="motion.html#+">+</A>&quot; and &quot;<A HREF="repeat.html#.">.</A>&quot;:
	&quot;123&quot; + &quot;456&quot; = 579
	&quot;123&quot; . &quot;456&quot; = &quot;123456&quot;

Since '<A HREF="repeat.html#.">.</A>' has the same precedence <A HREF="motion.html#as">as</A> '<A HREF="motion.html#+">+</A>' and '<A HREF="motion.html#-">-</A>', you need to read:
<B>	1 . 90 + 90.0</B>
As:
<B>	(1 . 90) + 90.0</B>
That works, since the <A HREF="#String">String</A> &quot;190&quot; is automatically converted to the <A HREF="#Number">Number</A>
190, which can be added to the <A HREF="#Float">Float</A> 90.0.  However:
<B>	1 . 90 * 90.0</B>
Should be read <A HREF="motion.html#as">as</A>:
<B>	1 . (90 * 90.0)</B>
Since '<A HREF="repeat.html#.">.</A>' has lower precedence than '*'.  This does NOT work, since this
attempts to concatenate a <A HREF="#Float">Float</A> and a <A HREF="#String">String</A>.

When dividing a <A HREF="#Number">Number</A> by zero the result depends on the value:
	  0 / 0  = -0x80000000	(like NaN for <A HREF="#Float">Float</A>)
	 &gt;0 / 0  =  0x7fffffff	(like positive infinity)
	 &lt;0 / 0  = -0x7fffffff	(like negative infinity)
	(before Vim 7.2 <A HREF="motion.html#it">it</A> was always 0x7fffffff)

When 64-bit <A HREF="#Number">Number</A> support is enabled:
	  0 / 0  = -0x8000000000000000	(like NaN for <A HREF="#Float">Float</A>)
	 &gt;0 / 0  =  0x7fffffffffffffff	(like positive infinity)
	 &lt;0 / 0  = -0x7fffffffffffffff	(like negative infinity)

When the righthand side of '<A HREF="motion.html#&#37;">&#37;</A>' is zero, the result is 0.

None of these work for |<A HREF="#Funcref">Funcref</A>|<A HREF="change.html#s">s</A>.


. and <A HREF="motion.html#&#37;">&#37;</A> <A HREF="diff.html#do">do</A> not work for <A HREF="#Float">Float</A>. *<A NAME="E804"></A><B>E804</B>*



<A HREF="#expr7">expr7</A>							*<A NAME="expr7"></A><B>expr7</B>*

! <A HREF="#expr7">expr7</A>			logical NOT		*<A NAME="expr-!"></A><B>expr-!</B>*

- <A HREF="#expr7">expr7</A>			unary minus		*<A NAME="expr-unary--"></A><B>expr-unary--</B>*

+ <A HREF="#expr7">expr7</A>			unary plus		*<A NAME="expr-unary-+"></A><B>expr-unary-+</B>*

For '<A HREF="change.html#!">!</A>' |<A HREF="#TRUE">TRUE</A>| becomes |<A HREF="#FALSE">FALSE</A>|, |<A HREF="#FALSE">FALSE</A>| becomes |<A HREF="#TRUE">TRUE</A>| (one).
For '<A HREF="motion.html#-">-</A>' the sign of the number is changed.
For '<A HREF="motion.html#+">+</A>' the number is unchanged.  Note: &quot;++&quot; has no effect.

A <A HREF="#String">String</A> will be converted to a <A HREF="#Number">Number</A> first.

These three can be repeated and mixed.  Examples:
	!-1	    <A HREF="change.html#==">==</A> 0
	!!8	    <A HREF="change.html#==">==</A> 1
	--9	    <A HREF="change.html#==">==</A> 9



<A HREF="#expr8">expr8</A>							*<A NAME="expr8"></A><B>expr8</B>*
This <A HREF="#expression">expression</A> is either |<A HREF="#expr9">expr9</A>| or a sequence of the alternatives below,
in any order.  E.g., these are all possible:
	expr8[expr1].name
	expr8.name[expr1]
	expr8(expr1, ...)[expr1].name
	expr8-&gt;(expr1, ...)[expr1]
Evaluation is always from left to right.



expr8[expr1]		item of <A HREF="#String">String</A> or |<A HREF="#List">List</A>|	*<A NAME="expr-[]"></A><B>expr-[]</B>* *<A NAME="E111"></A><B>E111</B>*

							*<A NAME="subscript"></A><B>subscript</B>*
In legacy Vim <A HREF="usr_41.html#script">script</A>:
If <A HREF="#expr8">expr8</A> is a <A HREF="#Number">Number</A> or <A HREF="#String">String</A> this results in a <A HREF="#String">String</A> that contains the
expr1'th single byte from <A HREF="#expr8">expr8</A>.  <A HREF="#expr8">expr8</A> is used <A HREF="motion.html#as">as</A> a <A HREF="#String">String</A> (a number is
automatically converted to a String), <A HREF="#expr1">expr1</A> <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A>.  This doesn't
recognize <A HREF="mbyte.html#multibyte">multibyte</A> encodings, see `byteidx()` for an alternative, or use
`split()` to turn the <A HREF="#string">string</A> into a <A HREF="#list">list</A> of characters.  Example, to get the
byte under the cursor:
<B>	:let c = getline(".")[col(".") - 1]</B>

Index zero gives the first byte.  This is like <A HREF="motion.html#it">it</A> works in C.  Careful:
text column numbers start with one!  Example, to get the byte under the
cursor:
<B>	:let c = getline(".")[col(".") - 1]</B>

If the length of the <A HREF="#String">String</A> is <A HREF="various.html#less">less</A> than the index, the result is an empty
<A HREF="#String">String</A>.  A negative index always results in an empty <A HREF="#string">string</A> (reason: backward
compatibility).  Use [-1:] to get the last byte.

If <A HREF="#expr8">expr8</A> is a |<A HREF="#List">List</A>| then <A HREF="motion.html#it">it</A> results the item at index <A HREF="#expr1">expr1</A>.  See |<A HREF="#list-index">list-index</A>|
for possible index values.  If the index is out of range this results in an
error.  Example:
<B>	:let item = mylist[-1]		" get last item</B>

Generally, if a |<A HREF="#List">List</A>| index is equal to or higher than the length of the
|<A HREF="#List">List</A>|, or more negative than the length of the |<A HREF="#List">List</A>|, this results in an
error.



expr8[expr1a : expr1b]	<A HREF="#substring">substring</A> or |<A HREF="#sublist">sublist</A>|		*<A NAME="expr-[:]"></A><B>expr-[:]</B>* *<A NAME="substring"></A><B>substring</B>*

If <A HREF="#expr8">expr8</A> is a <A HREF="#String">String</A> this results in the <A HREF="#substring">substring</A> with the bytes or
characters from expr1a to and including expr1b.  <A HREF="#expr8">expr8</A> is used <A HREF="motion.html#as">as</A> a <A HREF="#String">String</A>,
expr1a and expr1b are used <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A>.

In legacy Vim <A HREF="usr_41.html#script">script</A> the indexes are byte indexes.  This doesn't recognize
<A HREF="mbyte.html#multibyte">multibyte</A> encodings, see |<A HREF="builtin.html#byteidx()">byteidx()</A>| for computing the indexes.  If <A HREF="#expr8">expr8</A> is
a <A HREF="#Number">Number</A> <A HREF="motion.html#it">it</A> is first converted to a <A HREF="#String">String</A>.

If expr1a is omitted zero is used.  If expr1b is omitted the length of the
<A HREF="#string">string</A> minus one is used.

A negative number can be used to measure from the end of the <A HREF="#string">string</A>.  -1 is
the last character, -2 the last but one, etc.

If an index goes out of range for the <A HREF="#string">string</A> characters are omitted.  If
expr1b is smaller than expr1a the result is an empty <A HREF="#string">string</A>.

Examples:
<B>	:let c = name[-1:]		" last byte of a string</B>
<B>	:let c = name[0:-1]		" the whole string</B>
<B>	:let c = name[-2:-2]		" last but one byte of a string</B>
<B>	:let s = line(".")[4:]		" from the fifth byte to the end</B>
<B>	:let s = s[:-3]			" remove last two bytes</B>
 

							*<A NAME="slice"></A><B>slice</B>*
If <A HREF="#expr8">expr8</A> is a |<A HREF="#List">List</A>| this results in a new |<A HREF="#List">List</A>| with the items indicated by
the indexes expr1a and expr1b.  This works like with a <A HREF="#String">String</A>, <A HREF="motion.html#as">as</A> explained
just above. Also see |<A HREF="#sublist">sublist</A>| below.  Examples:
<B>	:let l = mylist[:3]		" first four items</B>
<B>	:let l = mylist[4:4]		" List with one item</B>
<B>	:let l = mylist[:]		" shallow copy of a List</B>

If <A HREF="#expr8">expr8</A> is a |<A HREF="#Blob">Blob</A>| this results in a new |<A HREF="#Blob">Blob</A>| with the bytes in the
indexes expr1a and expr1b, <A HREF="motion.html#inclusive">inclusive</A>.  Examples:
<B>	:let b = 0zDEADBEEF</B>
<B>	:let bs = b[1:2]		" 0zADBE</B>
<B>	:let bs = b[]			" copy of 0zDEADBEEF</B>

Using expr8[expr1] or expr8[expr1a : expr1b] on a |<A HREF="#Funcref">Funcref</A>| results in an
error.

Watch out for confusion between a <A HREF="api.html#namespace">namespace</A> and a variable followed by a colon
for a <A HREF="#sublist">sublist</A>:
<B>	mylist[n:]     " uses variable n</B>
<B>	mylist[s:]     " uses namespace s:, error!</B>



expr8.name		entry in a |<A HREF="#Dictionary">Dictionary</A>|		*<A NAME="expr-entry"></A><B>expr-entry</B>*

If <A HREF="#expr8">expr8</A> is a |<A HREF="#Dictionary">Dictionary</A>| and <A HREF="motion.html#it">it</A> is followed by a dot, then the following
name will be used <A HREF="motion.html#as">as</A> a key in the |<A HREF="#Dictionary">Dictionary</A>|.  This is just like:
expr8[name].

The name must consist of alphanumeric characters, just like a variable name,
but <A HREF="motion.html#it">it</A> may start with a number.  Curly braces cannot be used.

There must not be white space before or after the dot.

Examples:
<B>	:let dict = {"one": 1, 2: "two"}</B>
<B>	:echo dict.one		" shows "1"</B>
<B>	:echo dict.2		" shows "two"</B>
<B>	:echo dict .2		" error because of space before the dot</B>

Note that the dot is also used for <A HREF="#String">String</A> concatenation.  To avoid confusion
always put spaces around the dot for <A HREF="#String">String</A> concatenation.


expr8(expr1, <A HREF="userfunc.html#...">...</A>)	|<A HREF="#Funcref">Funcref</A>| function call

When <A HREF="#expr8">expr8</A> is a |<A HREF="#Funcref">Funcref</A>| type variable, invoke the function <A HREF="motion.html#it">it</A> refers to.



expr8-&gt;name([args])	<A HREF="#method">method</A> call			*<A NAME="method"></A><B>method</B>* *<A NAME="-&gt;"></A><B>-&gt;</B>*
expr8-&gt;{lambda}([args])


							*<A NAME="E260"></A><B>E260</B>* *<A NAME="E276"></A><B>E276</B>*
For methods that are also available <A HREF="motion.html#as">as</A> global <A HREF="#functions">functions</A> this is the same <A HREF="motion.html#as">as</A>:
<B>	name(expr8 [, args])</B>
There can also be methods specifically for the type of &quot;<A HREF="#expr8">expr8</A>&quot;.

This allows for chaining, passing the value that one <A HREF="#method">method</A> returns to the
next <A HREF="#method">method</A>:
<B>	mylist-&gt;filter(filterexpr)-&gt;map(mapexpr)-&gt;sort()-&gt;join()</B>
 
Example of using a <A HREF="#lambda">lambda</A>:
<B>	GetPercentage()-&gt;{x -&gt; x * 100}()-&gt;printf('%d%%')</B>
 
When using <A HREF="#-&gt;">-&gt;</A> the |<A HREF="#expr7">expr7</A>| operators will be applied first, thus:
<B>	-1.234-&gt;string()</B>
Is equivalent to:
<B>	(-1.234)-&gt;string()</B>
And NOT:
<B>	-(1.234-&gt;string())</B>
 

							*<A NAME="E274"></A><B>E274</B>*
&quot;-&gt;name(&quot; must not contain white space.  There can be white space before the
&quot;<A HREF="#-&gt;">-&gt;</A>&quot; and after the &quot;<A HREF="motion.html#(">(</A>&quot;, thus you can split the lines like this:
<B>	mylist</B>
<B>	\ -&gt;filter(filterexpr)</B>
<B>	\ -&gt;map(mapexpr)</B>
<B>	\ -&gt;sort()</B>
<B>	\ -&gt;join()</B>

When using the <A HREF="#lambda">lambda</A> form there must be no white space between the } and the
(.



							*<A NAME="expr9"></A><B>expr9</B>*
number

number			number constant			*<A NAME="expr-number"></A><B>expr-number</B>*


			*<A NAME="0x"></A><B>0x</B>* *<A NAME="hex-number"></A><B>hex-number</B>* *<A NAME="0o"></A><B>0o</B>* *<A NAME="octal-number"></A><B>octal-number</B>* *<A NAME="binary-number"></A><B>binary-number</B>*
Decimal, Hexadecimal (starting with <A HREF="#0x">0x</A> or 0X), Binary (starting with 0b or 0B)
and Octal (starting with 0, <A HREF="#0o">0o</A> or 0O).


						*<A NAME="floating-point-format"></A><B>floating-point-format</B>*
Floating point numbers can be written in two forms:

	[-+]{N}.{M}
	[-+]{N}.{M}[eE][-+]{exp}

{N} and {M} are numbers.  Both {N} and {M} must be present and can only
contain digits.
[-+] means there is an optional plus or minus sign.
{exp} is the exponent, power of 10.
Only a decimal point is accepted, not a comma.  No matter what the current
<A HREF="mbyte.html#locale">locale</A> is.

Examples:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88

These are INVALID:
	3.		empty {M}
	1e40		missing .{M}

Rationale:
Before floating point was introduced, the text &quot;123.456&quot; was interpreted <A HREF="motion.html#as">as</A>
the two numbers &quot;123&quot; and &quot;456&quot;, both converted to a <A HREF="#string">string</A> and concatenated,
resulting in the <A HREF="#string">string</A> &quot;123456&quot;.  Since this was considered pointless, and we
could not find <A HREF="motion.html#it">it</A> intentionally being used in Vim scripts, this backwards
incompatibility was accepted in favor of being able to use the normal <A HREF="intro.html#notation">notation</A>
for floating point numbers.


							*<A NAME="float-pi"></A><B>float-pi</B>* *<A NAME="float-e"></A><B>float-e</B>*
A few useful values to copy&amp;paste:
<B>	:let pi = 3.14159265359</B>
<B>	:let e  = 2.71828182846</B>
Or, if you don't want to write them in <A HREF="motion.html#as">as</A> floating-point literals, you can
also use <A HREF="#functions">functions</A>, like the following:
<B>	:let pi = acos(-1.0)</B>
<B>	:let e  = exp(1.0)</B>
 

						*<A NAME="floating-point-precision"></A><B>floating-point-precision</B>*
The precision and range of floating points numbers depends on what &quot;double&quot;
means in the library Vim was compiled with.  There is no way to change this at
runtime.

The default for displaying a |<A HREF="#Float">Float</A>| is to use 6 decimal places, like using
printf(&quot;&#37;g&quot;, <A HREF="motion.html#f">f</A>f).  You can select something else when using the |<A HREF="builtin.html#printf()">printf()</A>|
function.  Example:
<B>	:echo printf('%.15e', atan(1))</B>
 	7.853981633974483e-01




<A HREF="#string">string</A>					*<A NAME="string"></A><B>string</B>* *<A NAME="String"></A><B>String</B>* *<A NAME="expr-string"></A><B>expr-string</B>* *<A NAME="E114"></A><B>E114</B>*

&quot;<A HREF="#string">string</A>&quot;		<A HREF="#string">string</A> constant		*<A NAME="expr-quote"></A><B>expr-quote</B>*

Note that double quotes are used.

A <A HREF="#string">string</A> constant accepts these special characters:
\...	three-digit <A HREF="#octal">octal</A> number (e.g., &quot;\316&quot;)
\..	two-digit <A HREF="#octal">octal</A> number (must be followed by non-digit)
\.	one-digit <A HREF="#octal">octal</A> number (must be followed by non-digit)
\x..	byte specified with two hex numbers (e.g., &quot;\x1f&quot;)
\x.	byte specified with one hex number (must be followed by non-hex char)
\X..	same <A HREF="motion.html#as">as</A> \x..
\X.	same <A HREF="motion.html#as">as</A> \x.
\u....	character specified with up to 4 hex numbers, stored <A HREF="motion.html#as">as</A> <A HREF="mbyte.html#UTF-8">UTF-8</A>
	(e.g., &quot;\u02a4&quot;)
\U....	same <A HREF="motion.html#as">as</A> \u but allows up to 8 hex numbers.
\b	backspace <A HREF="motion.html#&lt;BS&gt;">&lt;BS&gt;</A>
\e	<A HREF="intro.html#escape">escape</A> <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>
\f	formfeed 0x0C
\n	newline <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>
\r	return <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>
\t	<A HREF="intro.html#tab">tab</A> <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>
\\	<A HREF="intro.html#backslash">backslash</A>
\&quot;	double <A HREF="change.html#quote">quote</A>
\&lt;xxx&gt;	Special key named &quot;xxx&quot;.  e.g. &quot;\&lt;C-W&gt;&quot; for <A HREF="vimindex.html#CTRL-W">CTRL-W</A>.  This is for use
	in mappings, the 0x80 byte is escaped.
	To use the double <A HREF="change.html#quote">quote</A> character <A HREF="motion.html#it">it</A> must be escaped: &quot;&lt;M-\&quot;&gt;&quot;.
	Don't use &lt;Char-xxxx&gt; to get a <A HREF="mbyte.html#UTF-8">UTF-8</A> character, use \uxxxx <A HREF="motion.html#as">as</A>
	mentioned above.
\&lt;*xxx&gt;	Like \&lt;xxx&gt; but prepends a modifier instead of including <A HREF="motion.html#it">it</A> in the
	character.  E.g. &quot;\&lt;C-w&gt;&quot; is one character 0x17 while &quot;\&lt;*C-w&gt;&quot; is four
	bytes: 3 for the CTRL modifier and then character &quot;<A HREF="motion.html#W">W</A>&quot;.

Note that &quot;\xff&quot; is stored <A HREF="motion.html#as">as</A> the byte 255, which may be invalid in some
encodings.  Use &quot;\u00ff&quot; to store character 255 correctly <A HREF="motion.html#as">as</A> <A HREF="mbyte.html#UTF-8">UTF-8</A>.

Note that &quot;\000&quot; and &quot;\x00&quot; force the end of the <A HREF="#string">string</A>.



<A HREF="#blob-literal">blob-literal</A>				*<A NAME="blob-literal"></A><B>blob-literal</B>* *<A NAME="E973"></A><B>E973</B>*

Hexadecimal starting with 0z or 0Z, with an arbitrary number of bytes.
The sequence must be an even number of hex characters.  Example:
<B>	:let b = 0zFF00ED015DAF</B>



<A HREF="#literal-string">literal-string</A>						*<A NAME="literal-string"></A><B>literal-string</B>* *<A NAME="E115"></A><B>E115</B>*

'<A HREF="#string">string</A>'		<A HREF="#string">string</A> constant			*<A NAME="expr-'"></A><B>expr-'</B>*

Note that single quotes are used.

This <A HREF="#string">string</A> is taken <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is.  No backslashes are removed or have a special
meaning.  The only exception is that two quotes stand for one <A HREF="change.html#quote.">quote.</A>

Single quoted strings are useful for patterns, so that backslashes <A HREF="diff.html#do">do</A> not need
to be doubled.  These two commands are equivalent:
<B>	if a =~ "\\s*"</B>
<B>	if a =~ '\s*'</B>



option						*<A NAME="expr-option"></A><B>expr-option</B>* *<A NAME="E112"></A><B>E112</B>* *<A NAME="E113"></A><B>E113</B>*
&amp;option			option value, local value if possible
&amp;g:option		global option value
&amp;l:option		local option value

Examples:
<B>	echo "tabstop is " .. &amp;tabstop</B>
<B>	if &amp;expandtab</B>

Any option name can be used here.  See |<A HREF="options.html#options">options</A>|.  When using the local value
and there is no buffer-local or window-local value, the global value is used
anyway.



<A HREF="intro.html#register">register</A>						*<A NAME="expr-register"></A><B>expr-register</B>* *<A NAME="@r"></A><B>@r</B>*
<A HREF="#@r">@r</A>			contents of <A HREF="intro.html#register">register</A> '<A HREF="change.html#r">r</A>'

The result is the contents of the named <A HREF="intro.html#register">register</A>, <A HREF="motion.html#as">as</A> a single <A HREF="#string">string</A>.
Newlines are inserted where required.  To get the contents of the unnamed
register use @&quot; or <A HREF="repeat.html#@@">@@</A>.  See |<A HREF="change.html#registers">registers</A>| for an explanation of the available
<A HREF="change.html#registers">registers</A>.

When using the '<A HREF="change.html#=">=</A>' <A HREF="intro.html#register">register</A> you get the <A HREF="#expression">expression</A> itself, not what <A HREF="motion.html#it">it</A>
evaluates to.  Use |<A HREF="builtin.html#eval()">eval()</A>| to evaluate <A HREF="motion.html#it">it</A>.



nesting							*<A NAME="expr-nesting"></A><B>expr-nesting</B>* *<A NAME="E110"></A><B>E110</B>*
(expr1)			nested <A HREF="#expression">expression</A>



environment variable					*<A NAME="expr-env"></A><B>expr-env</B>*
$VAR			environment variable

The <A HREF="#String">String</A> value of any environment variable.  When <A HREF="motion.html#it">it</A> is not defined, the
result is an empty <A HREF="#string">string</A>.

The <A HREF="#functions">functions</A> `getenv()` and `setenv()` can also be used and work for
environment <A HREF="#variables">variables</A> with non-alphanumeric names.
The function `environ()` can be used to get a <A HREF="#Dict">Dict</A> with all environment
<A HREF="#variables">variables</A>.



						*<A NAME="expr-env-expand"></A><B>expr-env-expand</B>*
Note that there is a difference between using $VAR directly and using
expand(&quot;$VAR&quot;).  Using <A HREF="motion.html#it">it</A> directly will only expand environment <A HREF="#variables">variables</A> that
are known inside the current Vim session.  Using <A HREF="builtin.html#expand()">expand()</A> will first try using
the environment <A HREF="#variables">variables</A> known inside the current Vim session.  If that
fails, a shell will be used to expand the variable.  This can be slow, but <A HREF="motion.html#it">it</A>
does expand all <A HREF="#variables">variables</A> that the shell knows about.  Example:
<B>	:echo $shell</B>
<B>	:echo expand("$shell")</B>
The first one probably doesn't echo anything, the second echoes the $shell
variable (if your shell supports <A HREF="motion.html#it">it</A>).



internal variable					*<A NAME="expr-variable"></A><B>expr-variable</B>*
variable		internal variable
See below |<A HREF="#internal-variables">internal-variables</A>|.



function call		*<A NAME="expr-function"></A><B>expr-function</B>* *<A NAME="E116"></A><B>E116</B>* *<A NAME="E118"></A><B>E118</B>* *<A NAME="E119"></A><B>E119</B>* *<A NAME="E120"></A><B>E120</B>*
function(expr1, <A HREF="userfunc.html#...">...</A>)	function call
See below |<A HREF="#functions">functions</A>|.



<A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>				*<A NAME="expr-lambda"></A><B>expr-lambda</B>* *<A NAME="lambda"></A><B>lambda</B>*
{args <A HREF="#-&gt;">-&gt;</A> expr1}		<A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>

A <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> creates a new unnamed function which returns the result of
evaluating |<A HREF="#expr1">expr1</A>|.  Lambda expressions differ from |<A HREF="#user-function">user-function</A>|s in
the following ways:

1. The body of the <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> is an |<A HREF="#expr1">expr1</A>| and not a sequence of |<A HREF="intro.html#Ex">Ex</A>|
   commands.
2. The prefix &quot;a:&quot; should not be used for arguments.  E.g.:
<B>	:let F = {arg1, arg2 -&gt; arg1 - arg2}</B>
<B>	:echo F(5, 2)</B>
 	3

The arguments are optional.  Example:
<B>	:let F = {-&gt; 'error function'}</B>
<B>	:echo F('ignored')</B>
 	error function

							*<A NAME="closure"></A><B>closure</B>*
Lambda expressions can access outer scope <A HREF="#variables">variables</A> and arguments.  This is
often called a <A HREF="#closure">closure</A>.  Example where &quot;<A HREF="insert.html#i">i</A>&quot; and &quot;a:arg&quot; are used in a <A HREF="#lambda">lambda</A>
while they already exist in the function scope.  They remain valid even after
the function returns:
<B>	:function Foo(arg)</B>
<B>	:  let i = 3</B>
<B>	:  return {x -&gt; x + i - a:arg}</B>
<B>	:endfunction</B>
<B>	:let Bar = Foo(4)</B>
<B>	:echo Bar(6)</B>
 	5
Note that the <A HREF="#variables">variables</A> must exist in the outer scope before the <A HREF="#lambda">lambda</A> is
defined for this to work.  See also |<A HREF="userfunc.html#:func-closure">:func-closure</A>|.

Lambda and <A HREF="#closure">closure</A> support can be checked with:
<B>	if has('lambda')</B>

Examples for using a <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> with |<A HREF="builtin.html#sort()">sort()</A>|, |<A HREF="builtin.html#map()">map()</A>| and |<A HREF="builtin.html#filter()">filter()</A>|:
<B>	:echo map([1, 2, 3], {idx, val -&gt; val + 1})</B>
 	[2, 3, 4]
<B>	:echo sort([3,7,2,1,4], {a, b -&gt; a - b})</B>
 	[1, 2, 3, 4, 7]

The <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A> is also useful for jobs and <A HREF="builtin.html#timers">timers</A>:
<B>	:let timer = timer_start(500,</B>
<B>			\ {-&gt; execute("echo 'Handler called'", "")},</B>
<B>			\ {'repeat': 3})</B>
 	Handler called
	Handler called
	Handler called

Note that <A HREF="motion.html#it">it</A> is possible to cause memory to be used and not freed if the
<A HREF="#closure">closure</A> is referenced by the <A HREF="repeat.html#context">context</A> <A HREF="motion.html#it">it</A> depends on:
<B>	function Function()</B>
<B>	   let x = 0</B>
<B>	   let F = {-&gt; x}</B>
<B>	 endfunction</B>
The <A HREF="#closure">closure</A> uses &quot;<A HREF="change.html#x">x</A>&quot; from the function scope, and &quot;<A HREF="motion.html#F">F</A>&quot; in that same scope
refers to the <A HREF="#closure">closure</A>.  This cycle results in the memory not being freed.
Recommendation: don't <A HREF="diff.html#do">do</A> this.

Notice how <A HREF="builtin.html#execute()">execute()</A> is used to execute an <A HREF="intro.html#Ex">Ex</A> command.  That's ugly though.


Lambda expressions have internal names like '&lt;lambda&gt;42'.  If you get an error
for a <A HREF="#lambda">lambda</A> <A HREF="#expression">expression</A>, you can find what <A HREF="motion.html#it">it</A> is with the following command:
<B>	:function &lt;lambda&gt;42</B>
See also: |<A HREF="#numbered-function">numbered-function</A>|

==============================================================================

3. Internal variable				*<A NAME="internal-variables"></A><B>internal-variables</B>* *<A NAME="E461"></A><B>E461</B>*

An internal variable name can be made up of letters, digits and '<A HREF="motion.html#_">_</A>'.  But <A HREF="motion.html#it">it</A>
cannot start with a digit.  It's also possible to use curly braces, see
|<A HREF="#curly-braces-names">curly-braces-names</A>|.

An internal variable is created with the &quot;:let&quot; command |<A HREF="#:let">:let</A>|.
An internal variable is explicitly destroyed with the &quot;<A HREF="#:unlet">:unlet</A>&quot; command
|<A HREF="#:unlet">:unlet</A>|.
Using a name that is not an internal variable or refers to a variable that has
been destroyed results in an error.


						*<A NAME="variable-scope"></A><B>variable-scope</B>*
There are several name spaces for <A HREF="#variables">variables</A>.  Which one is to be used is
specified by what is prepended:

		(nothing) In a function: local to a function; otherwise: global
|<A HREF="#buffer-variable">buffer-variable</A>|    <A HREF="#b:">b:</A>	  Local to the current buffer.
|<A HREF="#window-variable">window-variable</A>|    <A HREF="#w:">w:</A>	  Local to the current window.
|<A HREF="#tabpage-variable">tabpage-variable</A>|   <A HREF="#t:">t:</A>	  Local to the current tab page.
|<A HREF="#global-variable">global-variable</A>|    <A HREF="#g:">g:</A>	  Global.
|<A HREF="#local-variable">local-variable</A>|     <A HREF="#l:">l:</A>	  Local to a function.
|<A HREF="#script-variable">script-variable</A>|    s:	  Local to a |<A HREF="repeat.html#:source">:source</A>|'ed Vim script.
|<A HREF="userfunc.html#function-argument">function-argument</A>|  a:	  Function argument (only inside a function).
|<A HREF="#vim-variable">vim-variable</A>|       <A HREF="#v:">v:</A>	  Global, predefined by Vim.

The scope name by itself can be used <A HREF="motion.html#as">as</A> a |<A HREF="#Dictionary">Dictionary</A>|.  For example, to
delete all <A HREF="map.html#script-local">script-local</A> <A HREF="#variables">variables</A>:
<B>	:for k in keys(s:)</B>
<B>	:    unlet s:[k]</B>
<B>	:endfor</B>
 

						*<A NAME="buffer-variable"></A><B>buffer-variable</B>* *<A NAME="b:var"></A><B>b:var</B>* *<A NAME="b:"></A><B>b:</B>*
A variable name that is preceded with &quot;<A HREF="#b:">b:</A>&quot; is local to the current buffer.
Thus you can have several &quot;b:foo&quot; <A HREF="#variables">variables</A>, one for each buffer.
This kind of variable is deleted when the buffer is wiped out or deleted with
|<A HREF="windows.html#:bdelete">:bdelete</A>|.

One local buffer variable is predefined:

					*<A NAME="b:changedtick"></A><B>b:changedtick</B>* *<A NAME="changetick"></A><B>changetick</B>*
<A HREF="#b:changedtick">b:changedtick</A>	The total number of changes to the current buffer.  It is
		incremented for each change.  An <A HREF="undo.html#undo">undo</A> command is also a change
		in this <A HREF="change.html#case">case</A>.  Resetting <A HREF="options.html#'modified'">'modified'</A> when <A HREF="editing.html#writing">writing</A> the buffer is
		also counted.
		This can be used to perform an action only when the buffer has
		changed.  Example:
<B>		    :if my_changedtick != b:changedtick</B>
<B>		    :	let my_changedtick = b:changedtick</B>
<B>		    :	call My_Update()</B>
<B>		    :endif</B>
 		You cannot change or delete the <A HREF="#b:changedtick">b:changedtick</A> variable.


						*<A NAME="window-variable"></A><B>window-variable</B>* *<A NAME="w:var"></A><B>w:var</B>* *<A NAME="w:"></A><B>w:</B>*
A variable name that is preceded with &quot;<A HREF="#w:">w:</A>&quot; is local to the current <A HREF="windows.html#window">window</A>.  It
is deleted when the <A HREF="windows.html#window">window</A> is closed.


						*<A NAME="tabpage-variable"></A><B>tabpage-variable</B>* *<A NAME="t:var"></A><B>t:var</B>* *<A NAME="t:"></A><B>t:</B>*
A variable name that is preceded with &quot;<A HREF="#t:">t:</A>&quot; is local to the current <A HREF="intro.html#tab">tab</A> page,
It is deleted when the <A HREF="intro.html#tab">tab</A> page is closed.


						*<A NAME="global-variable"></A><B>global-variable</B>* *<A NAME="g:var"></A><B>g:var</B>* *<A NAME="g:"></A><B>g:</B>*
Inside <A HREF="#functions">functions</A> global <A HREF="#variables">variables</A> are accessed with &quot;<A HREF="#g:">g:</A>&quot;.  Omitting this will
access a variable local to a function.  But &quot;<A HREF="#g:">g:</A>&quot; can also be used in any other
place if you like.


						*<A NAME="local-variable"></A><B>local-variable</B>* *<A NAME="l:var"></A><B>l:var</B>* *<A NAME="l:"></A><B>l:</B>*
Inside <A HREF="#functions">functions</A> local <A HREF="#variables">variables</A> are accessed without prepending anything.
But you can also prepend &quot;<A HREF="#l:">l:</A>&quot; if you like.  However, without prepending &quot;<A HREF="#l:">l:</A>&quot;
you may run into reserved variable names.  For example &quot;<A HREF="intro.html#count">count</A>&quot;.  By itself <A HREF="motion.html#it">it</A>
refers to &quot;<A HREF="#v:count">v:count</A>&quot;.  Using &quot;l:count&quot; you can have a local variable with the
same name.


						*<A NAME="script-variable"></A><B>script-variable</B>* *<A NAME="s:var"></A><B>s:var</B>*
In a Vim <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> starting with &quot;s:&quot; can be used.  They cannot be
accessed from outside of the scripts, thus are local to the <A HREF="usr_41.html#script">script</A>.

They can be used in:
- commands executed while the <A HREF="usr_41.html#script">script</A> is sourced
- <A HREF="#functions">functions</A> defined in the <A HREF="usr_41.html#script">script</A>
- autocommands defined in the <A HREF="usr_41.html#script">script</A>
- <A HREF="#functions">functions</A> and autocommands defined in <A HREF="#functions">functions</A> and autocommands which were
  defined in the <A HREF="usr_41.html#script">script</A> (recursively)
- user defined commands defined in the <A HREF="usr_41.html#script">script</A>
Thus not in:
- other scripts sourced from this one
- mappings
- <A HREF="gui.html#menus">menus</A>
- etc.

Script <A HREF="#variables">variables</A> can be used to avoid conflicts with global variable names.
Take this example:

<B>	let s:counter = 0</B>
<B>	function MyCounter()</B>
<B>	  let s:counter = s:counter + 1</B>
<B>	  echo s:counter</B>
<B>	endfunction</B>
<B>	command Tick call MyCounter()</B>

You can now invoke &quot;Tick&quot; from any <A HREF="usr_41.html#script">script</A>, and the &quot;s:counter&quot; variable in
that <A HREF="usr_41.html#script">script</A> will not be changed, only the &quot;s:counter&quot; in the <A HREF="usr_41.html#script">script</A> where
&quot;Tick&quot; was defined is used.

Another example that does the same:

<B>	let s:counter = 0</B>
<B>	command Tick let s:counter = s:counter + 1 | echo s:counter</B>

When calling a function and invoking a user-defined command, the <A HREF="repeat.html#context">context</A> for
<A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> is set to the <A HREF="usr_41.html#script">script</A> where the function or command was
defined.

The <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A> are also available when a function is defined inside a
function that is defined in a <A HREF="usr_41.html#script">script</A>.  Example:

<B>	let s:counter = 0</B>
<B>	function StartCounting(incr)</B>
<B>	  if a:incr</B>
<B>	    function MyCounter()</B>
<B>	      let s:counter = s:counter + 1</B>
<B>	    endfunction</B>
<B>	  else</B>
<B>	    function MyCounter()</B>
<B>	      let s:counter = s:counter - 1</B>
<B>	    endfunction</B>
<B>	  endif</B>
<B>	endfunction</B>

This defines the MyCounter() function either for counting up or counting down
when calling StartCounting().  It doesn't matter from where StartCounting() is
called, the s:counter variable will be accessible in MyCounter().

When the same <A HREF="usr_41.html#script">script</A> is sourced again <A HREF="motion.html#it">it</A> will use the same <A HREF="usr_41.html#script">script</A> <A HREF="#variables">variables</A>.
They will remain valid <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> Vim is running.  This can be used to
maintain a counter:

<B>	if !exists("s:counter")</B>
<B>	  let s:counter = 1</B>
<B>	  echo "script executed for the first time"</B>
<B>	else</B>
<B>	  let s:counter = s:counter + 1</B>
<B>	  echo "script executed " .. s:counter .. " times now"</B>
<B>	endif</B>

Note that this means that <A HREF="filetype.html#filetype">filetype</A> plugins don't get a different set of <A HREF="usr_41.html#script">script</A>
<A HREF="#variables">variables</A> for each buffer.  Use local buffer <A HREF="#variables">variables</A> instead |<A HREF="#b:var">b:var</A>|.



PREDEFINED VIM VARIABLES			*<A NAME="vim-variable"></A><B>vim-variable</B>* *<A NAME="v:var"></A><B>v:var</B>* *<A NAME="v:"></A><B>v:</B>*

								*<A NAME="E963"></A><B>E963</B>*
Some <A HREF="#variables">variables</A> can be set by the user, but the type cannot be changed.


					*<A NAME="v:argv"></A><B>v:argv</B>* *<A NAME="argv-variable"></A><B>argv-variable</B>*
<A HREF="#v:argv">v:argv</A>		The command line arguments Vim was invoked with.  This is a
		<A HREF="#list">list</A> of strings.  The first item is the Vim command.
		See |<A HREF="#v:progpath">v:progpath</A>| for the command with full path.


					*<A NAME="v:beval_col"></A><B>v:beval_col</B>* *<A NAME="beval_col-variable"></A><B>beval_col-variable</B>*
<A HREF="#v:beval_col">v:beval_col</A>	The number of the column, over which the mouse pointer is.
		This is the byte index in the |<A HREF="#v:beval_lnum">v:beval_lnum</A>| line.
		Only valid while evaluating the <A HREF="vim_diff.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_bufnr"></A><B>v:beval_bufnr</B>* *<A NAME="beval_bufnr-variable"></A><B>beval_bufnr-variable</B>*
<A HREF="#v:beval_bufnr">v:beval_bufnr</A>	The number of the buffer, over which the mouse pointer is. Only
		valid while evaluating the <A HREF="vim_diff.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_lnum"></A><B>v:beval_lnum</B>* *<A NAME="beval_lnum-variable"></A><B>beval_lnum-variable</B>*
<A HREF="#v:beval_lnum">v:beval_lnum</A>	The number of the line, over which the mouse pointer is. Only
		valid while evaluating the <A HREF="vim_diff.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_text"></A><B>v:beval_text</B>* *<A NAME="beval_text-variable"></A><B>beval_text-variable</B>*
<A HREF="#v:beval_text">v:beval_text</A>	The text under or after the mouse pointer.  Usually a <A HREF="motion.html#word">word</A> <A HREF="motion.html#as">as</A>
		<A HREF="motion.html#it">it</A> is useful for debugging a C program.  <A HREF="options.html#'iskeyword'">'iskeyword'</A> applies,
		but a dot and &quot;<A HREF="#-&gt;">-&gt;</A>&quot; before the position is included.  When on a
		'<A HREF="vimindex.html#]">]</A>' the text before <A HREF="motion.html#it">it</A> is used, including the matching '<A HREF="vimindex.html#[">[</A>' and
		<A HREF="motion.html#word">word</A> before <A HREF="motion.html#it">it</A>.  When on a <A HREF="visual.html#Visual">Visual</A> area within one line the
		highlighted text is used.  Also see |<A HREF="cmdline.html#&lt;cexpr&gt;">&lt;cexpr&gt;</A>|.
		Only valid while evaluating the <A HREF="vim_diff.html#'balloonexpr'">'balloonexpr'</A> option.


					*<A NAME="v:beval_winnr"></A><B>v:beval_winnr</B>* *<A NAME="beval_winnr-variable"></A><B>beval_winnr-variable</B>*
<A HREF="#v:beval_winnr">v:beval_winnr</A>	The number of the <A HREF="windows.html#window">window</A>, over which the mouse pointer is. Only
		valid while evaluating the <A HREF="vim_diff.html#'balloonexpr'">'balloonexpr'</A> option.  The first
		<A HREF="windows.html#window">window</A> has number zero (unlike most other places where a
		<A HREF="windows.html#window">window</A> gets a number).


					*<A NAME="v:beval_winid"></A><B>v:beval_winid</B>* *<A NAME="beval_winid-variable"></A><B>beval_winid-variable</B>*
<A HREF="#v:beval_winid">v:beval_winid</A>	The |<A HREF="windows.html#window-ID">window-ID</A>| of the window, over which the mouse pointer
		is.  Otherwise like <A HREF="#v:beval_winnr">v:beval_winnr</A>.


					*<A NAME="v:char"></A><B>v:char</B>* *<A NAME="char-variable"></A><B>char-variable</B>*
<A HREF="#v:char">v:char</A>		Argument for evaluating <A HREF="options.html#'formatexpr'">'formatexpr'</A> and used for the typed
		character when using &lt;expr&gt; in an abbreviation |<A HREF="map.html#:map-&lt;expr&gt;">:map-&lt;expr&gt;</A>|.
		It is also used by the |<A HREF="autocmd.html#InsertCharPre">InsertCharPre</A>| and |<A HREF="autocmd.html#InsertEnter">InsertEnter</A>| <A HREF="autocmd.html#events">events</A>.


			*<A NAME="v:charconvert_from"></A><B>v:charconvert_from</B>* *<A NAME="charconvert_from-variable"></A><B>charconvert_from-variable</B>*
<A HREF="#v:charconvert_from">v:charconvert_from</A>
		The name of the character encoding of a file to be converted.
		Only valid while evaluating the <A HREF="options.html#'charconvert'">'charconvert'</A> option.


			*<A NAME="v:charconvert_to"></A><B>v:charconvert_to</B>* *<A NAME="charconvert_to-variable"></A><B>charconvert_to-variable</B>*
<A HREF="#v:charconvert_to">v:charconvert_to</A>
		The name of the character encoding of a file after conversion.
		Only valid while evaluating the <A HREF="options.html#'charconvert'">'charconvert'</A> option.


					*<A NAME="v:cmdarg"></A><B>v:cmdarg</B>* *<A NAME="cmdarg-variable"></A><B>cmdarg-variable</B>*
<A HREF="#v:cmdarg">v:cmdarg</A>	This variable is used for two purposes:
		1. The extra arguments given to a file read/write command.
		   Currently these are &quot;++enc=&quot; and &quot;++ff=&quot;.  This variable is
		   set before an <A HREF="autocmd.html#autocommand">autocommand</A> event for a file read/write
		   command is triggered.  There is a leading space to make <A HREF="motion.html#it">it</A>
		   possible to append this variable directly after the
		   read/write command.  Note: The &quot;<A HREF="editing.html#+cmd">+cmd</A>&quot; argument isn't
		   included here, because <A HREF="motion.html#it">it</A> will be executed anyway.
		2. When <A HREF="print.html#printing">printing</A> a PostScript file with &quot;<A HREF="print.html#:hardcopy">:hardcopy</A>&quot; this is
		   the argument for the &quot;<A HREF="print.html#:hardcopy">:hardcopy</A>&quot; command.  This can be used
		   in <A HREF="options.html#'printexpr'">'printexpr'</A>.


						*<A NAME="v:collate"></A><B>v:collate</B>* *<A NAME="collate-variable"></A><B>collate-variable</B>*
<A HREF="#v:collate">v:collate</A>	The current <A HREF="mbyte.html#locale">locale</A> setting for collation order of the runtime
		environment.  This allows Vim scripts to be aware of the
		current <A HREF="mbyte.html#locale">locale</A> encoding.  Technical: it's the value of
		LC_COLLATE.  When not using a <A HREF="mbyte.html#locale">locale</A> the value is &quot;<A HREF="change.html#C">C</A>&quot;.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.
		See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


					*<A NAME="v:cmdbang"></A><B>v:cmdbang</B>* *<A NAME="cmdbang-variable"></A><B>cmdbang-variable</B>*
<A HREF="#v:cmdbang">v:cmdbang</A>	Set like <A HREF="#v:cmdarg">v:cmdarg</A> for a file read/write command.  When a &quot;<A HREF="change.html#!">!</A>&quot;
		was used the value is 1, otherwise <A HREF="motion.html#it">it</A> is 0.  Note that this
		can only be used in autocommands.  For user commands |<A HREF="map.html#&lt;bang&gt;">&lt;bang&gt;</A>|
		can be used.


				*<A NAME="v:completed_item"></A><B>v:completed_item</B>* *<A NAME="completed_item-variable"></A><B>completed_item-variable</B>*
<A HREF="#v:completed_item">v:completed_item</A>
		<A HREF="#Dictionary">Dictionary</A> containing the most recent |<A HREF="insert.html#complete-items">complete-items</A>| after
		|<A HREF="autocmd.html#CompleteDone">CompleteDone</A>|.  Empty if the completion failed, or after
		leaving and re-entering insert mode.
		Note: Plugins can modify the value to emulate the builtin
		|<A HREF="autocmd.html#CompleteDone">CompleteDone</A>| event behavior.


					*<A NAME="v:count"></A><B>v:count</B>* *<A NAME="count-variable"></A><B>count-variable</B>*
<A HREF="#v:count">v:count</A>		The <A HREF="intro.html#count">count</A> given for the last <A HREF="intro.html#Normal">Normal</A> mode command.  Can be used
		to get the <A HREF="intro.html#count">count</A> before a <A HREF="map.html#mapping">mapping</A>.  Read-only.  Example:
<B>	:map _x :&lt;C-U&gt;echo "the count is " .. v:count&lt;CR&gt;</B>
 		Note: The &lt;C-U&gt; is required to remove the line range that you
		get when typing '<A HREF="cmdline.html#:">:</A>' after a <A HREF="intro.html#count">count</A>.
		When there are two counts, <A HREF="motion.html#as">as</A> in &quot;3d2w&quot;, they are multiplied,
		just like what happens in the command, &quot;d6w&quot; for the example.
		Also used for evaluating the <A HREF="options.html#'formatexpr'">'formatexpr'</A> option.


					*<A NAME="v:count1"></A><B>v:count1</B>* *<A NAME="count1-variable"></A><B>count1-variable</B>*
<A HREF="#v:count1">v:count1</A>	Just like &quot;<A HREF="#v:count">v:count</A>&quot;, but defaults to one when no <A HREF="intro.html#count">count</A> is
		used.


						*<A NAME="v:ctype"></A><B>v:ctype</B>* *<A NAME="ctype-variable"></A><B>ctype-variable</B>*
<A HREF="#v:ctype">v:ctype</A>		The current <A HREF="mbyte.html#locale">locale</A> setting for characters of the runtime
		environment.  This allows Vim scripts to be aware of the
		current <A HREF="mbyte.html#locale">locale</A> encoding.  Technical: it's the value of
		LC_CTYPE.  When not using a <A HREF="mbyte.html#locale">locale</A> the value is &quot;<A HREF="change.html#C">C</A>&quot;.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.
		See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


					*<A NAME="v:dying"></A><B>v:dying</B>* *<A NAME="dying-variable"></A><B>dying-variable</B>*
<A HREF="#v:dying">v:dying</A>		Normally zero.  When a deadly signal is caught it's set to
		one.  When multiple signals are caught the number increases.
		Can be used in an <A HREF="autocmd.html#autocommand">autocommand</A> to check if Vim didn't
		terminate normally. {only works on Unix}
		Example:
<B>	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif</B>
 		Note: if another deadly signal is caught when <A HREF="#v:dying">v:dying</A> is one,
		<A HREF="autocmd.html#VimLeave">VimLeave</A> autocommands will not be executed.


					*<A NAME="v:exiting"></A><B>v:exiting</B>* *<A NAME="exiting-variable"></A><B>exiting-variable</B>*
<A HREF="#v:exiting">v:exiting</A>	Exit code, or |<A HREF="#v:null">v:null</A>| before invoking the |<A HREF="autocmd.html#VimLeavePre">VimLeavePre</A>|
		and |<A HREF="autocmd.html#VimLeave">VimLeave</A>| autocmds.  See |<A HREF="editing.html#:q">:q</A>|, |<A HREF="editing.html#:x">:x</A>| and |<A HREF="quickfix.html#:cquit">:cquit</A>|.
		Example:
<B>			:au VimLeave * echo "Exit value is " .. v:exiting</B>

<B>					*v:echospace* *echospace-variable*</B>
<A HREF="#v:echospace">v:echospace</A>	<A HREF="#Number">Number</A> of screen cells that can be used for an `:echo` message
		in the last screen line before causing the |<A HREF="message.html#hit-enter-prompt">hit-enter-prompt</A>|.
		Depends on <A HREF="options.html#'showcmd'">'showcmd'</A>, <A HREF="options.html#'ruler'">'ruler'</A> and <A HREF="options.html#'columns'">'columns'</A>.  You need to
		check <A HREF="options.html#'cmdheight'">'cmdheight'</A> for whether there are full-width lines
		available above the last line.


					*<A NAME="v:errmsg"></A><B>v:errmsg</B>* *<A NAME="errmsg-variable"></A><B>errmsg-variable</B>*
<A HREF="#v:errmsg">v:errmsg</A>	Last given error message.
		Modifiable (can be set).
		Example:
<B>	:let v:errmsg = ""</B>
<B>	:silent! next</B>
<B>	:if v:errmsg != ""</B>
<B>	:  ... handle error</B>
 

				*<A NAME="v:errors"></A><B>v:errors</B>* *<A NAME="errors-variable"></A><B>errors-variable</B>* *<A NAME="assert-return"></A><B>assert-return</B>*
<A HREF="#v:errors">v:errors</A>	Errors found by assert <A HREF="#functions">functions</A>, such as |<A HREF="testing.html#assert_true()">assert_true()</A>|.
		This is a <A HREF="#list">list</A> of strings.
		The assert <A HREF="#functions">functions</A> append an item when an assert fails.
		The return value indicates this: a one is returned if an item
		was added to <A HREF="#v:errors">v:errors</A>, otherwise zero is returned.
		To remove old results make <A HREF="motion.html#it">it</A> empty:
<B>	:let v:errors = []</B>
 		If <A HREF="#v:errors">v:errors</A> is set to anything but a <A HREF="#list">list</A> <A HREF="motion.html#it">it</A> is made an empty
		<A HREF="#list">list</A> by the assert function.


					*<A NAME="v:event"></A><B>v:event</B>* *<A NAME="event-variable"></A><B>event-variable</B>*
<A HREF="#v:event">v:event</A>		<A HREF="#Dictionary">Dictionary</A> of event data for the current |<A HREF="autocmd.html#autocommand">autocommand</A>|.  Valid
		only during the event lifetime; storing or passing <A HREF="#v:event">v:event</A> is
		invalid!  Copy <A HREF="motion.html#it">it</A> instead:
<B>			au TextYankPost * let g:foo = deepcopy(v:event)</B>
 		Keys vary by event; see the documentation for the specific
		event, e.g. |<A HREF="autocmd.html#DirChanged">DirChanged</A>| or |<A HREF="autocmd.html#TextYankPost">TextYankPost</A>|.
<B><FONT COLOR="PURPLE">			KEY		DESCRIPTION </FONT></B>
			abort		Whether the event triggered during
					an aborting condition (e.g. |<A HREF="cmdline.html#c_Esc">c_Esc</A>| or
					|<A HREF="cmdline.html#c_CTRL-C">c_CTRL-C</A>| for |<A HREF="autocmd.html#CmdlineLeave">CmdlineLeave</A>|).
			chan		|<A HREF="channel.html#channel-id">channel-id</A>| or 0 for &quot;internal&quot;.
			cmdlevel	Level of <A HREF="cmdline.html#cmdline">cmdline</A>.
			cmdtype		Type of cmdline, |<A HREF="cmdline.html#cmdline-char">cmdline-char</A>|.
			cwd		Current working directory.
			inclusive	Motion is |<A HREF="motion.html#inclusive">inclusive</A>|, else <A HREF="motion.html#exclusive">exclusive</A>.
			scope		Event-specific scope name.
			operator	Current |<A HREF="motion.html#operator">operator</A>|.  Also set for <A HREF="intro.html#Ex">Ex</A>
					commands (unlike |<A HREF="#v:operator">v:operator</A>|). For
					example if |<A HREF="autocmd.html#TextYankPost">TextYankPost</A>| is triggered
					by the |<A HREF="change.html#:yank">:yank</A>| <A HREF="intro.html#Ex">Ex</A> command then
					`v:event.operator` is &quot;<A HREF="change.html#y">y</A>&quot;.
			regcontents	Text stored in the <A HREF="intro.html#register">register</A> <A HREF="motion.html#as">as</A> a
					|readfile()|-style <A HREF="#list">list</A> of lines.
			regname		Requested <A HREF="intro.html#register">register</A> (e.g &quot;<A HREF="change.html#x">x</A>&quot; for &quot;xyy)
					or the empty <A HREF="#string">string</A> for an unnamed
					operation.
			regtype		Type of <A HREF="intro.html#register">register</A> <A HREF="motion.html#as">as</A> returned by
					|<A HREF="builtin.html#getregtype()">getregtype()</A>|.
			visual		Selection is visual (as opposed to,
					e.g., via motion).
			completed_item    Current selected complete item on
					|<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|, Is `{}` when no complete
					item selected.
			height 		Height of popup menu on |<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|
			width   	width of popup menu on |<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|
			row  	 	Row <A HREF="intro.html#count">count</A> of popup menu on |<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|,
					relative to screen.
			col  	 	Col <A HREF="intro.html#count">count</A> of popup menu on |<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|,
					relative to screen.
			size 		Total number of completion items on
					|<A HREF="autocmd.html#CompleteChanged">CompleteChanged</A>|.
			scrollbar 	Is |<A HREF="#v:true">v:true</A>| if popup menu have scrollbar, or
					|<A HREF="#v:false">v:false</A>| if not.
			changed_window 	Is |<A HREF="#v:true">v:true</A>| if the the event fired
					while <A HREF="change.html#changing">changing</A> <A HREF="windows.html#window">window</A> (or <A HREF="intro.html#tab">tab</A>) on |<A HREF="autocmd.html#DirChanged">DirChanged</A>|.
			status		Job status or exit code, -1 means &quot;unknown&quot;. |<A HREF="autocmd.html#TermClose">TermClose</A>|


					*<A NAME="v:exception"></A><B>v:exception</B>* *<A NAME="exception-variable"></A><B>exception-variable</B>*
<A HREF="#v:exception">v:exception</A>	The value of the exception most recently caught and not
		finished.  See also |<A HREF="#v:throwpoint">v:throwpoint</A>| and |<A HREF="#throw-variables">throw-variables</A>|.
		Example:
<B>	:try</B>
<B>	:  throw "oops"</B>
<B>	:catch /.*/</B>
<B>	:  echo "caught " .. v:exception</B>
<B>	:endtry</B>
 		Output: &quot;caught oops&quot;.


					*<A NAME="v:false"></A><B>v:false</B>* *<A NAME="false-variable"></A><B>false-variable</B>*
<A HREF="#v:false">v:false</A>		Special value used to put &quot;false&quot; in JSON and msgpack.  See
		|<A HREF="builtin.html#json_encode()">json_encode()</A>|.  This value is converted to &quot;<A HREF="#v:false">v:false</A>&quot; when used
		<A HREF="motion.html#as">as</A> a <A HREF="#String">String</A> (e.g. in |<A HREF="#expr5">expr5</A>| with <A HREF="#string">string</A> concatenation
		<A HREF="motion.html#operator">operator</A>) and to zero when used <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A> (e.g. in |<A HREF="#expr5">expr5</A>|
		or |<A HREF="#expr7">expr7</A>| when used with numeric operators). Read-only.


					*<A NAME="v:fcs_reason"></A><B>v:fcs_reason</B>* *<A NAME="fcs_reason-variable"></A><B>fcs_reason-variable</B>*
<A HREF="#v:fcs_reason">v:fcs_reason</A>	The reason why the |<A HREF="autocmd.html#FileChangedShell">FileChangedShell</A>| event was triggered.
		Can be used in an <A HREF="autocmd.html#autocommand">autocommand</A> to decide what to <A HREF="diff.html#do">do</A> and/or what
		to set <A HREF="#v:fcs_choice">v:fcs_choice</A> to.  Possible values:
			deleted		file no longer exists
			conflict	file contents, mode or <A HREF="editing.html#timestamp">timestamp</A> was
					changed and buffer is modified
			changed		file contents has changed
			mode		mode of file changed
			time		only file <A HREF="editing.html#timestamp">timestamp</A> changed


					*<A NAME="v:fcs_choice"></A><B>v:fcs_choice</B>* *<A NAME="fcs_choice-variable"></A><B>fcs_choice-variable</B>*
<A HREF="#v:fcs_choice">v:fcs_choice</A>	What should happen after a |<A HREF="autocmd.html#FileChangedShell">FileChangedShell</A>| event was
		triggered.  Can be used in an <A HREF="autocmd.html#autocommand">autocommand</A> to tell Vim what to
		<A HREF="diff.html#do">do</A> with the affected buffer:
			<A HREF="editing.html#reload">reload</A>		Reload the buffer (does not work if
					the file was deleted).
			edit		Reload the buffer and detect the
					values for <A HREF="options.html#options">options</A> such <A HREF="motion.html#as">as</A>
					<A HREF="options.html#'fileformat'">'fileformat'</A>, <A HREF="options.html#'fileencoding'">'fileencoding'</A>, <A HREF="options.html#'binary'">'binary'</A>
					(does not work if the file was
					deleted).
			ask		Ask the user what to <A HREF="diff.html#do">do</A>, <A HREF="motion.html#as">as</A> if there
					was no <A HREF="autocmd.html#autocommand">autocommand</A>.  Except that when
					only the <A HREF="editing.html#timestamp">timestamp</A> changed nothing
					will happen.
			&lt;empty&gt;		Nothing, the <A HREF="autocmd.html#autocommand">autocommand</A> should <A HREF="diff.html#do">do</A>
					everything that needs to be done.
		The default is empty.  If another (invalid) value is used then
		Vim behaves like <A HREF="motion.html#it">it</A> is empty, there is no warning message.


					*<A NAME="v:fname"></A><B>v:fname</B>* *<A NAME="fname-variable"></A><B>fname-variable</B>*
<A HREF="#v:fname">v:fname</A>		When evaluating <A HREF="options.html#'includeexpr'">'includeexpr'</A>: the file name that was
		detected.  Empty otherwise.


					*<A NAME="v:fname_in"></A><B>v:fname_in</B>* *<A NAME="fname_in-variable"></A><B>fname_in-variable</B>*
<A HREF="#v:fname_in">v:fname_in</A>	The name of the input file.  Valid while evaluating:
<B><FONT COLOR="PURPLE">			option		used for </FONT></B>
			<A HREF="options.html#'charconvert'">'charconvert'</A>	file to be converted
			<A HREF="options.html#'diffexpr'">'diffexpr'</A>	original file
			<A HREF="options.html#'patchexpr'">'patchexpr'</A>	original file
			<A HREF="options.html#'printexpr'">'printexpr'</A>	file to be printed
		And set to the swap file name for |<A HREF="autocmd.html#SwapExists">SwapExists</A>|.


					*<A NAME="v:fname_out"></A><B>v:fname_out</B>* *<A NAME="fname_out-variable"></A><B>fname_out-variable</B>*
<A HREF="#v:fname_out">v:fname_out</A>	The name of the output file.  Only valid while
		evaluating:
<B><FONT COLOR="PURPLE">			option		used for </FONT></B>
			<A HREF="options.html#'charconvert'">'charconvert'</A>	resulting converted file (*)
			<A HREF="options.html#'diffexpr'">'diffexpr'</A>	output of <A HREF="diff.html#diff">diff</A>
			<A HREF="options.html#'patchexpr'">'patchexpr'</A>	resulting patched file
		(*) When doing conversion for a write command (e.g., &quot;<A HREF="editing.html#:w">:w</A>
		file&quot;) <A HREF="motion.html#it">it</A> will be equal to <A HREF="#v:fname_in">v:fname_in</A>.  When doing conversion
		for a read command (e.g., &quot;<A HREF="editing.html#:e">:e</A> file&quot;) <A HREF="motion.html#it">it</A> will be a temporary
		file and different from <A HREF="#v:fname_in">v:fname_in</A>.


					*<A NAME="v:fname_new"></A><B>v:fname_new</B>* *<A NAME="fname_new-variable"></A><B>fname_new-variable</B>*
<A HREF="#v:fname_new">v:fname_new</A>	The name of the new version of the file.  Only valid while
		evaluating <A HREF="options.html#'diffexpr'">'diffexpr'</A>.


					*<A NAME="v:fname_diff"></A><B>v:fname_diff</B>* *<A NAME="fname_diff-variable"></A><B>fname_diff-variable</B>*
<A HREF="#v:fname_diff">v:fname_diff</A>	The name of the <A HREF="diff.html#diff">diff</A> (patch) file.  Only valid while
		evaluating <A HREF="options.html#'patchexpr'">'patchexpr'</A>.


					*<A NAME="v:folddashes"></A><B>v:folddashes</B>* *<A NAME="folddashes-variable"></A><B>folddashes-variable</B>*
<A HREF="#v:folddashes">v:folddashes</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: dashes representing foldlevel of a closed
		fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:foldlevel"></A><B>v:foldlevel</B>* *<A NAME="foldlevel-variable"></A><B>foldlevel-variable</B>*
<A HREF="#v:foldlevel">v:foldlevel</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: foldlevel of closed fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:foldend"></A><B>v:foldend</B>* *<A NAME="foldend-variable"></A><B>foldend-variable</B>*
<A HREF="#v:foldend">v:foldend</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: last line of closed fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:foldstart"></A><B>v:foldstart</B>* *<A NAME="foldstart-variable"></A><B>foldstart-variable</B>*
<A HREF="#v:foldstart">v:foldstart</A>	Used for <A HREF="options.html#'foldtext'">'foldtext'</A>: first line of closed fold.
		Read-only in the |<A HREF="#sandbox">sandbox</A>|. |<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|


					*<A NAME="v:hlsearch"></A><B>v:hlsearch</B>* *<A NAME="hlsearch-variable"></A><B>hlsearch-variable</B>*
<A HREF="#v:hlsearch">v:hlsearch</A>	Variable that indicates whether search highlighting is on.
		Setting <A HREF="motion.html#it">it</A> makes sense only if <A HREF="options.html#'hlsearch'">'hlsearch'</A> is enabled. Setting
		this variable to zero acts like the |<A HREF="pattern.html#:nohlsearch">:nohlsearch</A>| command,
		setting <A HREF="motion.html#it">it</A> to one acts like
<B>			let &amp;hlsearch = &amp;hlsearch</B>
 		Note that the value is restored when returning from a
		function. |<A HREF="userfunc.html#function-search-undo">function-search-undo</A>|.


					*<A NAME="v:insertmode"></A><B>v:insertmode</B>* *<A NAME="insertmode-variable"></A><B>insertmode-variable</B>*
<A HREF="#v:insertmode">v:insertmode</A>	Used for the |<A HREF="autocmd.html#InsertEnter">InsertEnter</A>| and |<A HREF="autocmd.html#InsertChange">InsertChange</A>| <A HREF="autocmd.html#autocommand">autocommand</A>
		<A HREF="autocmd.html#events">events</A>.  Values:
			<A HREF="insert.html#i">i</A>	<A HREF="insert.html#Insert">Insert</A> mode
			<A HREF="change.html#r">r</A>	<A HREF="insert.html#Replace">Replace</A> mode
			<A HREF="visual.html#v">v</A>	Virtual <A HREF="insert.html#Replace">Replace</A> mode


						*<A NAME="v:key"></A><B>v:key</B>* *<A NAME="key-variable"></A><B>key-variable</B>*
<A HREF="#v:key">v:key</A>		Key of the current item of a |<A HREF="#Dictionary">Dictionary</A>|.  Only valid while
		evaluating the <A HREF="#expression">expression</A> used with |<A HREF="builtin.html#map()">map()</A>| and |<A HREF="builtin.html#filter()">filter()</A>|.
		Read-only.


						*<A NAME="v:lang"></A><B>v:lang</B>* *<A NAME="lang-variable"></A><B>lang-variable</B>*
<A HREF="#v:lang">v:lang</A>		The current <A HREF="mbyte.html#locale">locale</A> setting for <A HREF="message.html#messages">messages</A> of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_MESSAGES.
		The value is system dependent.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.
		It can be different from |<A HREF="#v:ctype">v:ctype</A>| when <A HREF="message.html#messages">messages</A> are desired
		in a different language than what is used for character
		encoding.  See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


						*<A NAME="v:lc_time"></A><B>v:lc_time</B>* *<A NAME="lc_time-variable"></A><B>lc_time-variable</B>*
<A HREF="#v:lc_time">v:lc_time</A>	The current <A HREF="mbyte.html#locale">locale</A> setting for time <A HREF="message.html#messages">messages</A> of the runtime
		environment.  This allows Vim scripts to be aware of the
		current language.  Technical: it's the value of LC_TIME.
		This variable can not be set directly, use the |<A HREF="mlang.html#:language">:language</A>|
		command.  See |<A HREF="mlang.html#multi-lang">multi-lang</A>|.


						*<A NAME="v:lnum"></A><B>v:lnum</B>* *<A NAME="lnum-variable"></A><B>lnum-variable</B>*
<A HREF="#v:lnum">v:lnum</A>		Line number for the <A HREF="options.html#'foldexpr'">'foldexpr'</A> |<A HREF="fold.html#fold-expr">fold-expr</A>|, <A HREF="options.html#'formatexpr'">'formatexpr'</A> and
		<A HREF="options.html#'indentexpr'">'indentexpr'</A> expressions, <A HREF="intro.html#tab">tab</A> page number for <A HREF="options.html#'guitablabel'">'guitablabel'</A>
		and <A HREF="options.html#'guitabtooltip'">'guitabtooltip'</A>.  Only valid while one of these
		expressions is being evaluated.  Read-only when in the
		|<A HREF="#sandbox">sandbox</A>|.


						*<A NAME="v:lua"></A><B>v:lua</B>* *<A NAME="lua-variable"></A><B>lua-variable</B>*
<A HREF="#v:lua">v:lua</A>		Prefix for calling <A HREF="lua.html#Lua">Lua</A> <A HREF="#functions">functions</A> from expressions.
		See |<A HREF="lua.html#v:lua-call">v:lua-call</A>| for more information.


					*<A NAME="v:mouse_win"></A><B>v:mouse_win</B>* *<A NAME="mouse_win-variable"></A><B>mouse_win-variable</B>*
<A HREF="#v:mouse_win">v:mouse_win</A>	Window number for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		First <A HREF="windows.html#window">window</A> has number 1, like with |<A HREF="builtin.html#winnr()">winnr()</A>|.  The value is
		zero when there was no mouse button click.


					*<A NAME="v:mouse_winid"></A><B>v:mouse_winid</B>* *<A NAME="mouse_winid-variable"></A><B>mouse_winid-variable</B>*
<A HREF="#v:mouse_winid">v:mouse_winid</A>	|<A HREF="windows.html#window-ID">window-ID</A>| for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		The value is zero when there was no mouse button click.


					*<A NAME="v:mouse_lnum"></A><B>v:mouse_lnum</B>* *<A NAME="mouse_lnum-variable"></A><B>mouse_lnum-variable</B>*
<A HREF="#v:mouse_lnum">v:mouse_lnum</A>	Line number for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		This is the text line number, not the screen line number.  The
		value is zero when there was no mouse button click.


					*<A NAME="v:mouse_col"></A><B>v:mouse_col</B>* *<A NAME="mouse_col-variable"></A><B>mouse_col-variable</B>*
<A HREF="#v:mouse_col">v:mouse_col</A>	Column number for a mouse click obtained with |<A HREF="builtin.html#getchar()">getchar()</A>|.
		This is the screen column number, like with |<A HREF="builtin.html#virtcol()">virtcol()</A>|.  The
		value is zero when there was no mouse button click.


				*<A NAME="v:msgpack_types"></A><B>v:msgpack_types</B>* *<A NAME="msgpack_types-variable"></A><B>msgpack_types-variable</B>*
<A HREF="#v:msgpack_types">v:msgpack_types</A>	<A HREF="#Dictionary">Dictionary</A> containing msgpack types used by |<A HREF="builtin.html#msgpackparse()">msgpackparse()</A>|
		and |<A HREF="builtin.html#msgpackdump()">msgpackdump()</A>|. All types inside dictionary are fixed
		(not editable) empty lists. To check whether some <A HREF="#list">list</A> is one
		of msgpack types, use |<A HREF="motion.html#is">is</A>| <A HREF="motion.html#operator">operator</A>.


					*<A NAME="v:null"></A><B>v:null</B>* *<A NAME="null-variable"></A><B>null-variable</B>*
<A HREF="#v:null">v:null</A>		Special value used to put &quot;null&quot; in JSON and NIL in msgpack.
		See |<A HREF="builtin.html#json_encode()">json_encode()</A>|.  This value is converted to &quot;<A HREF="#v:null">v:null</A>&quot; when
		used <A HREF="motion.html#as">as</A> a <A HREF="#String">String</A> (e.g. in |<A HREF="#expr5">expr5</A>| with <A HREF="#string">string</A> concatenation
		<A HREF="motion.html#operator">operator</A>) and to zero when used <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A> (e.g. in |<A HREF="#expr5">expr5</A>|
		or |<A HREF="#expr7">expr7</A>| when used with numeric operators). Read-only.
		In some places `v:null` can be used for a <A HREF="#List">List</A>, <A HREF="#Dict">Dict</A>, etc.
		that is not set.  That is slightly different than an empty
		<A HREF="#List">List</A>, <A HREF="#Dict">Dict</A>, etc.


					*<A NAME="v:numbermax"></A><B>v:numbermax</B>* *<A NAME="numbermax-variable"></A><B>numbermax-variable</B>*
<A HREF="#v:numbermax">v:numbermax</A>	Maximum value of a number.


					*<A NAME="v:numbermin"></A><B>v:numbermin</B>* *<A NAME="numbermin-variable"></A><B>numbermin-variable</B>*
<A HREF="#v:numbermin">v:numbermin</A>	Minimum value of a number (negative).


					*<A NAME="v:numbersize"></A><B>v:numbersize</B>* *<A NAME="numbersize-variable"></A><B>numbersize-variable</B>*
<A HREF="#v:numbersize">v:numbersize</A>	<A HREF="#Number">Number</A> of bits in a <A HREF="#Number">Number</A>.  This is normally 64, but on some
		systems <A HREF="motion.html#it">it</A> may be 32.


					*<A NAME="v:oldfiles"></A><B>v:oldfiles</B>* *<A NAME="oldfiles-variable"></A><B>oldfiles-variable</B>*
<A HREF="#v:oldfiles">v:oldfiles</A>	<A HREF="#List">List</A> of file names that is loaded from the |<A HREF="starting.html#shada">shada</A>| file on
		<A HREF="starting.html#startup">startup</A>.  These are the files that Vim remembers marks for.
		The length of the <A HREF="#List">List</A> is limited by the '' argument of the
		<A HREF="options.html#'shada'">'shada'</A> option (default is 100).
		When the |<A HREF="starting.html#shada">shada</A>| file is not used the <A HREF="#List">List</A> is empty.
		Also see |<A HREF="starting.html#:oldfiles">:oldfiles</A>| and |<A HREF="cmdline.html#c_#&lt;">c_#&lt;</A>|.
		The <A HREF="#List">List</A> can be modified, but this has no effect on what is
		stored in the |<A HREF="starting.html#shada">shada</A>| file later.  If you use values other
		than <A HREF="#String">String</A> this will cause trouble.


						    *<A NAME="v:option_new"></A><B>v:option_new</B>*
<A HREF="#v:option_new">v:option_new</A>    New value of the option. Valid while executing an |<A HREF="autocmd.html#OptionSet">OptionSet</A>|
		<A HREF="autocmd.html#autocommand">autocommand</A>.

						    *<A NAME="v:option_old"></A><B>v:option_old</B>*
<A HREF="#v:option_old">v:option_old</A>    Old value of the option. Valid while executing an |<A HREF="autocmd.html#OptionSet">OptionSet</A>|
		<A HREF="autocmd.html#autocommand">autocommand</A>. Depending on the command used for setting and the
		kind of option this is either the local old value or the
		global old value.

						    *<A NAME="v:option_oldlocal"></A><B>v:option_oldlocal</B>*
<A HREF="#v:option_oldlocal">v:option_oldlocal</A>
		Old local value of the option. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.

						    *<A NAME="v:option_oldglobal"></A><B>v:option_oldglobal</B>*
<A HREF="#v:option_oldglobal">v:option_oldglobal</A>
		Old global value of the option. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.

						    *<A NAME="v:option_type"></A><B>v:option_type</B>*
<A HREF="#v:option_type">v:option_type</A>   Scope of the set command. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>. Can be either &quot;global&quot; or &quot;local&quot;

						    *<A NAME="v:option_command"></A><B>v:option_command</B>*
<A HREF="#v:option_command">v:option_command</A>
		Command used to set the option. Valid while executing an
		|<A HREF="autocmd.html#OptionSet">OptionSet</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.
<B><FONT COLOR="PURPLE">			value		option was set via   </FONT></B>
			&quot;setlocal&quot;	|<A HREF="options.html#:setlocal">:setlocal</A>| or &quot;<A HREF="#:let">:let</A> l:xxx&quot;
			&quot;setglobal&quot;	|<A HREF="options.html#:setglobal">:setglobal</A>| or &quot;<A HREF="#:let">:let</A> g:xxx&quot;
			&quot;set&quot;		|<A HREF="options.html#:set">:set</A>| or |<A HREF="#:let">:let</A>|
			&quot;modeline&quot;	|<A HREF="options.html#modeline">modeline</A>|

					*<A NAME="v:operator"></A><B>v:operator</B>* *<A NAME="operator-variable"></A><B>operator-variable</B>*
<A HREF="#v:operator">v:operator</A>	The last <A HREF="motion.html#operator">operator</A> given in <A HREF="intro.html#Normal">Normal</A> mode.  This is a single
		character except for commands starting with &lt;g&gt; or &lt;z&gt;,
		in which <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> is two characters.  Best used alongside
		|<A HREF="#v:prevcount">v:prevcount</A>| and |<A HREF="#v:register">v:register</A>|.  Useful if you want to cancel
		<A HREF="intro.html#Operator-pending">Operator-pending</A> mode and then use the <A HREF="motion.html#operator">operator</A>, e.g.:
<B>			:omap O &lt;Esc&gt;:call MyMotion(v:operator)&lt;CR&gt;</B>
 		The value remains set until another <A HREF="motion.html#operator">operator</A> is entered, thus
		don't expect <A HREF="motion.html#it">it</A> to be empty.
		<A HREF="#v:operator">v:operator</A> is not set for |<A HREF="change.html#:delete">:delete</A>|, |<A HREF="change.html#:yank">:yank</A>| or other <A HREF="intro.html#Ex">Ex</A>
		commands.
		Read-only.


					*<A NAME="v:prevcount"></A><B>v:prevcount</B>* *<A NAME="prevcount-variable"></A><B>prevcount-variable</B>*
<A HREF="#v:prevcount">v:prevcount</A>	The <A HREF="intro.html#count">count</A> given for the last but one <A HREF="intro.html#Normal">Normal</A> mode command.
		This is the <A HREF="#v:count">v:count</A> value of the previous command.  Useful if
		you want to cancel <A HREF="visual.html#Visual">Visual</A> or <A HREF="intro.html#Operator-pending">Operator-pending</A> mode and then
		use the <A HREF="intro.html#count">count</A>, e.g.:
<B>			:vmap % &lt;Esc&gt;:call MyFilter(v:prevcount)&lt;CR&gt;</B>
 		Read-only.


					*<A NAME="v:profiling"></A><B>v:profiling</B>* *<A NAME="profiling-variable"></A><B>profiling-variable</B>*
<A HREF="#v:profiling">v:profiling</A>	Normally zero.  Set to one after using &quot;<A HREF="repeat.html#:profile">:profile</A> start&quot;.
		See |<A HREF="repeat.html#profiling">profiling</A>|.


					*<A NAME="v:progname"></A><B>v:progname</B>* *<A NAME="progname-variable"></A><B>progname-variable</B>*
<A HREF="#v:progname">v:progname</A>	The name by which Nvim was invoked (with path removed).
		Read-only.


					*<A NAME="v:progpath"></A><B>v:progpath</B>* *<A NAME="progpath-variable"></A><B>progpath-variable</B>*
<A HREF="#v:progpath">v:progpath</A>	Absolute path to the current running Nvim.
		Read-only.


					*<A NAME="v:register"></A><B>v:register</B>* *<A NAME="register-variable"></A><B>register-variable</B>*
<A HREF="#v:register">v:register</A>	The name of the <A HREF="intro.html#register">register</A> in effect for the current normal mode
		command (regardless of whether that command actually used a
		<A HREF="intro.html#register">register</A>).  Or for the currently executing normal mode <A HREF="map.html#mapping">mapping</A>
		(use this in custom commands that take a <A HREF="intro.html#register">register</A>).
		If none is supplied <A HREF="motion.html#it">it</A> is the default <A HREF="intro.html#register">register</A> &#39;&#34;'', unless
		<A HREF="options.html#'clipboard'">'clipboard'</A> contains &quot;unnamed&quot; or &quot;unnamedplus&quot;, then <A HREF="motion.html#it">it</A> is
		'*' or '<A HREF="motion.html#+">+</A>'.
		Also see |<A HREF="builtin.html#getreg()">getreg()</A>| and |<A HREF="builtin.html#setreg()">setreg()</A>|


					*<A NAME="v:scrollstart"></A><B>v:scrollstart</B>* *<A NAME="scrollstart-variable"></A><B>scrollstart-variable</B>*
<A HREF="#v:scrollstart">v:scrollstart</A>	<A HREF="#String">String</A> describing the <A HREF="usr_41.html#script">script</A> or function that caused the
		screen to scroll up.  It's only set when <A HREF="motion.html#it">it</A> is empty, thus the
		first reason is remembered.  It is set to &quot;Unknown&quot; for a
		typed command.
		This can be used to find out why your <A HREF="usr_41.html#script">script</A> causes the
		<A HREF="message.html#hit-enter">hit-enter</A> prompt.


					*<A NAME="v:servername"></A><B>v:servername</B>* *<A NAME="servername-variable"></A><B>servername-variable</B>*
<A HREF="#v:servername">v:servername</A>	Primary listen-address of the current Nvim instance, the first
		item returned by |<A HREF="builtin.html#serverlist()">serverlist()</A>|.  Can be set by |<A HREF="starting.html#--listen">--listen</A>| or
		|<A HREF="deprecated.html#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>| (deprecated) at <A HREF="starting.html#startup">startup</A>.
		See also |<A HREF="builtin.html#serverstart()">serverstart()</A>| |<A HREF="builtin.html#serverstop()">serverstop()</A>|.
		Read-only.


								       *<A NAME="$NVIM"></A><B>$NVIM</B>*
		<A HREF="#$NVIM">$NVIM</A> is set by |<A HREF="nvim_terminal_emulator.html#terminal">terminal</A>| and |<A HREF="builtin.html#jobstart()">jobstart()</A>|, and is thus
		a hint that the current environment is a subprocess of Nvim.
		Example:
<B>		    if $NVIM</B>
<B>		      echo nvim_get_chan_info(v:parent)</B>
<B>		    endif</B>

 		Note the contents of <A HREF="#$NVIM">$NVIM</A> may change in the future.


<A HREF="#v:searchforward">v:searchforward</A>			*<A NAME="v:searchforward"></A><B>v:searchforward</B>* *<A NAME="searchforward-variable"></A><B>searchforward-variable</B>*
		Search direction:  1 after a forward search, 0 after a
		backward search.  It is reset to forward when directly setting
		the last search <A HREF="pattern.html#pattern">pattern</A>, see |<A HREF="change.html#quote/">quote/</A>|.
		Note that the value is restored when returning from a
		function. |<A HREF="userfunc.html#function-search-undo">function-search-undo</A>|.
		Read-write.


					*<A NAME="v:shell_error"></A><B>v:shell_error</B>* *<A NAME="shell_error-variable"></A><B>shell_error-variable</B>*
<A HREF="#v:shell_error">v:shell_error</A>	Result of the last shell command.  When non-zero, the last
		shell command had an error.  When zero, there was no problem.
		This only works when the shell returns the error code to Vim.
		The value -1 is often used when the command could not be
		executed.  Read-only.
		Example:
<B>	:!mv foo bar</B>
<B>	:if v:shell_error</B>
<B>	:  echo 'could not rename "foo" to "bar"!'</B>
<B>	:endif</B>
 

					*<A NAME="v:statusmsg"></A><B>v:statusmsg</B>* *<A NAME="statusmsg-variable"></A><B>statusmsg-variable</B>*
<A HREF="#v:statusmsg">v:statusmsg</A>	Last given status message.
		Modifiable (can be set).


					*<A NAME="v:stderr"></A><B>v:stderr</B>* *<A NAME="stderr-variable"></A><B>stderr-variable</B>*
<A HREF="#v:stderr">v:stderr</A>	|<A HREF="channel.html#channel-id">channel-id</A>| corresponding to stderr. The value is always 2;
		use this variable to make your code more descriptive.
		Unlike stdin and stdout (see |<A HREF="builtin.html#stdioopen()">stdioopen()</A>|), stderr is always
		open for <A HREF="editing.html#writing">writing</A>. Example:
<B>			:call chansend(v:stderr, "error: toaster empty\n")</B>
 

					*<A NAME="v:swapname"></A><B>v:swapname</B>* *<A NAME="swapname-variable"></A><B>swapname-variable</B>*
<A HREF="#v:swapname">v:swapname</A>	Only valid when executing |<A HREF="autocmd.html#SwapExists">SwapExists</A>| autocommands: Name of
		the swap file found.  Read-only.


					*<A NAME="v:swapchoice"></A><B>v:swapchoice</B>* *<A NAME="swapchoice-variable"></A><B>swapchoice-variable</B>*
<A HREF="#v:swapchoice">v:swapchoice</A>	|<A HREF="autocmd.html#SwapExists">SwapExists</A>| autocommands can set this to the selected choice
		for handling an existing swap file:
			'<A HREF="insert.html#o">o</A>'	Open read-only
			'<A HREF="motion.html#e">e</A>'	Edit anyway
			'<A HREF="change.html#r">r</A>'	Recover
			'<A HREF="change.html#d">d</A>'	Delete swapfile
			'<A HREF="repeat.html#q">q</A>'	Quit
			'<A HREF="insert.html#a">a</A>'	Abort
		The value should be a single-character <A HREF="#string">string</A>.  An empty value
		results in the user being asked, <A HREF="motion.html#as">as</A> would happen when there is
		no <A HREF="autocmd.html#SwapExists">SwapExists</A> <A HREF="autocmd.html#autocommand">autocommand</A>.  The default is empty.


					*<A NAME="v:swapcommand"></A><B>v:swapcommand</B>* *<A NAME="swapcommand-variable"></A><B>swapcommand-variable</B>*
<A HREF="#v:swapcommand">v:swapcommand</A>	<A HREF="intro.html#Normal">Normal</A> mode command to be executed after a file has been
		opened.  Can be used for a |<A HREF="autocmd.html#SwapExists">SwapExists</A>| <A HREF="autocmd.html#autocommand">autocommand</A> to have
		another Vim open the file and jump to the right place.  For
		example, when jumping to a <A HREF="tagsrch.html#tag">tag</A> the value is &quot;<A HREF="tagsrch.html#:tag">:tag</A> tagname\r&quot;.
		For &quot;<A HREF="editing.html#:edit">:edit</A> <A HREF="editing.html#+cmd">+cmd</A> file&quot; the value is &quot;:cmd\r&quot;.


				*<A NAME="v:t_TYPE"></A><B>v:t_TYPE</B>* *<A NAME="v:t_bool"></A><B>v:t_bool</B>* *<A NAME="t_bool-variable"></A><B>t_bool-variable</B>*
<A HREF="#v:t_bool">v:t_bool</A>	Value of |<A HREF="#Boolean">Boolean</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_dict"></A><B>v:t_dict</B>* *<A NAME="t_dict-variable"></A><B>t_dict-variable</B>*
<A HREF="#v:t_dict">v:t_dict</A>	Value of |<A HREF="#Dictionary">Dictionary</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_float"></A><B>v:t_float</B>* *<A NAME="t_float-variable"></A><B>t_float-variable</B>*
<A HREF="#v:t_float">v:t_float</A>	Value of |<A HREF="#Float">Float</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_func"></A><B>v:t_func</B>* *<A NAME="t_func-variable"></A><B>t_func-variable</B>*
<A HREF="#v:t_func">v:t_func</A>	Value of |<A HREF="#Funcref">Funcref</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_list"></A><B>v:t_list</B>* *<A NAME="t_list-variable"></A><B>t_list-variable</B>*
<A HREF="#v:t_list">v:t_list</A>	Value of |<A HREF="#List">List</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_number"></A><B>v:t_number</B>* *<A NAME="t_number-variable"></A><B>t_number-variable</B>*
<A HREF="#v:t_number">v:t_number</A>	Value of |<A HREF="#Number">Number</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_string"></A><B>v:t_string</B>* *<A NAME="t_string-variable"></A><B>t_string-variable</B>*
<A HREF="#v:t_string">v:t_string</A>	Value of |<A HREF="#String">String</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|

					*<A NAME="v:t_blob"></A><B>v:t_blob</B>* *<A NAME="t_blob-variable"></A><B>t_blob-variable</B>*
<A HREF="#v:t_blob">v:t_blob</A>	Value of |<A HREF="#Blob">Blob</A>| type.  Read-only.  See: |<A HREF="builtin.html#type()">type()</A>|


				*<A NAME="v:termresponse"></A><B>v:termresponse</B>* *<A NAME="termresponse-variable"></A><B>termresponse-variable</B>*
<A HREF="#v:termresponse">v:termresponse</A>	The <A HREF="intro.html#escape">escape</A> sequence returned by the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> for the DA
		(request primary device attributes) <A HREF="intro.html#control">control</A> sequence.  It is
		set when Vim receives an <A HREF="intro.html#escape">escape</A> sequence that starts with ESC
		[ or CSI and ends in a '<A HREF="change.html#c">c</A>', with only digits, '<A HREF="motion.html#;">;</A>' and '<A HREF="repeat.html#.">.</A>' in
		between.
		When this option is set, the <A HREF="autocmd.html#TermResponse">TermResponse</A> <A HREF="autocmd.html#autocommand">autocommand</A> event is
		fired, so that you can react to the response from the
		<A HREF="nvim_terminal_emulator.html#terminal">terminal</A>.
		The response from a new xterm is: &quot;&lt;Esc&gt;[ Pp ; Pv ; Pc c&quot;.  Pp
		is the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> type: 0 for vt100 and 1 for vt220.  Pv is the
		patch level (since this was introduced in patch 95, it's
		always 95 or bigger).  Pc is always zero.


					*<A NAME="v:testing"></A><B>v:testing</B>* *<A NAME="testing-variable"></A><B>testing-variable</B>*
<A HREF="#v:testing">v:testing</A>	Must be set before using `test_garbagecollect_now()`.


				*<A NAME="v:this_session"></A><B>v:this_session</B>* *<A NAME="this_session-variable"></A><B>this_session-variable</B>*
<A HREF="#v:this_session">v:this_session</A>	Full filename of the last loaded or saved session file.
		Empty when no session file has been saved.  See |<A HREF="starting.html#:mksession">:mksession</A>|.
		Modifiable (can be set).


					*<A NAME="v:throwpoint"></A><B>v:throwpoint</B>* *<A NAME="throwpoint-variable"></A><B>throwpoint-variable</B>*
<A HREF="#v:throwpoint">v:throwpoint</A>	The point where the exception most recently caught and not
		finished was thrown.  Not set when commands are typed.  See
		also |<A HREF="#v:exception">v:exception</A>| and |<A HREF="#throw-variables">throw-variables</A>|.
		Example:
<B>	:try</B>
<B>	:  throw "oops"</B>
<B>	:catch /.*/</B>
<B>	:  echo "Exception from" v:throwpoint</B>
<B>	:endtry</B>
 		Output: &quot;Exception from test.vim, line 2&quot;


					*<A NAME="v:true"></A><B>v:true</B>* *<A NAME="true-variable"></A><B>true-variable</B>*
<A HREF="#v:true">v:true</A>		Special value used to put &quot;true&quot; in JSON and msgpack.  See
		|<A HREF="builtin.html#json_encode()">json_encode()</A>|.  This value is converted to &quot;<A HREF="#v:true">v:true</A>&quot; when used
		<A HREF="motion.html#as">as</A> a <A HREF="#String">String</A> (e.g. in |<A HREF="#expr5">expr5</A>| with <A HREF="#string">string</A> concatenation
		<A HREF="motion.html#operator">operator</A>) and to one when used <A HREF="motion.html#as">as</A> a <A HREF="#Number">Number</A> (e.g. in |<A HREF="#expr5">expr5</A>| or
		|<A HREF="#expr7">expr7</A>| when used with numeric operators). Read-only.


						*<A NAME="v:val"></A><B>v:val</B>* *<A NAME="val-variable"></A><B>val-variable</B>*
<A HREF="#v:val">v:val</A>		Value of the current item of a |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>|.  Only
		valid while evaluating the <A HREF="#expression">expression</A> used with |<A HREF="builtin.html#map()">map()</A>| and
		|<A HREF="builtin.html#filter()">filter()</A>|.  Read-only.


					*<A NAME="v:version"></A><B>v:version</B>* *<A NAME="version-variable"></A><B>version-variable</B>*
<A HREF="#v:version">v:version</A>	Vim version number: major version times 100 plus minor
		version.  Vim 5.0 is 500, Vim 5.1 is 501.
		Read-only.
		Use |<A HREF="builtin.html#has()">has()</A>| to check the Nvim (not Vim) version:
<B>			:if has("nvim-0.2.1")</B>
 


				*<A NAME="v:vim_did_enter"></A><B>v:vim_did_enter</B>* *<A NAME="vim_did_enter-variable"></A><B>vim_did_enter-variable</B>*
<A HREF="#v:vim_did_enter">v:vim_did_enter</A>	0 during <A HREF="starting.html#startup">startup</A>, 1 just before |<A HREF="autocmd.html#VimEnter">VimEnter</A>|.
		Read-only.


					*<A NAME="v:warningmsg"></A><B>v:warningmsg</B>* *<A NAME="warningmsg-variable"></A><B>warningmsg-variable</B>*
<A HREF="#v:warningmsg">v:warningmsg</A>	Last given warning message.
		Modifiable (can be set).


					*<A NAME="v:windowid"></A><B>v:windowid</B>* *<A NAME="windowid-variable"></A><B>windowid-variable</B>*
<A HREF="#v:windowid">v:windowid</A>	Application-specific <A HREF="windows.html#window">window</A> &quot;handle&quot; which may be set by any
		attached <A HREF="ui.html#UI">UI</A>. Defaults to zero.
		Note: For Nvim |<A HREF="windows.html#windows">windows</A>| use |<A HREF="builtin.html#winnr()">winnr()</A>| or |<A HREF="builtin.html#win_getid()">win_getid()</A>|, see
		|<A HREF="windows.html#window-ID">window-ID</A>|.

==============================================================================

4. Builtin Functions				*<A NAME="vim-function"></A><B>vim-function</B>* *<A NAME="functions"></A><B>functions</B>*

The Vimscript subsystem (referred to <A HREF="motion.html#as">as</A> &quot;<A HREF="#eval">eval</A>&quot; internally) provides builtin
<A HREF="#functions">functions</A>.  Scripts can also define |<A HREF="#user-function">user-function</A>|s.

See |<A HREF="usr_41.html#function-list">function-list</A>| to browse <A HREF="#functions">functions</A> by topic.

The alphabetic <A HREF="#list">list</A> of all builtin <A HREF="#functions">functions</A> and details are in a separate
help file: |<A HREF="builtin.html#builtin-functions">builtin-functions</A>|.

==============================================================================

5. Defining <A HREF="#functions">functions</A>					*<A NAME="user-function"></A><B>user-function</B>*

New <A HREF="#functions">functions</A> can be defined.  These can be called just like builtin
<A HREF="#functions">functions</A>.  The function takes arguments, executes a sequence of <A HREF="intro.html#Ex">Ex</A> commands
and can return a value.

You can find most information about defining <A HREF="#functions">functions</A> in |<A HREF="userfunc.html">userfunc.txt</A>|.

==============================================================================

6. Curly braces names					*<A NAME="curly-braces-names"></A><B>curly-braces-names</B>*

In most places where you can use a variable, you can use a &quot;curly braces name&quot;
variable.  This is a regular variable name with one or more expressions
wrapped in braces <A HREF="intro.html#{}">{}</A> like this:
<B>	my_{adjective}_variable</B>

When Vim encounters this, <A HREF="motion.html#it">it</A> evaluates the <A HREF="#expression">expression</A> inside the braces, puts
that in place of the <A HREF="#expression">expression</A>, and re-interprets the whole <A HREF="motion.html#as">as</A> a variable
name.  So in the above example, if the variable &quot;adjective&quot; was set to
&quot;noisy&quot;, then the reference would be to &quot;my_noisy_variable&quot;, whereas if
&quot;adjective&quot; was set to &quot;quiet&quot;, then <A HREF="motion.html#it">it</A> would be to &quot;my_quiet_variable&quot;.

One application for this is to create a set of <A HREF="#variables">variables</A> governed by an option
value.  For example, the statement
<B>	echo my_{&amp;background}_message</B>

would output the contents of &quot;my_dark_message&quot; or &quot;my_light_message&quot; depending
on the current value of <A HREF="options.html#'background'">'background'</A>.

You can use multiple brace pairs:
<B>	echo my_{adverb}_{adjective}_message</B>
..or even nest them:
<B>	echo my_{ad{end_of_word}}_message</B>
where &quot;end_of_word&quot; is either &quot;verb&quot; or &quot;jective&quot;.

However, the <A HREF="#expression">expression</A> inside the braces must evaluate to a valid single
variable name, e.g. this is invalid:
<B>	:let foo='a + b'</B>
<B>	:echo c{foo}d</B>
.. since the result of expansion is &quot;ca + bd&quot;, which is not a variable name.


						*<A NAME="curly-braces-function-names"></A><B>curly-braces-function-names</B>*
You can call and define <A HREF="#functions">functions</A> by an evaluated name in a similar way.
Example:
<B>	:let func_end='whizz'</B>
<B>	:call my_func_{func_end}(parameter)</B>

This would call the function &quot;my_func_whizz(parameter)&quot;.

This does NOT work:
<B>  :let i = 3</B>
<B>  :let @{i} = ''  " error</B>
<B>  :echo @{i}      " error</B>

==============================================================================

7. Commands						*<A NAME="expression-commands"></A><B>expression-commands</B>*


<A HREF="#:let">:let</A> {var-name} = {expr1}				*<A NAME=":let"></A><B>:let</B>* *<A NAME="E18"></A><B>E18</B>*
			Set internal variable {var-name} to the result of the
			<A HREF="#expression">expression</A> {expr1}.  The variable will get the type
			from the {expr}.  If {var-name} didn't exist yet, <A HREF="motion.html#it">it</A>
			is created.


<A HREF="#:let">:let</A> {var-name}[{idx}] = {expr1}			*<A NAME="E689"></A><B>E689</B>*
			Set a <A HREF="#list">list</A> item to the result of the <A HREF="#expression">expression</A>
			{expr1}.  {var-name} must refer to a <A HREF="#list">list</A> and {idx}
			must be a valid index in that <A HREF="#list">list</A>.  For nested <A HREF="#list">list</A>
			the index can be repeated.
			This cannot be used to add an item to a |<A HREF="#List">List</A>|.
			This cannot be used to set a byte in a <A HREF="#String">String</A>.  You
			can <A HREF="diff.html#do">do</A> that like this:
<B>				:let var = var[0:2] .. 'X' .. var[4:]</B>
 			When {var-name} is a |<A HREF="#Blob">Blob</A>| then {idx} can be the
			length of the <A HREF="#blob">blob</A>, in which <A HREF="change.html#case">case</A> one byte is
			appended.


							*<A NAME="E711"></A><B>E711</B>* *<A NAME="E719"></A><B>E719</B>*

<A HREF="#:let">:let</A> {var-name}[{idx1}:{idx2}] = {expr1}		*<A NAME="E708"></A><B>E708</B>* *<A NAME="E709"></A><B>E709</B>* *<A NAME="E710"></A><B>E710</B>*
			Set a sequence of items in a |<A HREF="#List">List</A>| to the result of
			the <A HREF="#expression">expression</A> {expr1}, which must be a <A HREF="#list">list</A> with the
			correct number of items.
			{idx1} can be omitted, zero is used instead.
			{idx2} can be omitted, meaning the end of the <A HREF="#list">list</A>.
			When the selected range of items is partly past the
			end of the <A HREF="#list">list</A>, items will be added.


			*<A NAME=":let+="></A><B>:let+=</B>* *<A NAME=":let-="></A><B>:let-=</B>* *<A NAME=":letstar="></A><B>:letstar=</B>*

			*<A NAME=":let/="></A><B>:let/=</B>* *<A NAME=":let&#37;="></A><B>:let&#37;=</B>* *<A NAME=":let.="></A><B>:let.=</B>* *<A NAME=":let..="></A><B>:let..=</B>* *<A NAME="E734"></A><B>E734</B>*
<A HREF="#:let">:let</A> {var} += {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} + {expr1}&quot;.
<A HREF="#:let">:let</A> {var} -= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} - {expr1}&quot;.
<A HREF="#:let">:let</A> {var} *= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} &#42; {expr1}&quot;.
<A HREF="#:let">:let</A> {var} /= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} / {expr1}&quot;.
<A HREF="#:let">:let</A> {var} &#37;= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} <A HREF="motion.html#&#37;">&#37;</A> {expr1}&quot;.
<A HREF="#:let">:let</A> {var} .= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} . {expr1}&quot;.
<A HREF="#:let">:let</A> {var} ..= {expr1}	Like &quot;<A HREF="#:let">:let</A> {var} = {var} .. {expr1}&quot;.
			These fail if {var} was not set yet and when the type
			of {var} and {expr1} don't fit the <A HREF="motion.html#operator">operator</A>.



<A HREF="#:let">:let</A> ${env-name} = {expr1}			*<A NAME=":let-environment"></A><B>:let-environment</B>* *<A NAME=":let-$"></A><B>:let-$</B>*
			Set environment variable {env-name} to the result of
			the <A HREF="#expression">expression</A> {expr1}.  The type is always <A HREF="#String">String</A>.
<A HREF="#:let">:let</A> ${env-name} .= {expr1}
			Append {expr1} to the environment variable {env-name}.
			If the environment variable didn't exist yet this
			works like &quot;<A HREF="change.html#=">=</A>&quot;.


<A HREF="#:let">:let</A> @{reg-name} = {expr1}			*<A NAME=":let-register"></A><B>:let-register</B>* *<A NAME=":let-@"></A><B>:let-@</B>*
			Write the result of the <A HREF="#expression">expression</A> {expr1} in <A HREF="intro.html#register">register</A>
			{reg-name}.  {reg-name} must be a single <A HREF="print.html#letter">letter</A>, and
			must be the name of a writable <A HREF="intro.html#register">register</A> (see
			|<A HREF="change.html#registers">registers</A>|).  &quot;<A HREF="repeat.html#@@">@@</A>&quot; can be used for the unnamed
			<A HREF="intro.html#register">register</A>, &quot;<A HREF="change.html#@/">@/</A>&quot; for the search <A HREF="pattern.html#pattern">pattern</A>.
			If the result of {expr1} ends in a <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> or <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>, the
			<A HREF="intro.html#register">register</A> will be <A HREF="motion.html#linewise">linewise</A>, otherwise <A HREF="motion.html#it">it</A> will be set to
			<A HREF="motion.html#charwise">charwise</A>.
			This can be used to clear the last search <A HREF="pattern.html#pattern">pattern</A>:
<B>				:let @/ = ""</B>
 			This is different from searching for an empty <A HREF="#string">string</A>,
			that would match everywhere.

<A HREF="#:let">:let</A> @{reg-name} .= {expr1}
			Append {expr1} to <A HREF="intro.html#register">register</A> {reg-name}.  If the
			<A HREF="intro.html#register">register</A> was empty it's like setting <A HREF="motion.html#it">it</A> to {expr1}.


<A HREF="#:let">:let</A> &amp;{option-name} = {expr1}			*<A NAME=":let-option"></A><B>:let-option</B>* *<A NAME=":let-&amp;"></A><B>:let-&amp;</B>*
			Set option {option-name} to the result of the
			<A HREF="#expression">expression</A> {expr1}.  A <A HREF="#String">String</A> or <A HREF="#Number">Number</A> value is
			always converted to the type of the option.
			For an option local to a <A HREF="windows.html#window">window</A> or buffer the effect
			is just like using the |<A HREF="options.html#:set">:set</A>| command: both the local
			value and the global value are changed.
			Example:
<B>				:let &amp;path = &amp;path .. ',/usr/local/include'</B>

<A HREF="#:let">:let</A> &amp;{option-name} .= {expr1}
			For a <A HREF="#string">string</A> option: Append {expr1} to the value.
			Does not insert a comma like |<A HREF="options.html#:set+=">:set+=</A>|.

<A HREF="#:let">:let</A> &amp;{option-name} += {expr1}
<A HREF="#:let">:let</A> &amp;{option-name} -= {expr1}
			For a number or <A HREF="options.html#boolean">boolean</A> option: Add or subtract
			{expr1}.

<A HREF="#:let">:let</A> &amp;l:{option-name} = {expr1}
<A HREF="#:let">:let</A> &amp;l:{option-name} .= {expr1}
<A HREF="#:let">:let</A> &amp;l:{option-name} += {expr1}
<A HREF="#:let">:let</A> &amp;l:{option-name} -= {expr1}
			Like above, but only set the local value of an option
			(if there is one).  Works like |<A HREF="options.html#:setlocal">:setlocal</A>|.

<A HREF="#:let">:let</A> &amp;g:{option-name} = {expr1}
<A HREF="#:let">:let</A> &amp;g:{option-name} .= {expr1}
<A HREF="#:let">:let</A> &amp;g:{option-name} += {expr1}
<A HREF="#:let">:let</A> &amp;g:{option-name} -= {expr1}
			Like above, but only set the global value of an option
			(if there is one).  Works like |<A HREF="options.html#:setglobal">:setglobal</A>|.


<A HREF="#:let">:let</A> [{name1}, {name2}, ...] = {expr1}		*<A NAME=":let-unpack"></A><B>:let-unpack</B>* *<A NAME="E687"></A><B>E687</B>* *<A NAME="E688"></A><B>E688</B>*
			{expr1} must evaluate to a |<A HREF="#List">List</A>|.  The first item in
			the <A HREF="#list">list</A> is assigned to {name1}, the second item to
			{name2}, etc.
			The number of names must match the number of items in
			the |<A HREF="#List">List</A>|.
			Each name can be one of the items of the &quot;<A HREF="#:let">:let</A>&quot;
			command <A HREF="motion.html#as">as</A> mentioned above.
			Example:
<B>				:let [s, item] = GetItem(s)</B>
 			Detail: {expr1} is evaluated first, then the
			assignments are done in sequence.  This matters if
			{name2} depends on {name1}.  Example:
<B>				:let x = [0, 1]</B>
<B>				:let i = 0</B>
<B>				:let [i, x[i]] = [1, 2]</B>
<B>				:echo x</B>
 			The result is [0, 2].

<A HREF="#:let">:let</A> [{name1}, {name2}, ...] .= {expr1}
<A HREF="#:let">:let</A> [{name1}, {name2}, ...] += {expr1}
<A HREF="#:let">:let</A> [{name1}, {name2}, ...] -= {expr1}
			Like above, but append/add/subtract the value for each
			|<A HREF="#List">List</A>| item.


<A HREF="#:let">:let</A> [{name}, <A HREF="userfunc.html#...">...</A>, ; {lastname}] = {expr1}				*<A NAME="E452"></A><B>E452</B>*
			Like |<A HREF="#:let-unpack">:let-unpack</A>| above, but the |<A HREF="#List">List</A>| may have more
			items than there are names.  A <A HREF="#list">list</A> of the remaining
			items is assigned to {lastname}.  If there are no
			remaining items {lastname} is set to an empty <A HREF="#list">list</A>.
			Example:
<B>				:let [a, b; rest] = ["aval", "bval", 3, 4]</B>
 
<A HREF="#:let">:let</A> [{name}, <A HREF="userfunc.html#...">...</A>, ; {lastname}] .= {expr1}
<A HREF="#:let">:let</A> [{name}, <A HREF="userfunc.html#...">...</A>, ; {lastname}] += {expr1}
<A HREF="#:let">:let</A> [{name}, <A HREF="userfunc.html#...">...</A>, ; {lastname}] -= {expr1}
			Like above, but append/add/subtract the value for each
			|<A HREF="#List">List</A>| item.


						*<A NAME=":let=&lt;&lt;"></A><B>:let=&lt;&lt;</B>* *<A NAME=":let-heredoc"></A><B>:let-heredoc</B>*

						*<A NAME="E990"></A><B>E990</B>* *<A NAME="E991"></A><B>E991</B>* *<A NAME="E172"></A><B>E172</B>* *<A NAME="E221"></A><B>E221</B>*
<A HREF="#:let">:let</A> {var-name} =&lt;&lt; [trim] {endmarker}
text...
text...
{endmarker}
			Set internal variable {var-name} to a |<A HREF="#List">List</A>|
			containing the lines of text bounded by the <A HREF="#string">string</A>
			{endmarker}. The lines of text is used <A HREF="motion.html#as">as</A> a
			|<A HREF="#literal-string">literal-string</A>|.
			{endmarker} must not contain white space.
			{endmarker} cannot start with a lower <A HREF="change.html#case">case</A> character.
			The last line should end only with the {endmarker}
			<A HREF="#string">string</A> without any other character.  Watch out for
			white space after {endmarker}!

			Without &quot;trim&quot; any white space characters in the lines
			of text are preserved.  If &quot;trim&quot; is specified before
			{endmarker}, then indentation is stripped so you can
			<A HREF="diff.html#do">do</A>:
<B>				let text =&lt;&lt; trim END</B>
<B>				   if ok</B>
<B>				     echo 'done'</B>
<B>				   endif</B>
<B>				END</B>
 			Results in: `[&quot;if ok&quot;, &quot;  echo 'done&#39;&#34;', &quot;endif&quot;]`
			The marker must line up with &quot;let&quot; and the indentation
			of the first line is removed from all the text lines.
			Specifically: all the leading indentation exactly
			matching the leading indentation of the first
			non-empty text line is stripped from the input lines.
			All leading indentation exactly matching the leading
			indentation before `let` is stripped from the line
			containing {endmarker}.  Note that the difference
			between space and <A HREF="intro.html#tab">tab</A> matters here.

			If {var-name} didn't exist yet, <A HREF="motion.html#it">it</A> is created.
			Cannot be followed by another command, but can be
			followed by a comment.

			To avoid line continuation to be applied, consider
			adding '<A HREF="change.html#C">C</A>' to <A HREF="options.html#'cpoptions'">'cpoptions'</A>:
<B>				set cpo+=C</B>
<B>				let var =&lt;&lt; END</B>
<B>				   \ leading backslash</B>
<B>				END</B>
<B>				set cpo-=C</B>
 
			Examples:
<B>				let var1 =&lt;&lt; END</B>
<B>				Sample text 1</B>
<B>				    Sample text 2</B>
<B>				Sample text 3</B>
<B>				END</B>

<B>				let data =&lt;&lt; trim DATA</B>
<B>					1 2 3 4</B>
<B>					5 6 7 8</B>
<B>				DATA</B>
 

								*<A NAME="E121"></A><B>E121</B>*
<A HREF="#:let">:let</A> {var-name}	..	<A HREF="#List">List</A> the value of variable {var-name}.  Multiple
			variable names may be given.  Special names recognized

			here:				*<A NAME="E738"></A><B>E738</B>*
			  <A HREF="#g:">g:</A>	global <A HREF="#variables">variables</A>
			  <A HREF="#b:">b:</A>	local buffer <A HREF="#variables">variables</A>
			  <A HREF="#w:">w:</A>	local <A HREF="windows.html#window">window</A> <A HREF="#variables">variables</A>
			  <A HREF="#t:">t:</A>	local <A HREF="intro.html#tab">tab</A> page <A HREF="#variables">variables</A>
			  <A HREF="change.html#s">s</A>:	<A HREF="map.html#script-local">script-local</A> <A HREF="#variables">variables</A>
			  <A HREF="#l:">l:</A>	local function <A HREF="#variables">variables</A>
			  <A HREF="#v:">v:</A>	Vim <A HREF="#variables">variables</A>.

<A HREF="#:let">:let</A>			<A HREF="#List">List</A> the values of all <A HREF="#variables">variables</A>.  The type of the
			variable is indicated before the value:
			    &lt;nothing&gt;	<A HREF="#String">String</A>
				#	<A HREF="#Number">Number</A>
				&#42;	<A HREF="#Funcref">Funcref</A>



:unl[et][!] {name} <A HREF="userfunc.html#...">...</A>				*<A NAME=":unlet"></A><B>:unlet</B>* *<A NAME=":unl"></A><B>:unl</B>* *<A NAME="E108"></A><B>E108</B>* *<A NAME="E795"></A><B>E795</B>*
			Remove the internal variable {name}.  Several variable
			names can be given, they are all removed.  The name
			may also be a |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>| item.
			With [!] no error message is given for non-existing
			<A HREF="#variables">variables</A>.
			One or more items from a |<A HREF="#List">List</A>| can be removed:
<B>				:unlet list[3]	  " remove fourth item</B>
<B>				:unlet list[3:]   " remove fourth item to last</B>
 			One item from a |<A HREF="#Dictionary">Dictionary</A>| can be removed at a time:
<B>				:unlet dict['two']</B>
<B>				:unlet dict.two</B>
 			This is especially useful to clean up used global
			<A HREF="#variables">variables</A> and <A HREF="map.html#script-local">script-local</A> <A HREF="#variables">variables</A> (these are not
			deleted when the <A HREF="usr_41.html#script">script</A> ends).  Function-local
			<A HREF="#variables">variables</A> are automatically deleted when the function
			ends.


:unl[et] ${env-name} <A HREF="userfunc.html#...">...</A>			*<A NAME=":unlet-environment"></A><B>:unlet-environment</B>* *<A NAME=":unlet-$"></A><B>:unlet-$</B>*
			Remove environment variable {env-name}.
			Can mix {name} and ${env-name} in one <A HREF="#:unlet">:unlet</A> command.
			No error message is given for a non-existing
			variable, also without !.
			If the system does not support <A HREF="change.html#deleting">deleting</A> an environment
			variable, <A HREF="motion.html#it">it</A> is made empty.


						*<A NAME=":cons"></A><B>:cons</B>* *<A NAME=":const"></A><B>:const</B>*
:cons[t] {var-name} = {expr1}
:cons[t] [{name1}, {name2}, ...] = {expr1}
:cons[t] [{name}, <A HREF="userfunc.html#...">...</A>, ; {lastname}] = {expr1}
			Similar to |<A HREF="#:let">:let</A>|, but additionally lock the variable
			after setting the value.  This is the same <A HREF="motion.html#as">as</A> locking
			the variable with |<A HREF="#:lockvar">:lockvar</A>| just after |<A HREF="#:let">:let</A>|, thus:
<B>				:const x = 1</B>
 			is equivalent to:
<B>				:let x = 1</B>
<B>				:lockvar! x</B>
 			This is useful if you want to make sure the variable
			is not modified.  If the value is a <A HREF="#List">List</A> or <A HREF="#Dictionary">Dictionary</A>
			literal then the items also cannot be changed:
<B>				const ll = [1, 2, 3]</B>
<B>				let ll[1] = 5  " Error!</B>
 			Nested references are not locked:
<B>				let lvar = ['a']</B>
<B>				const lconst = [0, lvar]</B>
<B>				let lconst[0] = 2  " Error!</B>
<B>				let lconst[1][0] = 'b'  " OK</B>

 							*<A NAME="E995"></A><B>E995</B>*
			|<A HREF="#:const">:const</A>| does not allow to for <A HREF="change.html#changing">changing</A> a variable.
<B>				:let x = 1</B>
<B>				:const x = 2  " Error!</B>

 							*<A NAME="E996"></A><B>E996</B>*
			Note that environment <A HREF="#variables">variables</A>, option values and
			<A HREF="intro.html#register">register</A> values cannot be used here, since they cannot
			be locked.

:cons[t]
:cons[t] {var-name}
			If no argument is given or only {var-name} is given,
			the behavior is the same <A HREF="motion.html#as">as</A> |<A HREF="#:let">:let</A>|.


:lockv[ar][!] [depth] {name} <A HREF="userfunc.html#...">...</A>			*<A NAME=":lockvar"></A><B>:lockvar</B>* *<A NAME=":lockv"></A><B>:lockv</B>*
			Lock the internal variable {name}.  Locking means that
			<A HREF="motion.html#it">it</A> can no longer be changed (until <A HREF="motion.html#it">it</A> is unlocked).
			A locked variable can be deleted:
<B>				:lockvar v</B>
<B>				:let v = 'asdf'	  " fails!</B>
<B>				:unlet v	  " works</B>

 							*<A NAME="E741"></A><B>E741</B>* *<A NAME="E940"></A><B>E940</B>*
			If you try to change a locked variable you get an
			error message: &quot;E741: Value is locked: {name}&quot;.
			If you try to lock or unlock a built-in variable you
			will get an error message &quot;E940: Cannot lock or unlock
			variable {name}&quot;.

			[depth] is relevant when locking a |<A HREF="#List">List</A>| or
			|<A HREF="#Dictionary">Dictionary</A>|.  It specifies how deep the locking goes:
				1	Lock the |<A HREF="#List">List</A>| or |<A HREF="#Dictionary">Dictionary</A>| itself,
					cannot add or remove items, but can
					still change their values.
				2	Also lock the values, cannot change
					the items.  If an item is a |<A HREF="#List">List</A>| or
					|<A HREF="#Dictionary">Dictionary</A>|, cannot add or remove
					items, but can still change the
					values.
				3	Like 2 but for the |<A HREF="#List">List</A>| /
					|<A HREF="#Dictionary">Dictionary</A>| in the |<A HREF="#List">List</A>| /
					|<A HREF="#Dictionary">Dictionary</A>|, one level deeper.
			The default [depth] is 2, thus when {name} is a |<A HREF="#List">List</A>|
			or |<A HREF="#Dictionary">Dictionary</A>| the values cannot be changed.

								*<A NAME="E743"></A><B>E743</B>*
			For unlimited depth use [!] and omit [depth].
			However, there is a maximum depth of 100 to catch
			loops.

			Note that when two <A HREF="#variables">variables</A> refer to the same |<A HREF="#List">List</A>|
			and you lock one of them, the |<A HREF="#List">List</A>| will also be
			locked when used through the other variable.
			Example:
<B>				:let l = [0, 1, 2, 3]</B>
<B>				:let cl = l</B>
<B>				:lockvar l</B>
<B>				:let cl[1] = 99		" won't work!</B>
 			You may want to make a copy of a <A HREF="#list">list</A> to avoid this.
			See |<A HREF="builtin.html#deepcopy()">deepcopy()</A>|.



:unlo[ckvar][!] [depth] {name} <A HREF="userfunc.html#...">...</A>			*<A NAME=":unlockvar"></A><B>:unlockvar</B>* *<A NAME=":unlo"></A><B>:unlo</B>*
			Unlock the internal variable {name}.  Does the
			opposite of |<A HREF="#:lockvar">:lockvar</A>|.


<A HREF="#:if">:if</A> {expr1}			*<A NAME=":if"></A><B>:if</B>* *<A NAME=":end"></A><B>:end</B>* *<A NAME=":endif"></A><B>:endif</B>* *<A NAME=":en"></A><B>:en</B>* *<A NAME="E171"></A><B>E171</B>* *<A NAME="E579"></A><B>E579</B>* *<A NAME="E580"></A><B>E580</B>*
:en[dif]		Execute the commands until the next matching `:else`
			or `:endif` if {expr1} evaluates to non-zero.
			Although the short forms work, <A HREF="motion.html#it">it</A> is recommended to
			always use `:endif` to avoid confusion and to make
			auto-indenting work properly.

			From Vim version 4.5 until 5.0, every <A HREF="intro.html#Ex">Ex</A> command in
			between the `:if` and `:endif` is ignored.  These two
			commands were just to allow for future expansions in a
			backward compatible way.  Nesting was allowed.  Note
			that any `:else` or `:elseif` was ignored, the `else`
			part was not executed either.

			You can use this to remain compatible with older
			versions:
<B>				:if version &gt;= 500</B>
<B>				:  version-5-specific-commands</B>
<B>				:endif</B>
 			The commands still need to be parsed to find the
			`endif`.  Sometimes an older Vim has a problem with a
			new command.  For example, `:silent` is recognized <A HREF="motion.html#as">as</A>
			a `:substitute` command.  In that <A HREF="change.html#case">case</A> `:execute` can
			avoid problems:
<B>				:if version &gt;= 600</B>
<B>				:  execute "silent 1,$delete"</B>
<B>				:endif</B>
 
			NOTE: The `:append` and `:insert` commands don't work
			properly in between `:if` and `:endif`.


						*<A NAME=":else"></A><B>:else</B>* *<A NAME=":el"></A><B>:el</B>* *<A NAME="E581"></A><B>E581</B>* *<A NAME="E583"></A><B>E583</B>*
:el[se]			Execute the commands until the next matching `:else`
			or `:endif` if they previously were not being
			executed.


					*<A NAME=":elseif"></A><B>:elseif</B>* *<A NAME=":elsei"></A><B>:elsei</B>* *<A NAME="E582"></A><B>E582</B>* *<A NAME="E584"></A><B>E584</B>*
:elsei[f] {expr1}	Short for `:else` `:if`, with the addition that there
			is no extra `:endif`.


:wh[ile] {expr1}			*<A NAME=":while"></A><B>:while</B>* *<A NAME=":endwhile"></A><B>:endwhile</B>* *<A NAME=":wh"></A><B>:wh</B>* *<A NAME=":endw"></A><B>:endw</B>*

						*<A NAME="E170"></A><B>E170</B>* *<A NAME="E585"></A><B>E585</B>* *<A NAME="E588"></A><B>E588</B>* *<A NAME="E733"></A><B>E733</B>*
:endw[hile]		Repeat the commands between `:while` and `:endwhile`,
			<A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> {expr1} evaluates to non-zero.
			When an error is detected from a command inside the
			loop, execution continues after the `endwhile`.
			Example:
<B>				:let lnum = 1</B>
<B>				:while lnum &lt;= line("$")</B>
<B>				   :call FixLine(lnum)</B>
<B>				   :let lnum = lnum + 1</B>
<B>				:endwhile</B>
 
			NOTE: The `:append` and `:insert` commands don't work
			properly inside a `:while` and `:for` loop.


<A HREF="#:for">:for</A> {var} in {object}					*<A NAME=":for"></A><B>:for</B>* *<A NAME="E690"></A><B>E690</B>* *<A NAME="E732"></A><B>E732</B>*

:endfo[r]						*<A NAME=":endfo"></A><B>:endfo</B>* *<A NAME=":endfor"></A><B>:endfor</B>*
			Repeat the commands between `:for` and `:endfor` for
			each item in {object}.  {object} can be a |<A HREF="#List">List</A>|,
			a |<A HREF="#Blob">Blob</A>| or a |<A HREF="#String">String</A>|.

			Variable {var} is set to the value of each item.

			When an error is detected for a command inside the
			loop, execution continues after the `endfor`.
			Changing {object} inside the loop affects what items
			are used.  Make a copy if this is unwanted:
<B>				:for item in copy(mylist)</B>
 
			When {object} is a |<A HREF="#List">List</A>| and not making a copy, Vim
			stores a reference to the next item in the |<A HREF="#List">List</A>|
			before executing the commands with the current item.
			Thus the current item can be removed without effect.
			Removing any later item means <A HREF="motion.html#it">it</A> will not be found.
			Thus the following example works (an inefficient way
			to make a |<A HREF="#List">List</A>| empty):
<B>				for item in mylist</B>
<B>				   call remove(mylist, 0)</B>
<B>				endfor</B>
 			Note that reordering the |<A HREF="#List">List</A>| (e.g., with <A HREF="builtin.html#sort()">sort()</A> or
			<A HREF="builtin.html#reverse()">reverse()</A>) may have unexpected effects.

			When {object} is a |<A HREF="#Blob">Blob</A>|, Vim always makes a copy to
			iterate over.  Unlike with |<A HREF="#List">List</A>|, modifying the
			|<A HREF="#Blob">Blob</A>| does not affect the iteration.

			When {object} is a |<A HREF="#String">String</A>| each item is a <A HREF="#string">string</A> with
			one character, plus any combining characters.

<A HREF="#:for">:for</A> [{var1}, {var2}, ...] in {listlist}
:endfo[r]
			Like `:for` above, but each item in {listlist} must be
			a <A HREF="#list">list</A>, of which each item is assigned to {var1},
			{var2}, etc.  Example:
<B>				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]</B>
<B>				   :echo getline(lnum)[col]</B>
<B>				:endfor</B>
 

						*<A NAME=":continue"></A><B>:continue</B>* *<A NAME=":con"></A><B>:con</B>* *<A NAME="E586"></A><B>E586</B>*
:con[tinue]		When used inside a `:while` or `:for` loop, jumps back
			to the start of the loop.

			If <A HREF="motion.html#it">it</A> is used after a `:try` inside the loop but
			before the matching `:finally` (if present), the
			commands following the `:finally` up to the matching
			`:endtry` are executed first.  This process applies to
			all nested `:try`s inside the loop.  The outermost
			`:endtry` then jumps back to the start of the loop.


						*<A NAME=":break"></A><B>:break</B>* *<A NAME=":brea"></A><B>:brea</B>* *<A NAME="E587"></A><B>E587</B>*
:brea[k]		When used inside a `:while` or `:for` loop, skips to
			the command after the matching `:endwhile` or
			`:endfor`.
			If <A HREF="motion.html#it">it</A> is used after a `:try` inside the loop but
			before the matching `:finally` (if present), the
			commands following the `:finally` up to the matching
			`:endtry` are executed first.  This process applies to
			all nested `:try`s inside the loop.  The outermost
			`:endtry` then jumps to the command after the loop.


<A HREF="#:try">:try</A>				*<A NAME=":try"></A><B>:try</B>* *<A NAME=":endt"></A><B>:endt</B>* *<A NAME=":endtry"></A><B>:endtry</B>* *<A NAME="E600"></A><B>E600</B>* *<A NAME="E601"></A><B>E601</B>* *<A NAME="E602"></A><B>E602</B>*
:endt[ry]		Change the error handling for the commands between
			`:try` and `:endtry` including everything being
			executed across `:source` commands, function calls,
			or <A HREF="autocmd.html#autocommand">autocommand</A> invocations.

			When an error or interrupt is detected and there is
			a `:finally` command following, execution continues
			after the `:finally`.  Otherwise, or when the
			`:endtry` is reached thereafter, the next
			(dynamically) surrounding `:try` is checked for
			a corresponding `:finally` etc.  Then the <A HREF="usr_41.html#script">script</A>
			processing is terminated.  Whether a function
			definition has an &quot;abort&quot; argument does not matter.
			Example:
<B>		try | call Unknown() | finally | echomsg "cleanup" | endtry</B>
<B>		echomsg "not reached"</B>
 
			Moreover, an error or interrupt (dynamically) inside
			`:try` and `:endtry` is converted to an exception.  It
			can be caught <A HREF="motion.html#as">as</A> if <A HREF="motion.html#it">it</A> were thrown by a `:throw`
			command (see `:catch`).  In this <A HREF="change.html#case">case</A>, the <A HREF="usr_41.html#script">script</A>
			processing is not terminated.

			The value &quot;Vim:Interrupt&quot; is used for an interrupt
			exception.  An error in a Vim command is converted
			to a value of the form &quot;Vim({command}):{errmsg}&quot;,
			other <A HREF="message.html#errors">errors</A> are converted to a value of the form
			&quot;Vim:{errmsg}&quot;.  {command} is the full command name,
			and {errmsg} is the message that is displayed if the
			error exception is not caught, always beginning with
			the error number.
			Examples:
<B>		try | sleep 100 | catch /^Vim:Interrupt$/ | endtry</B>
<B>		try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry</B>
 

					*<A NAME=":cat"></A><B>:cat</B>* *<A NAME=":catch"></A><B>:catch</B>* *<A NAME="E603"></A><B>E603</B>* *<A NAME="E604"></A><B>E604</B>* *<A NAME="E605"></A><B>E605</B>*
:cat[ch] /{pattern}/	The following commands until the next `:catch`,
			`:finally`, or `:endtry` that belongs to the same
			`:try` <A HREF="motion.html#as">as</A> the `:catch` are executed when an exception
			matching {pattern} is being thrown and has not yet
			been caught by a previous `:catch`.  Otherwise, these
			commands are skipped.
			When {pattern} is omitted all <A HREF="message.html#errors">errors</A> are caught.
			Examples:
<B>		:catch /^Vim:Interrupt$/	 " catch interrupts (CTRL-C)</B>
<B>		:catch /^Vim\%((\a\+)\)\=:E/	 " catch all Vim errors</B>
<B>		:catch /^Vim\%((\a\+)\)\=:/	 " catch errors and interrupts</B>
<B>		:catch /^Vim(write):/		 " catch all errors in :write</B>
<B>		:catch /^Vim\%((\a\+)\)\=:E123:/ " catch error E123</B>
<B>		:catch /my-exception/		 " catch user exception</B>
<B>		:catch /.*/			 " catch everything</B>
<B>		:catch				 " same as /.*/</B>
 
			Another character can be used instead of / around the
			{pattern}, so long <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> does not have a special
			meaning (e.g., '&#124;' or &#39;&#34;'') and doesn't occur inside
			{pattern}.
			Information about the exception is available in
			|<A HREF="#v:exception">v:exception</A>|.  Also see |<A HREF="#throw-variables">throw-variables</A>|.
			NOTE: It is not reliable to &quot;<A HREF="#:catch">:catch</A>&quot; the TEXT of
			an error message because <A HREF="motion.html#it">it</A> may vary in different
			locales.


					*<A NAME=":fina"></A><B>:fina</B>* *<A NAME=":finally"></A><B>:finally</B>* *<A NAME="E606"></A><B>E606</B>* *<A NAME="E607"></A><B>E607</B>*
:fina[lly]		The following commands until the matching `:endtry`
			are executed whenever the part between the matching
			`:try` and the `:finally` is left:  either by falling
			through to the `:finally` or by a `:continue`,
			`:break`, `:finish`, or `:return`, or by an error or
			interrupt or exception (see `:throw`).


							*<A NAME=":th"></A><B>:th</B>* *<A NAME=":throw"></A><B>:throw</B>* *<A NAME="E608"></A><B>E608</B>*
:th[row] {expr1}	The {expr1} is evaluated and thrown <A HREF="motion.html#as">as</A> an exception.
			If the `:throw` is used after a `:try` but before the
			first corresponding `:catch`, commands are skipped
			until the first `:catch` matching {expr1} is reached.
			If there is no such `:catch` or if the `:throw` is
			used after a `:catch` but before the `:finally`, the
			commands following the `:finally` (if present) up to
			the matching `:endtry` are executed.  If the `:throw`
			is after the `:finally`, commands up to the `:endtry`
			are skipped.  At the `:endtry`, this process applies
			again for the next dynamically surrounding `:try`
			(which may be found in a calling function or sourcing
			script), until a matching `:catch` has been found.
			If the exception is not caught, the command processing
			is terminated.
			Example:
<B>		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry</B>
 			Note that &quot;catch&quot; may need to be on a separate line
			for when an error causes the parsing to skip the whole
			line and not see the &quot;|&quot; that separates the commands.


							*<A NAME=":ec"></A><B>:ec</B>* *<A NAME=":echo"></A><B>:echo</B>*
:ec[ho] {expr1} ..	Echoes each {expr1}, with a space in between.  The
			first {expr1} starts on a new line.
			Also see |<A HREF="cmdline.html#:comment">:comment</A>|.
			Use &quot;\n&quot; to start a new line.  Use &quot;\r&quot; to move the
			cursor to the first column.
			Uses the highlighting set by the `:echohl` command.
			Cannot be followed by a comment.
			Example:
<B>		:echo "the value of 'shell' is" &amp;shell</B>

 							*<A NAME=":echo-redraw"></A><B>:echo-redraw</B>*
			A later redraw may make the message disappear again.
			And since Vim mostly postpones redrawing until it's
			finished with a sequence of commands this happens
			quite often.  To avoid that a command from before the
			`:echo` causes a redraw afterwards (redraws are often
			postponed until you type something), force a redraw
			with the `:redraw` command.  Example:
<B>		:new | redraw | echo "there is a new window"</B>

 							*<A NAME=":echo-self-refer"></A><B>:echo-self-refer</B>*
			When <A HREF="print.html#printing">printing</A> nested containers echo prints second
			occurrence of the self-referencing container using
			&quot;[...@level]&quot; (self-referencing |<A HREF="#List">List</A>|) or
			&quot;{...@level}&quot; (self-referencing |<A HREF="#Dict">Dict</A>|):
<B>		:let l = []</B>
<B>		:call add(l, l)</B>
<B>		:let l2 = []</B>
<B>		:call add(l2, [l2])</B>
<B>		:echo l l2</B>
 			echoes &quot;[[...@0]] [[[...@0]]]&quot;. Echoing &quot;[l]&quot; will
			echo &quot;[[[...@1]]]&quot; because <A HREF="motion.html#l">l</A> first occurs at second
			level.


							*<A NAME=":echon"></A><B>:echon</B>*
<A HREF="#:echon">:echon</A> {expr1} ..	Echoes each {expr1}, without anything added.  Also see
			|<A HREF="cmdline.html#:comment">:comment</A>|.
			Uses the highlighting set by the `:echohl` command.
			Cannot be followed by a comment.
			Example:
<B>				:echon "the value of 'shell' is " &amp;shell</B>
 
			Note the difference between using `:echo`, which is a
			Vim command, and `:!echo`, which is an external shell
			command:
<B>		:!echo %		--&gt; filename</B>
 			The arguments of &quot;<A HREF="various.html#:!">:!</A>&quot; are expanded, see |<A HREF="cmdline.html#:_&#37;">:_&#37;</A>|.
<B>		:!echo "%"		--&gt; filename or "filename"</B>
 			Like the previous example.  Whether you see the double
			quotes or not depends on your <A HREF="options.html#'shell'">'shell'</A>.
<B>		:echo %			--&gt; nothing</B>
 			The '<A HREF="motion.html#&#37;">&#37;</A>' is an illegal character in an <A HREF="#expression">expression</A>.
<B>		:echo "%"		--&gt; %</B>
 			This just echoes the '<A HREF="motion.html#&#37;">&#37;</A>' character.
<B>		:echo expand("%")	--&gt; filename</B>
 			This calls the <A HREF="builtin.html#expand()">expand()</A> function to expand the '<A HREF="motion.html#&#37;">&#37;</A>'.


							*<A NAME=":echoh"></A><B>:echoh</B>* *<A NAME=":echohl"></A><B>:echohl</B>*
:echoh[l] {name}	Use the highlight group {name} for the following
			`:echo`, `:echon` and `:echomsg` commands.  Also used
			for the `input()` prompt.  Example:
<B>		:echohl WarningMsg | echo "Don't panic!" | echohl None</B>
 			Don't forget to set the group back to &quot;None&quot;,
			otherwise all following echo's will be highlighted.


							*<A NAME=":echom"></A><B>:echom</B>* *<A NAME=":echomsg"></A><B>:echomsg</B>*
:echom[sg] {expr1} ..	Echo the expression(s) <A HREF="motion.html#as">as</A> a true message, saving the
			message in the |<A HREF="message.html#message-history">message-history</A>|.
			Spaces are placed between the arguments <A HREF="motion.html#as">as</A> with the
			`:echo` command.  But unprintable characters are
			displayed, not interpreted.
			The parsing works slightly different from `:echo`,
			more like `:execute`.  All the expressions are first
			evaluated and concatenated before echoing anything.
			If expressions does not evaluate to a <A HREF="#Number">Number</A> or
			<A HREF="#String">String</A>, <A HREF="builtin.html#string()">string()</A> is used to turn <A HREF="motion.html#it">it</A> into a <A HREF="#string">string</A>.
			Uses the highlighting set by the `:echohl` command.
			Example:
<B>		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."</B>
 			See |<A HREF="#:echo-redraw">:echo-redraw</A>| to avoid the message disappearing
			when the screen is redrawn.

							*<A NAME=":echoe"></A><B>:echoe</B>* *<A NAME=":echoerr"></A><B>:echoerr</B>*
:echoe[rr] {expr1} ..	Echo the expression(s) <A HREF="motion.html#as">as</A> an error message, saving the
			message in the |<A HREF="message.html#message-history">message-history</A>|.  When used in a
			<A HREF="usr_41.html#script">script</A> or function the line number will be added.
			Spaces are placed between the arguments <A HREF="motion.html#as">as</A> with the
			`:echomsg` command.  When used inside a try conditional,
			the message is raised <A HREF="motion.html#as">as</A> an error exception instead
			(see |<A HREF="#try-echoerr">try-echoerr</A>|).
			Example:
<B>		:echoerr "This script just failed!"</B>
 			If you just want a highlighted message use `:echohl`.
			And to get a beep:
<B>		:exe "normal \&lt;Esc&gt;"</B>
 

							*<A NAME=":eval"></A><B>:eval</B>*
<A HREF="#:eval">:eval</A> {expr}		Evaluate {expr} and <A HREF="editing.html#discard">discard</A> the result.  Example:
<B>				:eval Getlist()-&gt;Filter()-&gt;append('$')</B>

 			The <A HREF="#expression">expression</A> is supposed to have a side effect,
			since the resulting value is not used.  In the example
			the `append()` call appends the <A HREF="#List">List</A> with text to the
			buffer.  This is similar to `:call` but works with any
			<A HREF="#expression">expression</A>.

			The command can be shortened to `:ev` or `:eva`, but
			these are hard to recognize and therefore not to be
			used.

			The command cannot be followed by &quot;|&quot; and another
			command, since &quot;|&quot; is seen <A HREF="motion.html#as">as</A> part of the <A HREF="#expression">expression</A>.



							*<A NAME=":exe"></A><B>:exe</B>* *<A NAME=":execute"></A><B>:execute</B>*
:exe[cute] {expr1} ..	Executes the <A HREF="#string">string</A> that results from the evaluation
			of {expr1} <A HREF="motion.html#as">as</A> an <A HREF="intro.html#Ex">Ex</A> command.
			Multiple arguments are concatenated, with a space in
			between.  To avoid the extra space use the &quot;..&quot;
			<A HREF="motion.html#operator">operator</A> to concatenate strings into one argument.
			{expr1} is used <A HREF="motion.html#as">as</A> the processed command, command line
			editing keys are not recognized.
			Cannot be followed by a comment.
			Examples:
<B>		:execute "buffer" nextbuf</B>
<B>		:execute "normal" count .. "w"</B>
 
			&quot;<A HREF="#:execute">:execute</A>&quot; can be used to append a command to commands
			that don't accept a '&#124;'.  Example:
<B>		:execute '!ls' | echo "theend"</B>

 			&quot;<A HREF="#:execute">:execute</A>&quot; is also a nice way to avoid having to type
			<A HREF="intro.html#control">control</A> characters in a Vim <A HREF="usr_41.html#script">script</A> for a &quot;<A HREF="various.html#:normal">:normal</A>&quot;
			command:
<B>		:execute "normal ixxx\&lt;Esc&gt;"</B>
 			This has an <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> character, see |<A HREF="#expr-string">expr-string</A>|.

			Be careful to correctly <A HREF="intro.html#escape">escape</A> special characters in
			file names.  The |<A HREF="builtin.html#fnameescape()">fnameescape()</A>| function can be used
			for Vim commands, |<A HREF="builtin.html#shellescape()">shellescape()</A>| for |<A HREF="various.html#:!">:!</A>| commands.
			Examples:
<B>		:execute "e " .. fnameescape(filename)</B>
<B>		:execute "!ls " .. shellescape(filename, 1)</B>
 
			Note: The executed <A HREF="#string">string</A> may be any command-line, but
			starting or ending &quot;if&quot;, &quot;while&quot; and &quot;for&quot; does not
			always work, because when commands are skipped the
			&quot;<A HREF="#:execute">:execute</A>&quot; is not evaluated and Vim loses track of
			where blocks start and end.  Also &quot;break&quot; and
			&quot;continue&quot; should not be inside &quot;<A HREF="#:execute">:execute</A>&quot;.
			This example does not work, because the &quot;<A HREF="#:execute">:execute</A>&quot; is
			not evaluated and Vim does not see the &quot;while&quot;, and
			gives an error for finding an &quot;<A HREF="#:endwhile">:endwhile</A>&quot;:
<B>		:if 0</B>
<B>		: execute 'while i &gt; 5'</B>
<B>		:  echo "test"</B>
<B>		: endwhile</B>
<B>		:endif</B>
 
			It is allowed to have a &quot;while&quot; or &quot;if&quot; command
			completely in the executed <A HREF="#string">string</A>:
<B>		:execute 'while i &lt; 5 | echo i | let i = i + 1 | endwhile'</B>
 


							*<A NAME=":exe-comment"></A><B>:exe-comment</B>*
			&quot;<A HREF="#:execute">:execute</A>&quot;, &quot;<A HREF="#:echo">:echo</A>&quot; and &quot;<A HREF="#:echon">:echon</A>&quot; cannot be followed by
			a comment directly, because they see the &#39;&#34;'' <A HREF="motion.html#as">as</A> the
			start of a <A HREF="#string">string</A>.  But, you can use '&#124;' followed by a
			comment.  Example:
<B>		:echo "foo" | "this is a comment</B>

==============================================================================

8. Exception handling					*<A NAME="exception-handling"></A><B>exception-handling</B>*

The Vim <A HREF="usr_41.html#script">script</A> language comprises an exception handling feature.  This section
explains how <A HREF="motion.html#it">it</A> can be used in a Vim <A HREF="usr_41.html#script">script</A>.

Exceptions may be raised by Vim on an error or on interrupt, see
|<A HREF="#catch-errors">catch-errors</A>| and |<A HREF="#catch-interrupt">catch-interrupt</A>|.  You can also explicitly throw an
exception by using the &quot;<A HREF="#:throw">:throw</A>&quot; command, see |<A HREF="#throw-catch">throw-catch</A>|.



TRY CONDITIONALS					*<A NAME="try-conditionals"></A><B>try-conditionals</B>*

Exceptions can be caught or can cause cleanup code to be executed.  You can
use a try conditional to specify catch clauses (that catch exceptions) and/or
a finally clause (to be executed for cleanup).
   A try conditional begins with a |<A HREF="#:try">:try</A>| command and ends at the matching
|<A HREF="#:endtry">:endtry</A>| command.  In between, you can use a |<A HREF="#:catch">:catch</A>| command to start
a catch clause, or a |<A HREF="#:finally">:finally</A>| command to start a finally clause.  There may
be none or multiple catch clauses, but there is at most one finally clause,
which must not be followed by any catch clauses.  The lines before the catch
clauses and the finally clause is called a try block.

<B>     :try</B>
<B>     :	...</B>
<B>     :	...				TRY BLOCK</B>
<B>     :	...</B>
<B>     :catch /{pattern}/</B>
<B>     :	...</B>
<B>     :	...				CATCH CLAUSE</B>
<B>     :	...</B>
<B>     :catch /{pattern}/</B>
<B>     :	...</B>
<B>     :	...				CATCH CLAUSE</B>
<B>     :	...</B>
<B>     :finally</B>
<B>     :	...</B>
<B>     :	...				FINALLY CLAUSE</B>
<B>     :	...</B>
<B>     :endtry</B>

The try conditional allows to watch code for exceptions and to take the
appropriate actions.  Exceptions from the try block may be caught.  Exceptions
from the try block and also the catch clauses may cause cleanup actions.
   When no exception is thrown during execution of the try block, the <A HREF="intro.html#control">control</A>
is transferred to the finally clause, if present.  After its execution, the
<A HREF="usr_41.html#script">script</A> continues with the line following the &quot;<A HREF="#:endtry">:endtry</A>&quot;.
   When an exception occurs during execution of the try block, the remaining
lines in the try block are skipped.  The exception is matched against the
patterns specified <A HREF="motion.html#as">as</A> arguments to the &quot;<A HREF="#:catch">:catch</A>&quot; commands.  The catch clause
after the first matching &quot;<A HREF="#:catch">:catch</A>&quot; is taken, other catch clauses are not
executed.  The catch clause ends when the next &quot;<A HREF="#:catch">:catch</A>&quot;, &quot;<A HREF="#:finally">:finally</A>&quot;, or
&quot;<A HREF="#:endtry">:endtry</A>&quot; command is reached - whatever is first.  Then, the finally clause
(if present) is executed.  When the &quot;<A HREF="#:endtry">:endtry</A>&quot; is reached, the <A HREF="usr_41.html#script">script</A> execution
continues in the following line <A HREF="motion.html#as">as</A> usual.
   When an exception that does not match any of the patterns specified by the
&quot;<A HREF="#:catch">:catch</A>&quot; commands is thrown in the try block, the exception is not caught by
that try conditional and none of the catch clauses is executed.  Only the
finally clause, if present, is taken.  The exception pends during execution of
the finally clause.  It is resumed at the &quot;<A HREF="#:endtry">:endtry</A>&quot;, so that commands after
the &quot;<A HREF="#:endtry">:endtry</A>&quot; are not executed and the exception might be caught elsewhere,
see |<A HREF="#try-nesting">try-nesting</A>|.
   When during execution of a catch clause another exception is thrown, the
remaining lines in that catch clause are not executed.  The new exception is
not matched against the patterns in any of the &quot;<A HREF="#:catch">:catch</A>&quot; commands of the same
try conditional and none of its catch clauses is taken.  If there is, however,
a finally clause, <A HREF="motion.html#it">it</A> is executed, and the exception pends during its
execution.  The commands following the &quot;<A HREF="#:endtry">:endtry</A>&quot; are not executed.  The new
exception might, however, be caught elsewhere, see |<A HREF="#try-nesting">try-nesting</A>|.
   When during execution of the finally clause (if present) an exception is
thrown, the remaining lines in the finally clause are skipped.  If the finally
clause has been taken because of an exception from the try block or one of the
catch clauses, the original (pending) exception is discarded.  The commands
following the &quot;<A HREF="#:endtry">:endtry</A>&quot; are not executed, and the exception from the finally
clause is propagated and can be caught elsewhere, see |<A HREF="#try-nesting">try-nesting</A>|.

The finally clause is also executed, when a &quot;<A HREF="#:break">:break</A>&quot; or &quot;<A HREF="#:continue">:continue</A>&quot; for
a &quot;<A HREF="#:while">:while</A>&quot; loop enclosing the complete try conditional is executed from the
try block or a catch clause.  Or when a &quot;<A HREF="userfunc.html#:return">:return</A>&quot; or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; is executed
from the try block or a catch clause of a try conditional in a function or
sourced <A HREF="usr_41.html#script">script</A>, respectively.  The &quot;<A HREF="#:break">:break</A>&quot;, &quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="userfunc.html#:return">:return</A>&quot;, or
&quot;<A HREF="repeat.html#:finish">:finish</A>&quot; pends during execution of the finally clause and is resumed when the
&quot;<A HREF="#:endtry">:endtry</A>&quot; is reached.  It is, however, discarded when an exception is thrown
from the finally clause.
   When a &quot;<A HREF="#:break">:break</A>&quot; or &quot;<A HREF="#:continue">:continue</A>&quot; for a &quot;<A HREF="#:while">:while</A>&quot; loop enclosing the complete
try conditional or when a &quot;<A HREF="userfunc.html#:return">:return</A>&quot; or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; is encountered in the finally
clause, the rest of the finally clause is skipped, and the &quot;<A HREF="#:break">:break</A>&quot;,
&quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="userfunc.html#:return">:return</A>&quot; or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; is executed <A HREF="motion.html#as">as</A> usual.  If the finally
clause has been taken because of an exception or an earlier &quot;<A HREF="#:break">:break</A>&quot;,
&quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="userfunc.html#:return">:return</A>&quot;, or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; from the try block or a catch clause,
this pending exception or command is discarded.

For examples see |<A HREF="#throw-catch">throw-catch</A>| and |<A HREF="#try-finally">try-finally</A>|.



NESTING	OF TRY CONDITIONALS				*<A NAME="try-nesting"></A><B>try-nesting</B>*

Try conditionals can be nested arbitrarily.  That is, a complete try
conditional can be put into the try block, a catch clause, or the finally
clause of another try conditional.  If the inner try conditional does not
catch an exception thrown in its try block or throws a new exception from one
of its catch clauses or its finally clause, the outer try conditional is
checked according to the rules above.  If the inner try conditional is in the
try block of the outer try conditional, its catch clauses are checked, but
otherwise only the finally clause is executed.  It does not matter for
nesting, whether the inner try conditional is directly contained in the outer
one, or whether the outer one sources a <A HREF="usr_41.html#script">script</A> or calls a function containing
the inner try conditional.

When none of the active try conditionals catches an exception, just their
finally clauses are executed.  Thereafter, the <A HREF="usr_41.html#script">script</A> processing terminates.
An error message is displayed in <A HREF="change.html#case">case</A> of an uncaught exception explicitly
thrown by a &quot;<A HREF="#:throw">:throw</A>&quot; command.  For uncaught error and interrupt exceptions
implicitly raised by Vim, the error message(s) or interrupt message are shown
<A HREF="motion.html#as">as</A> usual.

For examples see |<A HREF="#throw-catch">throw-catch</A>|.



EXAMINING EXCEPTION HANDLING CODE			*<A NAME="except-examine"></A><B>except-examine</B>*

Exception handling code can get tricky.  If you are in doubt what happens, set
<A HREF="options.html#'verbose'">'verbose'</A> to 13 or use the &quot;:13verbose&quot; command modifier when sourcing your
<A HREF="usr_41.html#script">script</A> file.  Then you see when an exception is thrown, discarded, caught, or
finished.  When using a verbosity level of at least 14, things pending in
a finally clause are also shown.  This information is also given in debug mode
(see |<A HREF="repeat.html#debug-scripts">debug-scripts</A>|).



THROWING AND CATCHING EXCEPTIONS			*<A NAME="throw-catch"></A><B>throw-catch</B>*

You can throw any number or <A HREF="#string">string</A> <A HREF="motion.html#as">as</A> an exception.  Use the |<A HREF="#:throw">:throw</A>| command
and pass the value to be thrown <A HREF="motion.html#as">as</A> argument:
<B>	:throw 4711</B>
<B>	:throw "string"</B>

 							*<A NAME="throw-expression"></A><B>throw-expression</B>*
You can also specify an <A HREF="#expression">expression</A> argument.  The <A HREF="#expression">expression</A> is then evaluated
first, and the result is thrown:
<B>	:throw 4705 + strlen("string")</B>
<B>	:throw strpart("strings", 0, 6)</B>

An exception might be thrown during evaluation of the argument of the &quot;<A HREF="#:throw">:throw</A>&quot;
command.  Unless <A HREF="motion.html#it">it</A> is caught there, the <A HREF="#expression">expression</A> evaluation is abandoned.
The &quot;<A HREF="#:throw">:throw</A>&quot; command then does not throw a new exception.
   Example:

<B>	:function! Foo(arg)</B>
<B>	:  try</B>
<B>	:    throw a:arg</B>
<B>	:  catch /foo/</B>
<B>	:  endtry</B>
<B>	:  return 1</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Bar()</B>
<B>	:  echo "in Bar"</B>
<B>	:  return 4710</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:throw Foo("arrgh") + Bar()</B>

This throws &quot;arrgh&quot;, and &quot;in Bar&quot; is not displayed since Bar() is not
executed.
<B>	:throw Foo("foo") + Bar()</B>
however displays &quot;in Bar&quot; and throws 4711.

Any other command that takes an <A HREF="#expression">expression</A> <A HREF="motion.html#as">as</A> argument might also be
abandoned by an (uncaught) exception during the <A HREF="#expression">expression</A> evaluation.  The
exception is then propagated to the caller of the command.
   Example:

<B>	:if Foo("arrgh")</B>
<B>	:  echo "then"</B>
<B>	:else</B>
<B>	:  echo "else"</B>
<B>	:endif</B>

Here neither of &quot;then&quot; or &quot;else&quot; is displayed.


							*<A NAME="catch-order"></A><B>catch-order</B>*
Exceptions can be caught by a try conditional with one or more |<A HREF="#:catch">:catch</A>|
commands, see |<A HREF="#try-conditionals">try-conditionals</A>|.   The values to be caught by each &quot;<A HREF="#:catch">:catch</A>&quot;
command can be specified <A HREF="motion.html#as">as</A> a <A HREF="pattern.html#pattern">pattern</A> argument.  The subsequent catch clause
gets executed when a matching exception is caught.
   Example:

<B>	:function! Foo(value)</B>
<B>	:  try</B>
<B>	:    throw a:value</B>
<B>	:  catch /^\d\+$/</B>
<B>	:    echo "Number thrown"</B>
<B>	:  catch /.*/</B>
<B>	:    echo "String thrown"</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:call Foo(0x1267)</B>
<B>	:call Foo('string')</B>

The first call to Foo() displays &quot;<A HREF="#Number">Number</A> thrown&quot;, the second &quot;<A HREF="#String">String</A> thrown&quot;.
An exception is matched against the &quot;<A HREF="#:catch">:catch</A>&quot; commands in the order they are
specified.  Only the first match counts.  So you should place the more
specific &quot;<A HREF="#:catch">:catch</A>&quot; first.  The following order does not make sense:

<B>	:  catch /.*/</B>
<B>	:    echo "String thrown"</B>
<B>	:  catch /^\d\+$/</B>
<B>	:    echo "Number thrown"</B>

The first &quot;<A HREF="#:catch">:catch</A>&quot; here matches always, so that the second catch clause is
never taken.


							*<A NAME="throw-variables"></A><B>throw-variables</B>*
If you catch an exception by a general <A HREF="pattern.html#pattern">pattern</A>, you may access the exact value
in the variable YXXYv:exception|:

<B>	:  catch /^\d\+$/</B>
<B>	:    echo "Number thrown.  Value is" v:exception</B>

You may also be interested where an exception was thrown.  This is stored in
|<A HREF="#v:throwpoint">v:throwpoint</A>|.  Note that &quot;<A HREF="#v:exception">v:exception</A>&quot; and &quot;v:throwpoint&quot; are valid for the
exception most recently caught <A HREF="motion.html#as">as</A> long <A HREF="motion.html#it">it</A> is not finished.
   Example:

<B>	:function! Caught()</B>
<B>	:  if v:exception != ""</B>
<B>	:    echo 'Caught "' .. v:exception .. '" in ' .. v:throwpoint</B>
<B>	:  else</B>
<B>	:    echo 'Nothing caught'</B>
<B>	:  endif</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Foo()</B>
<B>	:  try</B>
<B>	:    try</B>
<B>	:      try</B>
<B>	:	 throw 4711</B>
<B>	:      finally</B>
<B>	:	 call Caught()</B>
<B>	:      endtry</B>
<B>	:    catch /.*/</B>
<B>	:      call Caught()</B>
<B>	:      throw "oops"</B>
<B>	:    endtry</B>
<B>	:  catch /.*/</B>
<B>	:    call Caught()</B>
<B>	:  finally</B>
<B>	:    call Caught()</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:call Foo()</B>

This displays

<B>	Nothing caught</B>
<B>	Caught "4711" in function Foo, line 4</B>
<B>	Caught "oops" in function Foo, line 10</B>
<B>	Nothing caught</B>

A practical example:  The following command &quot;:LineNumber&quot; displays the line
number in the <A HREF="usr_41.html#script">script</A> or function where <A HREF="motion.html#it">it</A> has been used:

<B>	:function! LineNumber()</B>
<B>	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")</B>
<B>	:endfunction</B>
<B>	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry</B>
 

							*<A NAME="try-nested"></A><B>try-nested</B>*
An exception that is not caught by a try conditional can be caught by
a surrounding try conditional:

<B>	:try</B>
<B>	:  try</B>
<B>	:    throw "foo"</B>
<B>	:  catch /foobar/</B>
<B>	:    echo "foobar"</B>
<B>	:  finally</B>
<B>	:    echo "inner finally"</B>
<B>	:  endtry</B>
<B>	:catch /foo/</B>
<B>	:  echo "foo"</B>
<B>	:endtry</B>

The inner try conditional does not catch the exception, just its finally
clause is executed.  The exception is then caught by the outer try
conditional.  The example displays &quot;inner finally&quot; and then &quot;foo&quot;.


							*<A NAME="throw-from-catch"></A><B>throw-from-catch</B>*
You can catch an exception and throw a new one to be caught elsewhere from the
catch clause:

<B>	:function! Foo()</B>
<B>	:  throw "foo"</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Bar()</B>
<B>	:  try</B>
<B>	:    call Foo()</B>
<B>	:  catch /foo/</B>
<B>	:    echo "Caught foo, throw bar"</B>
<B>	:    throw "bar"</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:try</B>
<B>	:  call Bar()</B>
<B>	:catch /.*/</B>
<B>	:  echo "Caught" v:exception</B>
<B>	:endtry</B>

This displays &quot;Caught foo, throw bar&quot; and then &quot;Caught bar&quot;.


							*<A NAME="rethrow"></A><B>rethrow</B>*
There is no real <A HREF="#rethrow">rethrow</A> in the Vim <A HREF="usr_41.html#script">script</A> language, but you may throw
&quot;<A HREF="#v:exception">v:exception</A>&quot; instead:

<B>	:function! Bar()</B>
<B>	:  try</B>
<B>	:    call Foo()</B>
<B>	:  catch /.*/</B>
<B>	:    echo "Rethrow" v:exception</B>
<B>	:    throw v:exception</B>
<B>	:  endtry</B>
<B>	:endfunction</B>

 							*<A NAME="try-echoerr"></A><B>try-echoerr</B>*
Note that this <A HREF="#method">method</A> cannot be used to &quot;<A HREF="#rethrow">rethrow</A>&quot; Vim error or interrupt
exceptions, because <A HREF="motion.html#it">it</A> is not possible to fake Vim internal exceptions.
Trying so causes an error exception.  You should throw your own exception
denoting the situation.  If you want to cause a Vim error exception containing
the original error exception value, you can use the |<A HREF="#:echoerr">:echoerr</A>| command:

<B>	:try</B>
<B>	:  try</B>
<B>	:    asdf</B>
<B>	:  catch /.*/</B>
<B>	:    echoerr v:exception</B>
<B>	:  endtry</B>
<B>	:catch /.*/</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>

This code displays

<B><FONT COLOR="PURPLE">	Vim(echoerr):Vim:E492: Not an editor command:	asdf </FONT></B>



CLEANUP CODE						*<A NAME="try-finally"></A><B>try-finally</B>*

Scripts often change global settings and restore them at their end.  If the
user however interrupts the <A HREF="usr_41.html#script">script</A> by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>, the settings remain in
an inconsistent state.  The same may happen to you in the <A HREF="develop.html#development">development</A> phase of
a <A HREF="usr_41.html#script">script</A> when an error occurs or you explicitly throw an exception without
catching <A HREF="motion.html#it">it</A>.  You can solve these problems by using a try conditional with
a finally clause for restoring the settings.  Its execution is guaranteed on
normal <A HREF="intro.html#control">control</A> flow, on error, on an explicit &quot;<A HREF="#:throw">:throw</A>&quot;, and on interrupt.
(Note that <A HREF="message.html#errors">errors</A> and interrupts from inside the try conditional are converted
to exceptions.  When not caught, they terminate the <A HREF="usr_41.html#script">script</A> after the finally
clause has been executed.)
Example:

<B>	:try</B>
<B>	:  let s:saved_ts = &amp;ts</B>
<B>	:  set ts=17</B>
<B>	:</B>
<B>	:  " Do the hard work here.</B>
<B>	:</B>
<B>	:finally</B>
<B>	:  let &amp;ts = s:saved_ts</B>
<B>	:  unlet s:saved_ts</B>
<B>	:endtry</B>

This <A HREF="#method">method</A> should be used locally whenever a function or part of a <A HREF="usr_41.html#script">script</A>
changes global settings which need to be restored on failure or normal exit of
that function or <A HREF="usr_41.html#script">script</A> part.


							*<A NAME="break-finally"></A><B>break-finally</B>*
Cleanup code works also when the try block or a catch clause is left by
a &quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:break">:break</A>&quot;, &quot;<A HREF="userfunc.html#:return">:return</A>&quot;, or &quot;<A HREF="repeat.html#:finish">:finish</A>&quot;.
   Example:

<B>	:let first = 1</B>
<B>	:while 1</B>
<B>	:  try</B>
<B>	:    if first</B>
<B>	:      echo "first"</B>
<B>	:      let first = 0</B>
<B>	:      continue</B>
<B>	:    else</B>
<B>	:      throw "second"</B>
<B>	:    endif</B>
<B>	:  catch /.*/</B>
<B>	:    echo v:exception</B>
<B>	:    break</B>
<B>	:  finally</B>
<B>	:    echo "cleanup"</B>
<B>	:  endtry</B>
<B>	:  echo "still in while"</B>
<B>	:endwhile</B>
<B>	:echo "end"</B>

This displays &quot;first&quot;, &quot;cleanup&quot;, &quot;second&quot;, &quot;cleanup&quot;, and &quot;end&quot;.

<B>	:function! Foo()</B>
<B>	:  try</B>
<B>	:    return 4711</B>
<B>	:  finally</B>
<B>	:    echo "cleanup\n"</B>
<B>	:  endtry</B>
<B>	:  echo "Foo still active"</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:echo Foo() "returned by Foo"</B>

This displays &quot;cleanup&quot; and &quot;4711 returned by Foo&quot;.  You don't need to add an
extra &quot;<A HREF="userfunc.html#:return">:return</A>&quot; in the finally clause.  (Above all, this would override the
return value.)


							*<A NAME="except-from-finally"></A><B>except-from-finally</B>*
Using either of &quot;<A HREF="#:continue">:continue</A>&quot;, &quot;<A HREF="#:break">:break</A>&quot;, &quot;<A HREF="userfunc.html#:return">:return</A>&quot;, &quot;<A HREF="repeat.html#:finish">:finish</A>&quot;, or &quot;<A HREF="#:throw">:throw</A>&quot; in
a finally clause is possible, but not recommended since <A HREF="motion.html#it">it</A> abandons the
cleanup actions for the try conditional.  But, of course, interrupt and error
exceptions might get raised from a finally clause.
   Example where an error in the finally clause stops an interrupt from
working correctly:

<B>	:try</B>
<B>	:  try</B>
<B>	:    echo "Press CTRL-C for interrupt"</B>
<B>	:    while 1</B>
<B>	:    endwhile</B>
<B>	:  finally</B>
<B>	:    unlet novar</B>
<B>	:  endtry</B>
<B>	:catch /novar/</B>
<B>	:endtry</B>
<B>	:echo "Script still running"</B>
<B>	:sleep 1</B>

If you need to put commands that could fail into a finally clause, you should
think about catching or ignoring the <A HREF="message.html#errors">errors</A> in these commands, see
|<A HREF="#catch-errors">catch-errors</A>| and |<A HREF="#ignore-errors">ignore-errors</A>|.



CATCHING ERRORS						*<A NAME="catch-errors"></A><B>catch-errors</B>*

If you want to catch specific <A HREF="message.html#errors">errors</A>, you just have to put the code to be
watched in a try block and add a catch clause for the error message.  The
presence of the try conditional causes all <A HREF="message.html#errors">errors</A> to be converted to an
exception.  No message is displayed and |<A HREF="#v:errmsg">v:errmsg</A>| is not set then.  To find
the right <A HREF="pattern.html#pattern">pattern</A> for the &quot;<A HREF="#:catch">:catch</A>&quot; command, you have to know how the format of
the error exception is.
   Error exceptions have the following format:

<B>	Vim({cmdname}):{errmsg}</B>
or
<B>	Vim:{errmsg}</B>

{cmdname} is the name of the command that failed; the second form is used when
the command name is not known.  {errmsg} is the error message usually produced
when the error occurs outside try conditionals.  It always begins with
a capital &quot;<A HREF="motion.html#E">E</A>&quot;, followed by a two or three-digit error number, a colon, and
a space.

Examples:

The command
<B>	:unlet novar</B>
normally produces the error message
<B>	E108: No such variable: "novar"</B>
which is converted inside try conditionals to an exception
<B>	Vim(unlet):E108: No such variable: "novar"</B>

The command
<B>	:dwim</B>
normally produces the error message
<B>	E492: Not an editor command: dwim</B>
which is converted inside try conditionals to an exception
<B>	Vim:E492: Not an editor command: dwim</B>

You can catch all &quot;<A HREF="#:unlet">:unlet</A>&quot; <A HREF="message.html#errors">errors</A> by a
<B>	:catch /^Vim(unlet):/</B>
or all <A HREF="message.html#errors">errors</A> for misspelled command names by a
<B>	:catch /^Vim:E492:/</B>

Some error <A HREF="message.html#messages">messages</A> may be produced by different commands:
<B>	:function nofunc</B>
and
<B>	:delfunction nofunc</B>
both produce the error message
<B>	E128: Function name must start with a capital: nofunc</B>
which is converted inside try conditionals to an exception
<B>	Vim(function):E128: Function name must start with a capital: nofunc</B>
or
<B>	Vim(delfunction):E128: Function name must start with a capital: nofunc</B>
respectively.  You can catch the error by its number independently on the
command that caused <A HREF="motion.html#it">it</A> if you use the following <A HREF="pattern.html#pattern">pattern</A>:
<B>	:catch /^Vim(\a\+):E128:/</B>

Some commands like
<B>	:let x = novar</B>
produce multiple error <A HREF="message.html#messages">messages</A>, here:
<B>	E121: Undefined variable: novar</B>
<B>	E15: Invalid expression:  novar</B>
Only the first is used for the exception value, since <A HREF="motion.html#it">it</A> is the most specific
one (see |<A HREF="#except-several-errors">except-several-errors</A>|).  So you can catch <A HREF="motion.html#it">it</A> by
<B>	:catch /^Vim(\a\+):E121:/</B>

You can catch all <A HREF="message.html#errors">errors</A> related to the name &quot;nofunc&quot; by
<B>	:catch /\&lt;nofunc\&gt;/</B>

You can catch all Vim <A HREF="message.html#errors">errors</A> in the &quot;<A HREF="editing.html#:write">:write</A>&quot; and &quot;<A HREF="insert.html#:read">:read</A>&quot; commands by
<B>	:catch /^Vim(\(write\|read\)):E\d\+:/</B>

You can catch all Vim <A HREF="message.html#errors">errors</A> by the <A HREF="pattern.html#pattern">pattern</A>
<B>	:catch /^Vim\((\a\+)\)\=:E\d\+:/</B>
 

							*<A NAME="catch-text"></A><B>catch-text</B>*
NOTE: You should never catch the error message text itself:
<B>	:catch /No such variable/</B>
only works in the English <A HREF="mbyte.html#locale">locale</A>, but not when the user has selected
a different language by the |<A HREF="mlang.html#:language">:language</A>| command.  It is however helpful to
cite the message text in a comment:
<B>	:catch /^Vim(\a\+):E108:/   " No such variable</B>



IGNORING ERRORS						*<A NAME="ignore-errors"></A><B>ignore-errors</B>*

You can ignore <A HREF="message.html#errors">errors</A> in a specific Vim command by catching them locally:

<B>	:try</B>
<B>	:  write</B>
<B>	:catch</B>
<B>	:endtry</B>

But you are strongly recommended NOT to use this simple form, since <A HREF="motion.html#it">it</A> could
catch more than you want.  With the &quot;<A HREF="editing.html#:write">:write</A>&quot; command, some autocommands could
be executed and cause <A HREF="message.html#errors">errors</A> not related to <A HREF="editing.html#writing">writing</A>, for instance:

<B>	:au BufWritePre * unlet novar</B>

There could even be such <A HREF="message.html#errors">errors</A> you are not responsible for <A HREF="motion.html#as">as</A> a <A HREF="usr_41.html#script">script</A>
writer: a user of your <A HREF="usr_41.html#script">script</A> might have defined such autocommands.  You would
then hide the error from the user.
   It is much better to use

<B>	:try</B>
<B>	:  write</B>
<B>	:catch /^Vim(write):/</B>
<B>	:endtry</B>

which only catches real write <A HREF="message.html#errors">errors</A>.  So catch only what you'd like to ignore
intentionally.

For a single command that does not cause execution of autocommands, you could
even suppress the conversion of <A HREF="message.html#errors">errors</A> to exceptions by the &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;
command:
<B>	:silent! nunmap k</B>
This works also when a try conditional is active.



CATCHING INTERRUPTS					*<A NAME="catch-interrupt"></A><B>catch-interrupt</B>*

When there are active try conditionals, an interrupt (CTRL-C) is converted to
the exception &quot;Vim:Interrupt&quot;.  You can catch <A HREF="motion.html#it">it</A> like every exception.  The
<A HREF="usr_41.html#script">script</A> is not terminated, then.
   Example:

<B>	:function! TASK1()</B>
<B>	:  sleep 10</B>
<B>	:endfunction</B>

<B>	:function! TASK2()</B>
<B>	:  sleep 20</B>
<B>	:endfunction</B>

<B>	:while 1</B>
<B>	:  let command = input("Type a command: ")</B>
<B>	:  try</B>
<B>	:    if command == ""</B>
<B>	:      continue</B>
<B>	:    elseif command == "END"</B>
<B>	:      break</B>
<B>	:    elseif command == "TASK1"</B>
<B>	:      call TASK1()</B>
<B>	:    elseif command == "TASK2"</B>
<B>	:      call TASK2()</B>
<B>	:    else</B>
<B>	:      echo "\nIllegal command:" command</B>
<B>	:      continue</B>
<B>	:    endif</B>
<B>	:  catch /^Vim:Interrupt$/</B>
<B>	:    echo "\nCommand interrupted"</B>
<B>	:    " Caught the interrupt.  Continue with next prompt.</B>
<B>	:  endtry</B>
<B>	:endwhile</B>

You can interrupt a task here by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>; the <A HREF="usr_41.html#script">script</A> then asks for
a new command.  If you press <A HREF="pattern.html#CTRL-C">CTRL-C</A> at the prompt, the <A HREF="usr_41.html#script">script</A> is terminated.

For <A HREF="testing.html#testing">testing</A> what happens when <A HREF="pattern.html#CTRL-C">CTRL-C</A> would be pressed on a specific line in
your <A HREF="usr_41.html#script">script</A>, use the debug mode and execute the |<A HREF="repeat.html#&gt;quit">&gt;quit</A>| or |<A HREF="repeat.html#&gt;interrupt">&gt;interrupt</A>|
command on that line.  See |<A HREF="repeat.html#debug-scripts">debug-scripts</A>|.



CATCHING ALL						*<A NAME="catch-all"></A><B>catch-all</B>*

The commands

<B>	:catch /.*/</B>
<B>	:catch //</B>
<B>	:catch</B>

catch everything, error exceptions, interrupt exceptions and exceptions
explicitly thrown by the |<A HREF="#:throw">:throw</A>| command.  This is useful at the top level of
a <A HREF="usr_41.html#script">script</A> in order to catch unexpected things.
   Example:

<B>	:try</B>
<B>	:</B>
<B>	:  " do the hard work here</B>
<B>	:</B>
<B>	:catch /MyException/</B>
<B>	:</B>
<B>	:  " handle known problem</B>
<B>	:</B>
<B>	:catch /^Vim:Interrupt$/</B>
<B>	:    echo "Script interrupted"</B>
<B>	:catch /.*/</B>
<B>	:  echo "Internal error (" .. v:exception .. ")"</B>
<B>	:  echo " - occurred at " .. v:throwpoint</B>
<B>	:endtry</B>
<B>	:" end of script</B>

Note: Catching all might catch more things than you want.  Thus, you are
strongly encouraged to catch only for problems that you can really handle by
specifying a <A HREF="pattern.html#pattern">pattern</A> argument to the &quot;<A HREF="#:catch">:catch</A>&quot;.
   Example: Catching all could make <A HREF="motion.html#it">it</A> nearly impossible to interrupt a <A HREF="usr_41.html#script">script</A>
by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>:

<B>	:while 1</B>
<B>	:  try</B>
<B>	:    sleep 1</B>
<B>	:  catch</B>
<B>	:  endtry</B>
<B>	:endwhile</B>



EXCEPTIONS AND AUTOCOMMANDS				*<A NAME="except-autocmd"></A><B>except-autocmd</B>*

Exceptions may be used during execution of autocommands.  Example:

<B>	:autocmd User x try</B>
<B>	:autocmd User x   throw "Oops!"</B>
<B>	:autocmd User x catch</B>
<B>	:autocmd User x   echo v:exception</B>
<B>	:autocmd User x endtry</B>
<B>	:autocmd User x throw "Arrgh!"</B>
<B>	:autocmd User x echo "Should not be displayed"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  doautocmd User x</B>
<B>	:catch</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>

This displays &quot;Oops!&quot; and &quot;Arrgh!&quot;.


							*<A NAME="except-autocmd-Pre"></A><B>except-autocmd-Pre</B>*
For some commands, autocommands get executed before the main action of the
command takes place.  If an exception is thrown and not caught in the sequence
of autocommands, the sequence and the command that caused its execution are
abandoned and the exception is propagated to the caller of the command.
   Example:

<B>	:autocmd BufWritePre * throw "FAIL"</B>
<B>	:autocmd BufWritePre * echo "Should not be displayed"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write</B>
<B>	:catch</B>
<B>	:  echo "Caught:" v:exception "from" v:throwpoint</B>
<B>	:endtry</B>

Here, the &quot;<A HREF="editing.html#:write">:write</A>&quot; command does not write the file currently being edited (as
you can see by checking 'modified'), since the exception from the <A HREF="autocmd.html#BufWritePre">BufWritePre</A>
<A HREF="autocmd.html#autocommand">autocommand</A> abandons the &quot;<A HREF="editing.html#:write">:write</A>&quot;.  The exception is then caught and the
<A HREF="usr_41.html#script">script</A> displays:

<B>	Caught: FAIL from BufWrite Auto commands for "*"</B>
 

							*<A NAME="except-autocmd-Post"></A><B>except-autocmd-Post</B>*
For some commands, autocommands get executed after the main action of the
command has taken place.  If this main action fails and the command is inside
an active try conditional, the autocommands are skipped and an error exception
is thrown that can be caught by the caller of the command.
   Example:

<B>	:autocmd BufWritePost * echo "File successfully written!"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write /i/m/p/o/s/s/i/b/l/e</B>
<B>	:catch</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>

This just displays:

<B>	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)</B>

If you really need to execute the autocommands even when the main action
fails, trigger the event from the catch clause.
   Example:

<B>	:autocmd BufWritePre  * set noreadonly</B>
<B>	:autocmd BufWritePost * set readonly</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write /i/m/p/o/s/s/i/b/l/e</B>
<B>	:catch</B>
<B>	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e</B>
<B>	:endtry</B>
 
You can also use &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;:

<B>	:let x = "ok"</B>
<B>	:let v:errmsg = ""</B>
<B>	:autocmd BufWritePost * if v:errmsg != ""</B>
<B>	:autocmd BufWritePost *   let x = "after fail"</B>
<B>	:autocmd BufWritePost * endif</B>
<B>	:try</B>
<B>	:  silent! write /i/m/p/o/s/s/i/b/l/e</B>
<B>	:catch</B>
<B>	:endtry</B>
<B>	:echo x</B>

This displays &quot;after fail&quot;.

If the main action of the command does not fail, exceptions from the
autocommands will be catchable by the caller of the command: 

<B>	:autocmd BufWritePost * throw ":-("</B>
<B>	:autocmd BufWritePost * echo "Should not be displayed"</B>
<B>	:</B>
<B>	:try</B>
<B>	:  write</B>
<B>	:catch</B>
<B>	:  echo v:exception</B>
<B>	:endtry</B>
 

							*<A NAME="except-autocmd-Cmd"></A><B>except-autocmd-Cmd</B>*
For some commands, the normal action can be replaced by a sequence of
autocommands.  Exceptions from that sequence will be catchable by the caller
of the command.
   Example:  For the &quot;<A HREF="editing.html#:write">:write</A>&quot; command, the caller cannot know whether the file
had actually been written when the exception occurred.  You need to tell <A HREF="motion.html#it">it</A> in
some way.

<B>	:if !exists("cnt")</B>
<B>	:  let cnt = 0</B>
<B>	:</B>
<B>	:  autocmd BufWriteCmd * if &amp;modified</B>
<B>	:  autocmd BufWriteCmd *   let cnt = cnt + 1</B>
<B>	:  autocmd BufWriteCmd *   if cnt % 3 == 2</B>
<B>	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</B>
<B>	:  autocmd BufWriteCmd *   endif</B>
<B>	:  autocmd BufWriteCmd *   write | set nomodified</B>
<B>	:  autocmd BufWriteCmd *   if cnt % 3 == 0</B>
<B>	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"</B>
<B>	:  autocmd BufWriteCmd *   endif</B>
<B>	:  autocmd BufWriteCmd *   echo "File successfully written!"</B>
<B>	:  autocmd BufWriteCmd * endif</B>
<B>	:endif</B>
<B>	:</B>
<B>	:try</B>
<B>	:	write</B>
<B>	:catch /^BufWriteCmdError$/</B>
<B>	:  if &amp;modified</B>
<B>	:    echo "Error on writing (file contents not changed)"</B>
<B>	:  else</B>
<B>	:    echo "Error after writing"</B>
<B>	:  endif</B>
<B>	:catch /^Vim(write):/</B>
<B>	:    echo "Error on writing"</B>
<B>	:endtry</B>

When this <A HREF="usr_41.html#script">script</A> is sourced several times after making changes, <A HREF="motion.html#it">it</A> displays
first
<B>	File successfully written!</B>
then
<B>	Error on writing (file contents not changed)</B>
then
<B>	Error after writing</B>
etc.


							*<A NAME="except-autocmd-ill"></A><B>except-autocmd-ill</B>*
You cannot spread a try conditional over autocommands for different <A HREF="autocmd.html#events">events</A>.
The following code is ill-formed:

<B>	:autocmd BufWritePre  * try</B>
<B>	:</B>
<B>	:autocmd BufWritePost * catch</B>
<B>	:autocmd BufWritePost *   echo v:exception</B>
<B>	:autocmd BufWritePost * endtry</B>
<B>	:</B>
<B>	:write</B>



EXCEPTION HIERARCHIES AND PARAMETERIZED EXCEPTIONS	*<A NAME="except-hier-param"></A><B>except-hier-param</B>*

Some programming languages allow to use hierarchies of exception classes or to
pass additional information with the object of an exception class.  You can <A HREF="diff.html#do">do</A>
similar things in Vim.
   In order to throw an exception from a hierarchy, just throw the complete
class name with the components separated by a colon, for instance throw the
<A HREF="#string">string</A> &quot;EXCEPT:MATHERR:OVERFLOW&quot; for an overflow in a mathematical library.
   When you want to pass additional information with your exception class, add
<A HREF="motion.html#it">it</A> in parentheses, for instance throw the <A HREF="#string">string</A> &quot;EXCEPT:IO:WRITEERR(myfile)&quot;
for an error when <A HREF="editing.html#writing">writing</A> &quot;myfile&quot;.
   With the appropriate patterns in the &quot;<A HREF="#:catch">:catch</A>&quot; command, you can catch for
base classes or derived classes of your hierarchy.  Additional information in
parentheses can be cut out from |<A HREF="#v:exception">v:exception</A>| with the &quot;<A HREF="change.html#:substitute">:substitute</A>&quot; command.
   Example:

<B>	:function! CheckRange(a, func)</B>
<B>	:  if a:a &lt; 0</B>
<B>	:    throw "EXCEPT:MATHERR:RANGE(" .. a:func .. ")"</B>
<B>	:  endif</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Add(a, b)</B>
<B>	:  call CheckRange(a:a, "Add")</B>
<B>	:  call CheckRange(a:b, "Add")</B>
<B>	:  let c = a:a + a:b</B>
<B>	:  if c &lt; 0</B>
<B>	:    throw "EXCEPT:MATHERR:OVERFLOW"</B>
<B>	:  endif</B>
<B>	:  return c</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Div(a, b)</B>
<B>	:  call CheckRange(a:a, "Div")</B>
<B>	:  call CheckRange(a:b, "Div")</B>
<B>	:  if (a:b == 0)</B>
<B>	:    throw "EXCEPT:MATHERR:ZERODIV"</B>
<B>	:  endif</B>
<B>	:  return a:a / a:b</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:function! Write(file)</B>
<B>	:  try</B>
<B>	:    execute "write" fnameescape(a:file)</B>
<B>	:  catch /^Vim(write):/</B>
<B>	:    throw "EXCEPT:IO(" .. getcwd() .. ", " .. a:file .. "):WRITEERR"</B>
<B>	:  endtry</B>
<B>	:endfunction</B>
<B>	:</B>
<B>	:try</B>
<B>	:</B>
<B>	:  " something with arithmetic and I/O</B>
<B>	:</B>
<B>	:catch /^EXCEPT:MATHERR:RANGE/</B>
<B>	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")</B>
<B>	:  echo "Range error in" function</B>
<B>	:</B>
<B>	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV</B>
<B>	:  echo "Math error"</B>
<B>	:</B>
<B>	:catch /^EXCEPT:IO/</B>
<B>	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")</B>
<B>	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")</B>
<B>	:  if file !~ '^/'</B>
<B>	:    let file = dir .. "/" .. file</B>
<B>	:  endif</B>
<B>	:  echo 'I/O error for "' .. file .. '"'</B>
<B>	:</B>
<B>	:catch /^EXCEPT/</B>
<B>	:  echo "Unspecified error"</B>
<B>	:</B>
<B>	:endtry</B>

The exceptions raised by Vim itself (on error or when pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>) use
a flat hierarchy:  they are all in the &quot;Vim&quot; class.  You cannot throw yourself
exceptions with the &quot;Vim&quot; prefix; they are reserved for Vim.
   Vim error exceptions are parameterized with the name of the command that
failed, if known.  See |<A HREF="#catch-errors">catch-errors</A>|.


PECULIARITIES

							*<A NAME="except-compat"></A><B>except-compat</B>*
The exception handling concept requires that the command sequence causing the
exception is aborted immediately and <A HREF="intro.html#control">control</A> is transferred to finally clauses
and/or a catch clause.

In the Vim <A HREF="usr_41.html#script">script</A> language there are cases where scripts and <A HREF="#functions">functions</A>
continue after an error: in <A HREF="#functions">functions</A> without the &quot;abort&quot; flag or in a command
after &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;, <A HREF="intro.html#control">control</A> flow goes to the following line, and outside
<A HREF="#functions">functions</A>, <A HREF="intro.html#control">control</A> flow goes to the line following the outermost &quot;<A HREF="#:endwhile">:endwhile</A>&quot;
or &quot;<A HREF="#:endif">:endif</A>&quot;.  On the other hand, <A HREF="message.html#errors">errors</A> should be catchable <A HREF="motion.html#as">as</A> exceptions
(thus, requiring the immediate abortion).

This problem has been solved by converting <A HREF="message.html#errors">errors</A> to exceptions and using
immediate abortion (if not suppressed by &quot;<A HREF="various.html#:silent!">:silent!</A>&quot;) only when a try
conditional is active.  This is no restriction since an (error) exception can
be caught only from an active try conditional.  If you want an immediate
termination without catching the error, just use a try conditional without
catch clause.  (You can cause cleanup code being executed before termination
by specifying a finally clause.)

When no try conditional is active, the usual abortion and continuation
behavior is used instead of immediate abortion.  This ensures compatibility of
scripts written for Vim 6.1 and earlier.

However, when sourcing an existing <A HREF="usr_41.html#script">script</A> that does not use exception handling
commands (or when calling one of its <A HREF="#functions">functions</A>) from inside an active try
conditional of a new <A HREF="usr_41.html#script">script</A>, you might change the <A HREF="intro.html#control">control</A> flow of the existing
<A HREF="usr_41.html#script">script</A> on error.  You get the immediate abortion on error and can catch the
error in the new <A HREF="usr_41.html#script">script</A>.  If however the sourced <A HREF="usr_41.html#script">script</A> suppresses error
<A HREF="message.html#messages">messages</A> by using the &quot;<A HREF="various.html#:silent!">:silent!</A>&quot; command (checking for <A HREF="message.html#errors">errors</A> by <A HREF="testing.html#testing">testing</A>
|<A HREF="#v:errmsg">v:errmsg</A>| if appropriate), its execution path is not changed.  The error is
not converted to an exception.  (See |<A HREF="various.html#:silent">:silent</A>|.)  So the only remaining cause
where this happens is for scripts that don't care about <A HREF="message.html#errors">errors</A> and produce
error <A HREF="message.html#messages">messages</A>.  You probably won't want to use such code from your new
scripts.


							*<A NAME="except-syntax-err"></A><B>except-syntax-err</B>*
<A HREF="autocmd.html#Syntax">Syntax</A> <A HREF="message.html#errors">errors</A> in the exception handling commands are never caught by any of
the &quot;<A HREF="#:catch">:catch</A>&quot; commands of the try conditional they belong to.  Its finally
clauses, however, is executed.
   Example:

<B>	:try</B>
<B>	:  try</B>
<B>	:    throw 4711</B>
<B>	:  catch /\(/</B>
<B>	:    echo "in catch with syntax error"</B>
<B>	:  catch</B>
<B>	:    echo "inner catch-all"</B>
<B>	:  finally</B>
<B>	:    echo "inner finally"</B>
<B>	:  endtry</B>
<B>	:catch</B>
<B>	:  echo 'outer catch-all caught "' .. v:exception .. '"'</B>
<B>	:  finally</B>
<B>	:    echo "outer finally"</B>
<B>	:endtry</B>

This displays:
<B>    inner finally</B>
<B>    outer catch-all caught "Vim(catch):E54: Unmatched \("</B>
<B>    outer finally</B>
The original exception is discarded and an error exception is raised, instead.


							*<A NAME="except-single-line"></A><B>except-single-line</B>*
The &quot;<A HREF="#:try">:try</A>&quot;, &quot;<A HREF="#:catch">:catch</A>&quot;, &quot;<A HREF="#:finally">:finally</A>&quot;, and &quot;<A HREF="#:endtry">:endtry</A>&quot; commands can be put on
a single line, but then <A HREF="syntax.html#syntax">syntax</A> <A HREF="message.html#errors">errors</A> may make <A HREF="motion.html#it">it</A> difficult to recognize the
&quot;catch&quot; line, thus you better avoid this.
   Example:
<B>	:try | unlet! foo # | catch | endtry</B>
raises an error exception for the trailing characters after the &quot;:unlet!&quot;
argument, but does not see the &quot;<A HREF="#:catch">:catch</A>&quot; and &quot;<A HREF="#:endtry">:endtry</A>&quot; commands, so that the
error exception is discarded and the &quot;E488: Trailing characters&quot; message gets
displayed.


							*<A NAME="except-several-errors"></A><B>except-several-errors</B>*
When several <A HREF="message.html#errors">errors</A> appear in a single command, the first error message is
usually the most specific one and therefore converted to the error exception.
   Example:
<B>	echo novar</B>
causes
<B>	E121: Undefined variable: novar</B>
<B>	E15: Invalid expression: novar</B>
The value of the error exception inside try conditionals is:
<B>	Vim(echo):E121: Undefined variable: novar</B>

 							*<A NAME="except-syntax-error"></A><B>except-syntax-error</B>*
But when a <A HREF="syntax.html#syntax">syntax</A> error is detected after a normal error in the same command,
the <A HREF="syntax.html#syntax">syntax</A> error is used for the exception being thrown.
   Example:
<B>	unlet novar #</B>
causes
<B>	E108: No such variable: "novar"</B>
<B>	E488: Trailing characters</B>
The value of the error exception inside try conditionals is:
<B>	Vim(unlet):E488: Trailing characters</B>
This is done because the <A HREF="syntax.html#syntax">syntax</A> error might change the execution path in a way
not intended by the user.  Example:
<B>	try</B>
<B>	    try | unlet novar # | catch | echo v:exception | endtry</B>
<B>	catch /.*/</B>
<B>	    echo "outer catch:" v:exception</B>
<B>	endtry</B>
This displays &quot;outer catch: Vim(unlet):E488: Trailing characters&quot;, and then
a &quot;E600: Missing :endtry&quot; error message is given, see |<A HREF="#except-single-line">except-single-line</A>|.

==============================================================================

9. Examples						*<A NAME="eval-examples"></A><B>eval-examples</B>*

<B><FONT COLOR="PURPLE">Printing in Binary </FONT></B>

<B>  :" The function Nr2Bin() returns the binary string representation of a number.</B>
<B>  :func Nr2Bin(nr)</B>
<B>  :  let n = a:nr</B>
<B>  :  let r = ""</B>
<B>  :  while n</B>
<B>  :    let r = '01'[n % 2] .. r</B>
<B>  :    let n = n / 2</B>
<B>  :  endwhile</B>
<B>  :  return r</B>
<B>  :endfunc</B>

<B>  :" The function String2Bin() converts each character in a string to a</B>
<B>  :" binary string, separated with dashes.</B>
<B>  :func String2Bin(str)</B>
<B>  :  let out = ''</B>
<B>  :  for ix in range(strlen(a:str))</B>
<B>  :    let out = out .. '-' .. Nr2Bin(char2nr(a:str[ix]))</B>
<B>  :  endfor</B>
<B>  :  return out[1:]</B>
<B>  :endfunc</B>

Example of its use:
<B>  :echo Nr2Bin(32)</B>
result: &quot;100000&quot;
<B>  :echo String2Bin("32")</B>
result: &quot;110011-110010&quot;


<B><FONT COLOR="PURPLE">Sorting lines </FONT></B>

This example sorts lines with a specific compare function.

<B>  :func SortBuffer()</B>
<B>  :  let lines = getline(1, '$')</B>
<B>  :  call sort(lines, function("Strcmp"))</B>
<B>  :  call setline(1, lines)</B>
<B>  :endfunction</B>

As a one-liner:
<B>  :call setline(1, sort(getline(1, '$'), function("Strcmp")))</B>
 

<B><FONT COLOR="PURPLE">scanf() replacement </FONT></B>

							*<A NAME="sscanf"></A><B>sscanf</B>*
There is no sscanf() function in Vim.  If you need to extract parts from a
line, you can use <A HREF="builtin.html#matchstr()">matchstr()</A> and <A HREF="builtin.html#substitute()">substitute()</A> to <A HREF="diff.html#do">do</A> <A HREF="motion.html#it">it</A>.  This example shows
how to get the file name, line number and column number out of a line like
&quot;foobar.txt, 123, 45&quot;.
<B>   :" Set up the match bit</B>
<B>   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'</B>
<B>   :"get the part matching the whole expression</B>
<B>   :let l = matchstr(line, mx)</B>
<B>   :"get each item out of the match</B>
<B>   :let file = substitute(l, mx, '\1', '')</B>
<B>   :let lnum = substitute(l, mx, '\2', '')</B>
<B>   :let col = substitute(l, mx, '\3', '')</B>

The input is in the variable &quot;line&quot;, the results in the <A HREF="#variables">variables</A> &quot;file&quot;,
&quot;lnum&quot; and &quot;col&quot;. (idea from Michael Geddes)


<B><FONT COLOR="PURPLE">getting the scriptnames in a Dictionary </FONT></B>

						*<A NAME="scriptnames-dictionary"></A><B>scriptnames-dictionary</B>*
The |<A HREF="repeat.html#:scriptnames">:scriptnames</A>| command can be used to get a <A HREF="#list">list</A> of all script files that
have been sourced.  There is no equivalent function or variable for this
(because it's rarely needed).  In <A HREF="change.html#case">case</A> you need to manipulate the <A HREF="#list">list</A> this
code can be used:
<B>    " Get the output of ":scriptnames" in the scriptnames_output variable.</B>
<B>    let scriptnames_output = ''</B>
<B>    redir =&gt; scriptnames_output</B>
<B>    silent scriptnames</B>
<B>    redir END</B>

<B>    " Split the output into lines and parse each line.	Add an entry to the</B>
<B>    " "scripts" dictionary.</B>
<B>    let scripts = {}</B>
<B>    for line in split(scriptnames_output, "\n")</B>
<B>      " Only do non-blank lines.</B>
<B>      if line =~ '\S'</B>
<B>	" Get the first number in the line.</B>
<B>	let nr = matchstr(line, '\d\+')</B>
<B>	" Get the file name, remove the script number " 123: ".</B>
<B>	let name = substitute(line, '.\+:\s*', '', '')</B>
<B>	" Add an item to the Dictionary</B>
<B>	let scripts[nr] = name</B>
<B>      endif</B>
<B>    endfor</B>
<B>    unlet scriptnames_output</B>

==============================================================================

The <A HREF="#sandbox">sandbox</A>					*<A NAME="eval-sandbox"></A><B>eval-sandbox</B>* *<A NAME="sandbox"></A><B>sandbox</B>*

The <A HREF="options.html#'foldexpr'">'foldexpr'</A>, <A HREF="options.html#'formatexpr'">'formatexpr'</A>, <A HREF="options.html#'includeexpr'">'includeexpr'</A>, <A HREF="options.html#'indentexpr'">'indentexpr'</A>, <A HREF="options.html#'statusline'">'statusline'</A> and
<A HREF="options.html#'foldtext'">'foldtext'</A> <A HREF="options.html#options">options</A> may be evaluated in a <A HREF="#sandbox">sandbox</A>.  This means that you are
protected from these expressions having nasty side effects.  This gives some
safety for when these <A HREF="options.html#options">options</A> are set from a <A HREF="options.html#modeline">modeline</A>.  It is also used when
the command from a <A HREF="tagsrch.html#tags">tags</A> file is executed and for <A HREF="undo.html#CTRL-R">CTRL-R</A> = in the command line.
The sandbox is also used for the |<A HREF="#:sandbox">:sandbox</A>| command.


								*<A NAME="E48"></A><B>E48</B>*
These items are not allowed in the <A HREF="#sandbox">sandbox</A>:
	- <A HREF="change.html#changing">changing</A> the buffer text
	- defining or <A HREF="change.html#changing">changing</A> <A HREF="map.html#mapping">mapping</A>, autocommands, user commands
	- setting certain <A HREF="options.html#options">options</A> (see |<A HREF="options.html#option-summary">option-summary</A>|)

	- setting certain v: <A HREF="#variables">variables</A> (see |<A HREF="#v:var">v:var</A>|)  *<A NAME="E794"></A><B>E794</B>*
	- executing a shell command
	- reading or <A HREF="editing.html#writing">writing</A> a file
	- jumping to another buffer or editing a file
	- executing <A HREF="if_pyth.html#Python">Python</A>, Perl, etc. commands
This is not guaranteed 100&#37; secure, but <A HREF="motion.html#it">it</A> should block most attacks.


							*<A NAME=":san"></A><B>:san</B>* *<A NAME=":sandbox"></A><B>:sandbox</B>*
:san[dbox] {cmd}	Execute {cmd} in the <A HREF="#sandbox">sandbox</A>.  Useful to evaluate an
			option that may have been set from a <A HREF="options.html#modeline">modeline</A>, e.g.
			<A HREF="options.html#'foldexpr'">'foldexpr'</A>.


							*<A NAME="sandbox-option"></A><B>sandbox-option</B>*
A few <A HREF="options.html#options">options</A> contain an <A HREF="#expression">expression</A>.  When this <A HREF="#expression">expression</A> is evaluated <A HREF="motion.html#it">it</A> may
have to be done in the <A HREF="#sandbox">sandbox</A> to avoid a security risk.  But the <A HREF="#sandbox">sandbox</A> is
restrictive, thus this only happens when the option was set from an insecure
location.  Insecure in this <A HREF="repeat.html#context">context</A> are:
- sourcing a .nvimrc or .exrc in the current directory
- while executing in the <A HREF="#sandbox">sandbox</A>
- value coming from a <A HREF="options.html#modeline">modeline</A>
- executing a function that was defined in the <A HREF="#sandbox">sandbox</A>

Note that when in the <A HREF="#sandbox">sandbox</A> and saving an option value and restoring <A HREF="motion.html#it">it</A>, the
option will still be marked <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> was set in the <A HREF="#sandbox">sandbox</A>.

==============================================================================

Textlock							*<A NAME="textlock"></A><B>textlock</B>*

In a few situations <A HREF="motion.html#it">it</A> is not allowed to change the text in the buffer, jump
to another <A HREF="windows.html#window">window</A> and some other things that might confuse or break what Vim
is currently doing.  This mostly applies to things that happen when Vim is
actually doing something else.  For example, evaluating the <A HREF="vim_diff.html#'balloonexpr'">'balloonexpr'</A> may
happen any moment the mouse cursor is resting at some position.

This is not allowed when the <A HREF="#textlock">textlock</A> is active:
	- <A HREF="change.html#changing">changing</A> the buffer text
	- jumping to another buffer or <A HREF="windows.html#window">window</A>
	- editing another file
	- closing a <A HREF="windows.html#window">window</A> or quitting Vim
	- etc.

==============================================================================

<A HREF="cmdline.html#Command-line">Command-line</A> expressions highlighting		*<A NAME="expr-highlight"></A><B>expr-highlight</B>*

Expressions entered by the user in |<A HREF="insert.html#i_CTRL-R_=">i_CTRL-R_=</A>|, |<A HREF="cmdline.html#c_CTRL-\_e">c_CTRL-\_e</A>|, |<A HREF="change.html#quote=">quote=</A>| are
highlighted by the built-in expressions parser.  It uses highlight groups
described in the table below, which may be overridden by colorschemes.

							*<A NAME="hl-NvimInvalid"></A><B>hl-NvimInvalid</B>*
Besides the &quot;Nvim&quot;-prefixed highlight groups described below, there are
&quot;NvimInvalid&quot;-prefixed highlight groups which have the same meaning but
indicate that the token contains an error or that an error occurred just
before <A HREF="motion.html#it">it</A>.  They have mostly the same hierarchy, except that (by default) in
place of any non-Nvim-prefixed group NvimInvalid linking to `Error` is used
and some other intermediate groups are present.

<B><FONT COLOR="PURPLE">Group                              Default link            Colored expression </FONT></B>

*<A NAME="hl-NvimInternalError"></A><B>hl-NvimInternalError</B>*               None, red/red           Parser bug


*<A NAME="hl-NvimAssignment"></A><B>hl-NvimAssignment</B>*                  Operator                Generic assignment

*<A NAME="hl-NvimPlainAssignment"></A><B>hl-NvimPlainAssignment</B>*             NvimAssignment          `=` in |<A HREF="#:let">:let</A>|

*<A NAME="hl-NvimAugmentedAssignment"></A><B>hl-NvimAugmentedAssignment</B>*         NvimAssignment          Generic, `+=`/`-=`/`.=`

*<A NAME="hl-NvimAssignmentWithAddition"></A><B>hl-NvimAssignmentWithAddition</B>*      NvimAugmentedAssignment `+=` in |<A HREF="#:let+=">:let+=</A>|

*<A NAME="hl-NvimAssignmentWithSubtraction"></A><B>hl-NvimAssignmentWithSubtraction</B>*   NvimAugmentedAssignment `-=` in |<A HREF="#:let-=">:let-=</A>|

*<A NAME="hl-NvimAssignmentWithConcatenation"></A><B>hl-NvimAssignmentWithConcatenation</B>* NvimAugmentedAssignment `.=` in |<A HREF="#:let.=">:let.=</A>|


*<A NAME="hl-NvimOperator"></A><B>hl-NvimOperator</B>*                    Operator                Generic <A HREF="motion.html#operator">operator</A>


*<A NAME="hl-NvimUnaryOperator"></A><B>hl-NvimUnaryOperator</B>*               NvimOperator            Generic unary op

*<A NAME="hl-NvimUnaryPlus"></A><B>hl-NvimUnaryPlus</B>*                   NvimUnaryOperator       |<A HREF="#expr-unary-+">expr-unary-+</A>|

*<A NAME="hl-NvimUnaryMinus"></A><B>hl-NvimUnaryMinus</B>*                  NvimUnaryOperator       |<A HREF="#expr-unary--">expr-unary--</A>|

*<A NAME="hl-NvimNot"></A><B>hl-NvimNot</B>*                         NvimUnaryOperator       |<A HREF="#expr-!">expr-!</A>|


*<A NAME="hl-NvimBinaryOperator"></A><B>hl-NvimBinaryOperator</B>*              NvimOperator            Generic binary op

*<A NAME="hl-NvimComparison"></A><B>hl-NvimComparison</B>*                  NvimBinaryOperator      Any |<A HREF="#expr4">expr4</A>| <A HREF="motion.html#operator">operator</A>

*<A NAME="hl-NvimComparisonModifier"></A><B>hl-NvimComparisonModifier</B>*          NvimComparison          `#`/`?` near |<A HREF="#expr4">expr4</A>| op

*<A NAME="hl-NvimBinaryPlus"></A><B>hl-NvimBinaryPlus</B>*                  NvimBinaryOperator      |<A HREF="#expr-+">expr-+</A>|

*<A NAME="hl-NvimBinaryMinus"></A><B>hl-NvimBinaryMinus</B>*                 NvimBinaryOperator      |<A HREF="#expr--">expr--</A>|

*<A NAME="hl-NvimConcat"></A><B>hl-NvimConcat</B>*                      NvimBinaryOperator      |<A HREF="#expr-.">expr-.</A>|

*<A NAME="hl-NvimConcatOrSubscript"></A><B>hl-NvimConcatOrSubscript</B>*           NvimConcat              |<A HREF="#expr-.">expr-.</A>| or |<A HREF="#expr-entry">expr-entry</A>|

*<A NAME="hl-NvimOr"></A><B>hl-NvimOr</B>*                          NvimBinaryOperator      |<A HREF="#expr-barbar">expr-barbar</A>|

*<A NAME="hl-NvimAnd"></A><B>hl-NvimAnd</B>*                         NvimBinaryOperator      |<A HREF="#expr-&amp;&amp;">expr-&amp;&amp;</A>|

*<A NAME="hl-NvimMultiplication"></A><B>hl-NvimMultiplication</B>*              NvimBinaryOperator      |<A HREF="#expr-star">expr-star</A>|

*<A NAME="hl-NvimDivision"></A><B>hl-NvimDivision</B>*                    NvimBinaryOperator      |<A HREF="#expr-/">expr-/</A>|

*<A NAME="hl-NvimMod"></A><B>hl-NvimMod</B>*                         NvimBinaryOperator      |<A HREF="#expr-&#37;">expr-&#37;</A>|


*<A NAME="hl-NvimTernary"></A><B>hl-NvimTernary</B>*                     NvimOperator            `?` in |<A HREF="#expr1">expr1</A>|

*<A NAME="hl-NvimTernaryColon"></A><B>hl-NvimTernaryColon</B>*                NvimTernary             `:` in |<A HREF="#expr1">expr1</A>|


*<A NAME="hl-NvimParenthesis"></A><B>hl-NvimParenthesis</B>*                 Delimiter               Generic bracket

*<A NAME="hl-NvimLambda"></A><B>hl-NvimLambda</B>*                      NvimParenthesis         `{`/`}` in |<A HREF="#lambda">lambda</A>|

*<A NAME="hl-NvimNestingParenthesis"></A><B>hl-NvimNestingParenthesis</B>*          NvimParenthesis         `(`/`)` in |<A HREF="#expr-nesting">expr-nesting</A>|

*<A NAME="hl-NvimCallingParenthesis"></A><B>hl-NvimCallingParenthesis</B>*          NvimParenthesis         `(`/`)` in |<A HREF="#expr-function">expr-function</A>|


*<A NAME="hl-NvimSubscript"></A><B>hl-NvimSubscript</B>*                   NvimParenthesis         Generic <A HREF="#subscript">subscript</A>

*<A NAME="hl-NvimSubscriptBracket"></A><B>hl-NvimSubscriptBracket</B>*            NvimSubscript           `[`/`]` in |<A HREF="#expr-[]">expr-[]</A>|

*<A NAME="hl-NvimSubscriptColon"></A><B>hl-NvimSubscriptColon</B>*              NvimSubscript           `:` in |<A HREF="#expr-[:]">expr-[:]</A>|

*<A NAME="hl-NvimCurly"></A><B>hl-NvimCurly</B>*                       NvimSubscript           `{`/`}` in
                                                           |<A HREF="#curly-braces-names">curly-braces-names</A>|


*<A NAME="hl-NvimContainer"></A><B>hl-NvimContainer</B>*                   NvimParenthesis         Generic container

*<A NAME="hl-NvimDict"></A><B>hl-NvimDict</B>*                        NvimContainer           `{`/`}` in |<A HREF="#dict">dict</A>| literal

*<A NAME="hl-NvimList"></A><B>hl-NvimList</B>*                        NvimContainer           `[`/`]` in |<A HREF="#list">list</A>| literal


*<A NAME="hl-NvimIdentifier"></A><B>hl-NvimIdentifier</B>*                  Identifier              Generic identifier

*<A NAME="hl-NvimIdentifierScope"></A><B>hl-NvimIdentifierScope</B>*             NvimIdentifier          Namespace: <A HREF="print.html#letter">letter</A>
                                                           before `:` in
                                                           |<A HREF="#internal-variables">internal-variables</A>|

*<A NAME="hl-NvimIdentifierScopeDelimiter"></A><B>hl-NvimIdentifierScopeDelimiter</B>*    NvimIdentifier          `:` after <A HREF="api.html#namespace">namespace</A>
                                                           <A HREF="print.html#letter">letter</A>

*<A NAME="hl-NvimIdentifierName"></A><B>hl-NvimIdentifierName</B>*              NvimIdentifier          Rest of the ident

*<A NAME="hl-NvimIdentifierKey"></A><B>hl-NvimIdentifierKey</B>*               NvimIdentifier          Identifier after
                                                           |<A HREF="#expr-entry">expr-entry</A>|


*<A NAME="hl-NvimColon"></A><B>hl-NvimColon</B>*                       Delimiter               `:` in |<A HREF="#dict">dict</A>| literal

*<A NAME="hl-NvimComma"></A><B>hl-NvimComma</B>*                       Delimiter               `,` in |<A HREF="#dict">dict</A>| or |<A HREF="#list">list</A>|
                                                           literal or
                                                           |<A HREF="#expr-function">expr-function</A>|

*<A NAME="hl-NvimArrow"></A><B>hl-NvimArrow</B>*                       Delimiter               `-&gt;` in |<A HREF="#lambda">lambda</A>|


*<A NAME="hl-NvimRegister"></A><B>hl-NvimRegister</B>*                    SpecialChar             |<A HREF="#expr-register">expr-register</A>|

*<A NAME="hl-NvimNumber"></A><B>hl-NvimNumber</B>*                      <A HREF="#Number">Number</A>                  Non-prefix digits
                                                           in integer
                                                           |<A HREF="#expr-number">expr-number</A>|

*<A NAME="hl-NvimNumberPrefix"></A><B>hl-NvimNumberPrefix</B>*                Type                    `0` for |<A HREF="#octal-number">octal-number</A>|
                                                           `0x` for |<A HREF="#hex-number">hex-number</A>|
                                                           `0b` for |<A HREF="#binary-number">binary-number</A>|

*<A NAME="hl-NvimFloat"></A><B>hl-NvimFloat</B>*                       NvimNumber              Floating-point
                                                           number


*<A NAME="hl-NvimOptionSigil"></A><B>hl-NvimOptionSigil</B>*                 Type                    `&amp;` in |<A HREF="#expr-option">expr-option</A>|

*<A NAME="hl-NvimOptionScope"></A><B>hl-NvimOptionScope</B>*                 NvimIdentifierScope     Option scope if any

*<A NAME="hl-NvimOptionScopeDelimiter"></A><B>hl-NvimOptionScopeDelimiter</B>*        NvimIdentifierScopeDelimiter
                                                           `:` after option scope

*<A NAME="hl-NvimOptionName"></A><B>hl-NvimOptionName</B>*                  NvimIdentifier          Option name


*<A NAME="hl-NvimEnvironmentSigil"></A><B>hl-NvimEnvironmentSigil</B>*            NvimOptionSigil         `$` in |<A HREF="#expr-env">expr-env</A>|

*<A NAME="hl-NvimEnvironmentName"></A><B>hl-NvimEnvironmentName</B>*             NvimIdentifier          Env variable name


*<A NAME="hl-NvimString"></A><B>hl-NvimString</B>*                      <A HREF="#String">String</A>                  Generic <A HREF="#string">string</A>

*<A NAME="hl-NvimStringBody"></A><B>hl-NvimStringBody</B>*                  NvimString              Generic <A HREF="#string">string</A>
                                                           literal body

*<A NAME="hl-NvimStringQuote"></A><B>hl-NvimStringQuote</B>*                 NvimString              Generic <A HREF="#string">string</A> <A HREF="change.html#quote">quote</A>

*<A NAME="hl-NvimStringSpecial"></A><B>hl-NvimStringSpecial</B>*               SpecialChar             Generic <A HREF="#string">string</A>
                                                           non-literal body


*<A NAME="hl-NvimSingleQuote"></A><B>hl-NvimSingleQuote</B>*                 NvimStringQuote         `'` in |<A HREF="#expr-'">expr-'</A>|

*<A NAME="hl-NvimSingleQuotedBody"></A><B>hl-NvimSingleQuotedBody</B>*            NvimStringBody          Literal part of
                                                           |<A HREF="#expr-'">expr-'</A>| <A HREF="#string">string</A> body

*<A NAME="hl-NvimSingleQuotedQuote"></A><B>hl-NvimSingleQuotedQuote</B>*           NvimStringSpecial       `''` inside |<A HREF="#expr-'">expr-'</A>|
                                                           <A HREF="#string">string</A> body


*<A NAME="hl-NvimDoubleQuote"></A><B>hl-NvimDoubleQuote</B>*                 NvimStringQuote         `&quot;` in |<A HREF="#expr-quote">expr-quote</A>|

*<A NAME="hl-NvimDoubleQuotedBody"></A><B>hl-NvimDoubleQuotedBody</B>*            NvimStringBody          Literal part of
                                                           |<A HREF="#expr-quote">expr-quote</A>| body

*<A NAME="hl-NvimDoubleQuotedEscape"></A><B>hl-NvimDoubleQuotedEscape</B>*          NvimStringSpecial       Valid |<A HREF="#expr-quote">expr-quote</A>|
                                                           <A HREF="intro.html#escape">escape</A> sequence

*<A NAME="hl-NvimDoubleQuotedUnknownEscape"></A><B>hl-NvimDoubleQuotedUnknownEscape</B>*   NvimInvalidValue        Unrecognized
                                                           |<A HREF="#expr-quote">expr-quote</A>| <A HREF="intro.html#escape">escape</A>
                                                           sequence

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
