<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Nvim documentation: api</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Nvim documentation: api</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="api.txt"></A><B>api.txt</B>*               Nvim


                 NVIM REFERENCE MANUAL    by Thiago de Arruda



Nvim <A HREF="#API">API</A>                                                           *<A NAME="API"></A><B>API</B>* *<A NAME="api"></A><B>api</B>*

Nvim exposes a powerful <A HREF="#API">API</A> that can be used by plugins and external processes
via |<A HREF="#RPC">RPC</A>|, |<A HREF="lua.html#Lua">Lua</A>| and VimL (|<A HREF="builtin.html#eval-api">eval-api</A>|).

Applications can also embed libnvim to work with the C <A HREF="#API">API</A> directly.

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

<A HREF="#API">API</A> Usage                                               *<A NAME="api-rpc"></A><B>api-rpc</B>* *<A NAME="RPC"></A><B>RPC</B>* *<A NAME="rpc"></A><B>rpc</B>*


                                                        *<A NAME="msgpack-rpc"></A><B>msgpack-rpc</B>*
<A HREF="#RPC">RPC</A> is the typical way to <A HREF="intro.html#control">control</A> Nvim programmatically.  Nvim implements the
MessagePack-RPC protocol:
  https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md
  https://github.com/msgpack/msgpack/blob/0b8f5ac/spec.md

Many clients use the <A HREF="#API">API</A>: user interfaces (GUIs), remote plugins, scripts like
&quot;nvr&quot; (https://github.com/mhinz/neovim-remote).  Even Nvim itself can <A HREF="intro.html#control">control</A>
other Nvim instances.  <A HREF="#API">API</A> clients can:

  - Call any <A HREF="#API">API</A> function
  - Listen for <A HREF="autocmd.html#events">events</A>
  - Receive remote calls from Nvim

The <A HREF="#RPC">RPC</A> <A HREF="#API">API</A> is like a more powerful version of Vim's &quot;<A HREF="remote.html#clientserver">clientserver</A>&quot; feature.


CONNECTING                                              *<A NAME="rpc-connecting"></A><B>rpc-connecting</B>*

See |<A HREF="channel.html#channel-intro">channel-intro</A>| for various ways to open a channel. Channel-opening
<A HREF="eval.html#functions">functions</A> take an `rpc` key in the <A HREF="options.html#options">options</A> dictionary. <A HREF="#RPC">RPC</A> channels can also
be opened by other processes connecting to TCP/IP sockets or named pipes
listened to by Nvim.

Nvim creates a default <A HREF="#RPC">RPC</A> socket at |<A HREF="starting.html#startup">startup</A>|, given by |<A HREF="eval.html#v:servername">v:servername</A>|. To
start with a TCP/IP socket instead, use |<A HREF="starting.html#--listen">--listen</A>| with a TCP-style address:
<B>    nvim --listen 127.0.0.1:6666</B>
More endpoints can be started with |<A HREF="builtin.html#serverstart()">serverstart()</A>|.

Note that localhost TCP sockets are generally <A HREF="various.html#less">less</A> secure than named pipes,
and can lead to vulnerabilities like remote code execution.

Connecting to the socket is the easiest way a programmer can test the <A HREF="#API">API</A>,
which can be done through any <A HREF="#msgpack-rpc">msgpack-rpc</A> client library or full-featured
|<A HREF="develop.html#api-client">api-client</A>|. Here's a <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="usr_41.html#script">script</A> that prints &quot;hello world!&quot; in the current
Nvim instance:

<B>    #!/usr/bin/env ruby</B>
<B>    # Requires msgpack-rpc: gem install msgpack-rpc</B>
<B>    #</B>
<B>    # To run this script, execute it from a running Nvim instance (notice the</B>
<B>    # trailing '&amp;' which is required since Nvim won't process events while</B>
<B>    # running a blocking command):</B>
<B>    #</B>
<B>    #   :!./hello.rb &amp;</B>
<B>    #</B>
<B>    # Or from another shell by setting NVIM_LISTEN_ADDRESS:</B>
<B>    # $ NVIM_LISTEN_ADDRESS=[address] ./hello.rb</B>

<B>    require 'msgpack/rpc'</B>
<B>    require 'msgpack/rpc/transport/unix'</B>

<B>    nvim = MessagePack::RPC::Client.new(MessagePack::RPC::UNIXTransport.new, ENV['NVIM_LISTEN_ADDRESS'])</B>
<B>    result = nvim.call(:nvim_command, 'echo "hello world!"')</B>
 
A better way is to use the <A HREF="if_pyth.html#Python">Python</A> REPL with the &quot;<A HREF="develop.html#pynvim">pynvim</A>&quot; package, where <A HREF="#API">API</A>
<A HREF="eval.html#functions">functions</A> can be called interactively:

<B>    &gt;&gt;&gt; from pynvim import attach</B>
<B>    &gt;&gt;&gt; nvim = attach('socket', path='[address]')</B>
<B>    &gt;&gt;&gt; nvim.command('echo "hello world!"')</B>
 
You can also embed Nvim via |<A HREF="builtin.html#jobstart()">jobstart()</A>|, and communicate using |<A HREF="builtin.html#rpcrequest()">rpcrequest()</A>|
and YXXYrpcnotify()|:

<B>    let nvim = jobstart(['nvim', '--embed'], {'rpc': v:true})</B>
<B>    echo rpcrequest(nvim, 'nvim_eval', '"Hello " . "world!"')</B>
<B>    call jobstop(nvim)</B>
 

==============================================================================

<A HREF="#API">API</A> Definitions                                         *<A NAME="api-definitions"></A><B>api-definitions</B>*


                                                        *<A NAME="api-types"></A><B>api-types</B>*
The Nvim C <A HREF="#API">API</A> defines custom types for all function parameters. Some are just
typedefs around C99 standard types, others are Nvim-defined data structures.

<B><FONT COLOR="PURPLE">Basic types </FONT></B>

<B>  API Type                              C type</B>
<B>  ------------------------------------------------------------------------</B>
<B>  Nil</B>
<B>  Boolean                               bool</B>
<B>  Integer (signed 64-bit integer)       int64_t</B>
<B>  Float (IEEE 754 double precision)     double</B>
<B>  String                                {char* data, size_t size} struct</B>
<B>  Array</B>
<B>  Dictionary (msgpack: map)</B>
<B>  Object</B>
 
  Note: empty Array is accepted <A HREF="motion.html#as">as</A> a valid argument for <A HREF="eval.html#Dictionary">Dictionary</A> parameter.

<B><FONT COLOR="PURPLE">Special types (msgpack EXT) </FONT></B>

  These are integer typedefs discriminated <A HREF="motion.html#as">as</A> separate Object subtypes. They
  can be treated <A HREF="motion.html#as">as</A> opaque integers, but are mutually incompatible: Buffer may
  be passed <A HREF="motion.html#as">as</A> an integer but not <A HREF="motion.html#as">as</A> Window or Tabpage.

  The EXT object data is the (integer) object handle. The EXT type codes given
  in the |<A HREF="#api-metadata">api-metadata</A>| `types` key are stable: they will not change and are
  thus forward-compatible.

<B>  EXT Type      C type                                  Data</B>
<B>  ------------------------------------------------------------------------</B>
<B>  Buffer        enum value kObjectTypeBuffer            |bufnr()|</B>
<B>  Window        enum value kObjectTypeWindow            |window-ID|</B>
<B>  Tabpage       enum value kObjectTypeTabpage           internal handle</B>
 


                                                        *<A NAME="api-indexing"></A><B>api-indexing</B>*
Most of the <A HREF="#API">API</A> uses 0-based indices, and ranges are end-exclusive. For the
end of a range, -1 denotes the last line/column.

Exception: the following <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A> use &quot;mark-like&quot; indexing (1-based
lines, 0-based columns):

- |<A HREF="#nvim_get_mark()">nvim_get_mark()</A>|
- |<A HREF="#nvim_buf_get_mark()">nvim_buf_get_mark()</A>|
- |<A HREF="#nvim_buf_set_mark()">nvim_buf_set_mark()</A>|
- |<A HREF="#nvim_win_get_cursor()">nvim_win_get_cursor()</A>|
- |<A HREF="#nvim_win_set_cursor()">nvim_win_set_cursor()</A>|

Exception: the following <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A> use |<A HREF="#extmarks">extmarks</A>| indexing (0-based
indices, end-inclusive):

- |<A HREF="#nvim_buf_del_extmark()">nvim_buf_del_extmark()</A>|
- |<A HREF="#nvim_buf_get_extmark_by_id()">nvim_buf_get_extmark_by_id()</A>|
- |<A HREF="#nvim_buf_get_extmarks()">nvim_buf_get_extmarks()</A>|
- |<A HREF="#nvim_buf_set_extmark()">nvim_buf_set_extmark()</A>|


                                                        *<A NAME="api-fast"></A><B>api-fast</B>*
Most <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A> are &quot;deferred&quot;: they are queued on the main loop and
processed sequentially with normal input.  So if the editor is waiting for
user input in a &quot;modal&quot; fashion (e.g. the |<A HREF="message.html#hit-enter-prompt">hit-enter-prompt</A>|), the request
will block.  Non-deferred (fast) <A HREF="eval.html#functions">functions</A> such <A HREF="motion.html#as">as</A> |<A HREF="#nvim_get_mode()">nvim_get_mode()</A>| and
|<A HREF="#nvim_input()">nvim_input()</A>| are served immediately (i.e. without waiting in the input
queue).  <A HREF="lua.html#Lua">Lua</A> code can use |<A HREF="vim.html">vim.in_fast_event()</A>| to detect a fast <A HREF="repeat.html#context">context</A>.

==============================================================================

<A HREF="#API">API</A> metadata                                            *<A NAME="api-metadata"></A><B>api-metadata</B>*

The Nvim C <A HREF="#API">API</A> is automatically exposed to <A HREF="#RPC">RPC</A> by the build system, which
parses headers in src/nvim/api/* and generates dispatch-functions <A HREF="map.html#mapping">mapping</A> <A HREF="#RPC">RPC</A>
<A HREF="#API">API</A> <A HREF="eval.html#method">method</A> names to public C <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A>, converting/validating arguments
and return values.

Nvim exposes its <A HREF="#API">API</A> metadata <A HREF="motion.html#as">as</A> a <A HREF="eval.html#Dictionary">Dictionary</A> with these items:

- version                 Nvim version, <A HREF="#API">API</A> level/compatibility

- version.api_level       <A HREF="#API">API</A> version integer *<A NAME="api-level"></A><B>api-level</B>*
- version.api_compatible  <A HREF="#API">API</A> is backwards-compatible with this level
- version.api_prerelease  Declares the <A HREF="#API">API</A> <A HREF="motion.html#as">as</A> unstable/unreleased
                          `(version.api_prerelease &amp;&amp; fn.since <A HREF="change.html#==">==</A> version.api_level)`
- <A HREF="eval.html#functions">functions</A>               <A HREF="#API">API</A> function signatures, containing |<A HREF="#api-types">api-types</A>| info
                          describing the return value and parameters.
- ui_events               |<A HREF="ui.html#UI">UI</A>| event signatures
- ui_options              Supported |<A HREF="ui.html#ui-option">ui-option</A>|<A HREF="change.html#s">s</A>
- {fn}.since              <A HREF="#API">API</A> level where function {fn} was introduced
- {fn}.deprecated_since   <A HREF="#API">API</A> level where function {fn} was <A HREF="deprecated.html#deprecated">deprecated</A>
- types                   Custom handle types defined by Nvim
- error_types             Possible error types returned by <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A>

About the `functions` map:

  - Container types may be decorated with type/size constraints, e.g.
    ArrayOf(Buffer) or ArrayOf(Integer, 2).
  - Functions considered to be methods that operate on instances of Nvim
    special types (msgpack EXT) have the &quot;method=true&quot; flag. The receiver type
    is that of the first argument. Method names are prefixed with `nvim_` plus
    a type name, e.g. `nvim_buf_get_lines` is the `get_lines` <A HREF="eval.html#method">method</A> of
    a Buffer instance. |<A HREF="develop.html#dev-api">dev-api</A>|
  - Global <A HREF="eval.html#functions">functions</A> have the &quot;method=false&quot; flag and are prefixed with just
    `nvim_`, e.g. `nvim_list_bufs`.


                                                        *<A NAME="api-mapping"></A><B>api-mapping</B>*
External programs (clients) can use the metadata to discover the <A HREF="#API">API</A>, using
any of these approaches:

  1. Connect to a running Nvim instance and call |<A HREF="#nvim_get_api_info()">nvim_get_api_info()</A>| via
     msgpack-RPC. This is best for clients written in dynamic languages which
     can define <A HREF="eval.html#functions">functions</A> at runtime.

  2. Start Nvim with |<A HREF="starting.html#--api-info">--api-info</A>|. Useful for statically-compiled clients.
     Example (requires <A HREF="if_pyth.html#Python">Python</A> &quot;pyyaml&quot; and &quot;msgpack-python&quot; modules):
<B>     nvim --api-info | python -c 'import msgpack, sys, yaml; yaml.dump(msgpack.unpackb(sys.stdin.buffer.read()), sys.stdout)'</B>
 
  3. Use the |<A HREF="builtin.html#api_info()">api_info()</A>| Vimscript function.
<B>     :lua print(vim.inspect(vim.fn.api_info()))</B>
      Example using |<A HREF="builtin.html#filter()">filter()</A>| to exclude non-deprecated <A HREF="#API">API</A> <A HREF="eval.html#functions">functions</A>:
<B>     :new|put =map(filter(api_info().functions, '!has_key(v:val,''deprecated_since'')'), 'v:val.name')</B>

==============================================================================

<A HREF="#API">API</A> contract                                                     *<A NAME="api-contract"></A><B>api-contract</B>*

The Nvim <A HREF="#API">API</A> is composed of <A HREF="eval.html#functions">functions</A> and <A HREF="autocmd.html#events">events</A>.

- Clients call <A HREF="eval.html#functions">functions</A> like those described at |<A HREF="#api-global">api-global</A>|.
- Clients can subscribe to |<A HREF="ui.html#ui-events">ui-events</A>|, |<A HREF="#api-buffer-updates">api-buffer-updates</A>|, etc.
- <A HREF="#API">API</A> function names are prefixed with &quot;nvim_&quot;.
- <A HREF="#API">API</A> event names are prefixed with &quot;nvim_&quot; and suffixed with &quot;_event&quot;.

As Nvim evolves the <A HREF="#API">API</A> may change in compliance with this CONTRACT:

- New <A HREF="eval.html#functions">functions</A> and <A HREF="autocmd.html#events">events</A> may be added.
  - Any such extensions are OPTIONAL: old clients may ignore them.
- Function signatures will NOT CHANGE (after release).
  - Functions introduced in the <A HREF="develop.html#development">development</A> (unreleased) version MAY CHANGE.
    (Clients can dynamically check `api_prerelease`, etc. |<A HREF="#api-metadata">api-metadata</A>|)
- Event parameters will not be removed or reordered (after release).
- Events may be EXTENDED: new parameters may be added.
- New items may be ADDED to map/list parameters/results of <A HREF="eval.html#functions">functions</A> and
  <A HREF="autocmd.html#events">events</A>.
  - Any such new items are OPTIONAL: old clients may ignore them.
  - Existing items will not be removed (after release).
- Deprecated <A HREF="eval.html#functions">functions</A> will not be removed until Nvim version 2.0

==============================================================================

Global <A HREF="autocmd.html#events">events</A>                                               *<A NAME="api-global-events"></A><B>api-global-events</B>*

When a client invokes an <A HREF="#API">API</A> request <A HREF="motion.html#as">as</A> an async notification, <A HREF="motion.html#it">it</A> is not
possible for Nvim to send an error response. Instead, in <A HREF="change.html#case">case</A> of error, the
following notification will be sent to the client:


                                                             *<A NAME="nvim_error_event"></A><B>nvim_error_event</B>*
nvim_error_event[{type}, {message}]

{type} is a numeric id <A HREF="motion.html#as">as</A> defined by `api_info().error_types`, and {message} is
a <A HREF="eval.html#string">string</A> with the error message.

==============================================================================

Buffer update <A HREF="autocmd.html#events">events</A>                                    *<A NAME="api-buffer-updates"></A><B>api-buffer-updates</B>*

<A HREF="#API">API</A> clients can &quot;attach&quot; to Nvim <A HREF="windows.html#buffers">buffers</A> to subscribe to buffer update <A HREF="autocmd.html#events">events</A>.
This is similar to |<A HREF="autocmd.html#TextChanged">TextChanged</A>| but more powerful and granular.

Call |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| to receive these <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>:


                                                        *<A NAME="nvim_buf_lines_event"></A><B>nvim_buf_lines_event</B>*
nvim_buf_lines_event[{buf}, {changedtick}, {firstline}, {lastline}, {linedata}, {more}]

    When the buffer text between {firstline} and {lastline} (end-exclusive,
    zero-indexed) were changed to the new text in the {linedata} <A HREF="eval.html#list">list</A>. The
    granularity is a line, i.e. if a single character is changed in the
    editor, the entire line is sent.

    When {changedtick} is |<A HREF="eval.html#v:null">v:null</A>| this means the screen lines (display)
    changed but not the buffer contents. {linedata} contains the changed
    screen lines. This happens when <A HREF="options.html#'inccommand'">'inccommand'</A> shows a buffer preview.

<B><FONT COLOR="PURPLE">    Properties:</FONT></B>
        {buf} <A HREF="#API">API</A> buffer handle (buffer number)

        {changedtick} value of |<A HREF="eval.html#b:changedtick">b:changedtick</A>| for the buffer. If you send an
        <A HREF="#API">API</A> command back to <A HREF="nvim.html#nvim">nvim</A> you can check the value of |<A HREF="eval.html#b:changedtick">b:changedtick</A>| <A HREF="motion.html#as">as</A>
        part of your request to ensure that no other changes have been made.

        {firstline} integer line number of the first line that was replaced.
        Zero-indexed: if line 1 was replaced then {firstline} will be 0, not
        1. {firstline} is always <A HREF="various.html#less">less</A> than or equal to the number of lines
        that were in the buffer before the lines were replaced.

        {lastline} integer line number of the first line that was not replaced
        (i.e. the range {firstline}, {lastline} is end-exclusive).
        Zero-indexed: if line numbers 2 to 5 were replaced, this will be 5
        instead of 6. {lastline} is always be <A HREF="various.html#less">less</A> than or equal to the number
        of lines that were in the buffer before the lines were replaced.
        {lastline} will be -1 if the event is part of the initial update after
        attaching.

        {linedata} <A HREF="eval.html#list">list</A> of strings containing the contents of the new buffer
        lines. Newline characters are omitted; empty lines are sent <A HREF="motion.html#as">as</A> empty
        strings.

        {more} <A HREF="options.html#boolean">boolean</A>, true for a &quot;multipart&quot; change notification: the
        current change was chunked into multiple |<A HREF="#nvim_buf_lines_event">nvim_buf_lines_event</A>|
        notifications (e.g. because <A HREF="motion.html#it">it</A> was too big).


nvim_buf_changedtick_event[{buf}, {changedtick}]  *<A NAME="nvim_buf_changedtick_event"></A><B>nvim_buf_changedtick_event</B>*

    When |<A HREF="eval.html#b:changedtick">b:changedtick</A>| was incremented but no text was changed. Relevant for
    undo/redo.

<B><FONT COLOR="PURPLE">    Properties:</FONT></B>
        {buf} <A HREF="#API">API</A> buffer handle (buffer number)
        {changedtick} new value of |<A HREF="eval.html#b:changedtick">b:changedtick</A>| for the buffer


nvim_buf_detach_event[{buf}]                           *<A NAME="nvim_buf_detach_event"></A><B>nvim_buf_detach_event</B>*

    When buffer is detached (i.e. updates are disabled). Triggered explicitly by
    |<A HREF="#nvim_buf_detach()">nvim_buf_detach()</A>| or implicitly in these cases:
    - Buffer was |abandon|ed and <A HREF="options.html#'hidden'">'hidden'</A> is not set.
    - Buffer was reloaded, e.g. with |<A HREF="editing.html#:edit">:edit</A>| or an external change triggered
      |<A HREF="editing.html#:checktime">:checktime</A>| or <A HREF="options.html#'autoread'">'autoread'</A>.
    - Generally: whenever the buffer contents are unloaded from memory.

<B><FONT COLOR="PURPLE">    Properties:</FONT></B>
        {buf} <A HREF="#API">API</A> buffer handle (buffer number)


<B><FONT COLOR="PURPLE">EXAMPLE </FONT></B>

Calling |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| with send_buffer=true on an empty buffer, emits:
<B>    nvim_buf_lines_event[{buf}, {changedtick}, 0, -1, [""], v:false]</B>

<A HREF="autocmd.html#User">User</A> adds two lines to the buffer, emits:
<B>    nvim_buf_lines_event[{buf}, {changedtick}, 0, 0, ["line1", "line2"], v:false]</B>

<A HREF="autocmd.html#User">User</A> moves to a line containing the text &quot;Hello world&quot; and inserts &quot;<A HREF="change.html#!">!</A>&quot;, emits:
<B>    nvim_buf_lines_event[{buf}, {changedtick}, {linenr}, {linenr} + 1,</B>
<B>                         ["Hello world!"], v:false]</B>

<A HREF="autocmd.html#User">User</A> moves to line 3 and deletes 20 lines using &quot;20dd&quot;, emits:
<B>    nvim_buf_lines_event[{buf}, {changedtick}, 2, 22, [], v:false]</B>

<A HREF="autocmd.html#User">User</A> selects lines 3-5 using |<A HREF="visual.html#linewise-visual">linewise-visual</A>| mode and then types &quot;<A HREF="change.html#p">p</A>&quot; to
<A HREF="provider.html#paste">paste</A> a block of 6 lines, emits:
<B>    nvim_buf_lines_event[{buf}, {changedtick}, 2, 5,</B>
<B>      ['pasted line 1', 'pasted line 2', 'pasted line 3', 'pasted line 4',</B>
<B>       'pasted line 5', 'pasted line 6'],</B>
<B>      v:false</B>
<B>    ]</B>

<A HREF="autocmd.html#User">User</A> reloads the buffer with &quot;<A HREF="editing.html#:edit">:edit</A>&quot;, emits:
<B>    nvim_buf_detach_event[{buf}]</B>
 

<B><FONT COLOR="PURPLE">LUA </FONT></B>

                                                        *<A NAME="api-buffer-updates-lua"></A><B>api-buffer-updates-lua</B>*
In-process <A HREF="lua.html#Lua">Lua</A> plugins can receive buffer updates in the form of <A HREF="lua.html#Lua">Lua</A>
callbacks. These callbacks are called frequently in various contexts;
|<A HREF="eval.html#textlock">textlock</A>| prevents <A HREF="change.html#changing">changing</A> buffer contents and <A HREF="windows.html#window">window</A> layout (use
|<A HREF="vim.html">vim.schedule()</A>| to defer such operations to the main loop instead).

|<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| will take keyword args for the callbacks. &quot;on_lines&quot; will
receive parameters (&quot;lines&quot;, {buf}, {changedtick}, {firstline}, {lastline},
{new_lastline}, {old_byte_size} [, {old_utf32_size}, {old_utf16_size}]).
Unlike remote <A HREF="channel.html#channel">channel</A> <A HREF="autocmd.html#events">events</A> the text contents are not passed. The new text can
be accessed inside the callback <A HREF="motion.html#as">as</A>

    `vim.api.nvim_buf_get_lines(buf, firstline, new_lastline, true)`

{old_byte_size} is the total size of the replaced region {firstline} to
{lastline} in bytes, including the final newline after {lastline}. if
`utf_sizes` is set to true in |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| keyword args, then the
UTF-32 and UTF-16 sizes of the deleted region is also passed <A HREF="motion.html#as">as</A> additional
arguments {old_utf32_size} and {old_utf16_size}.

&quot;on_changedtick&quot; is invoked when |<A HREF="eval.html#b:changedtick">b:changedtick</A>| was incremented but no text
was changed. The parameters received are (&quot;changedtick&quot;, {buf}, {changedtick}).


                                                        *<A NAME="api-lua-detach"></A><B>api-lua-detach</B>*
In-process <A HREF="lua.html#Lua">Lua</A> callbacks can detach by returning `true`. This will detach all
callbacks attached with the same |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>| call.


==============================================================================

Buffer highlighting                                            *<A NAME="api-highlights"></A><B>api-highlights</B>*

Nvim allows plugins to add position-based highlights to <A HREF="windows.html#buffers">buffers</A>. This is
similar to |<A HREF="builtin.html#matchaddpos()">matchaddpos()</A>| but with some key differences. The added highlights
are associated with a buffer and adapts to line insertions and deletions,
similar to <A HREF="sign.html#signs">signs</A>. It is also possible to manage a set of highlights <A HREF="motion.html#as">as</A> a group
and delete or replace all at once.

The intended use <A HREF="change.html#case">case</A> are linter or semantic highlighter plugins that monitor
a buffer for changes, and in the background compute highlights to the buffer.
Another use <A HREF="change.html#case">case</A> are plugins that show output in an append-only buffer, and
want to add highlights to the outputs. Highlight data cannot be preserved
on <A HREF="editing.html#writing">writing</A> and loading a buffer to file, nor in undo/redo cycles.

Highlights are registered using the |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>| function. If an
external highlighter <A HREF="usr_05.html#plugin">plugin</A> wants to add many highlights in a batch,
performance can be improved by calling |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>| <A HREF="motion.html#as">as</A> an
asynchronous notification, after first (synchronously) requesting a source id.

Example using the <A HREF="if_pyth.html#Python">Python</A> <A HREF="#API">API</A> client (|<A HREF="develop.html#pynvim">pynvim</A>|):

<B>    src = vim.new_highlight_source()</B>
<B>    buf = vim.current.buffer</B>
<B>    for i in range(5):</B>
<B>        buf.add_highlight("String",i,0,-1,src_id=src)</B>
<B>    # some time later ...</B>
<B>    buf.clear_namespace(src)</B>
 
If the highlights don't need to be deleted or updated, just pass -1 <A HREF="motion.html#as">as</A>
src_id (this is the default in <A HREF="if_pyth.html#python">python</A>). Use |<A HREF="#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>| to
clear highlights from a specific source, in a specific line range or the
entire buffer by passing in the line range 0, -1 (the latter is the default in
<A HREF="if_pyth.html#python">python</A> <A HREF="motion.html#as">as</A> used above).

Example using the <A HREF="#API">API</A> from Vimscript:

<B>    call nvim_buf_set_lines(0, 0, 0, v:true, ["test text"])</B>
<B>    let src = nvim_buf_add_highlight(0, 0, "String", 1, 0, 4)</B>
<B>    call nvim_buf_add_highlight(0, src, "Identifier", 0, 5, -1)</B>
<B>    " some time later ...</B>
<B>    call nvim_buf_clear_namespace(0, src, 0, -1)</B>


==============================================================================

Floating <A HREF="windows.html#windows">windows</A>                                                 *<A NAME="api-floatwin"></A><B>api-floatwin</B>*

Floating <A HREF="windows.html#windows">windows</A> (&quot;floats&quot;) are displayed on top of normal <A HREF="windows.html#windows">windows</A>.  This is
useful to implement simple widgets, such <A HREF="motion.html#as">as</A> <A HREF="gui.html#tooltips">tooltips</A> displayed next to the
cursor. Floats are fully functional <A HREF="windows.html#windows">windows</A> supporting user editing, common
|<A HREF="#api-window">api-window</A>| calls, and most window <A HREF="options.html#options">options</A> (except <A HREF="options.html#'statusline'">'statusline'</A>).

Two ways to create a floating <A HREF="windows.html#window">window</A>:
- |<A HREF="#nvim_open_win()">nvim_open_win()</A>| creates a new <A HREF="windows.html#window">window</A> (needs a buffer, see |<A HREF="#nvim_create_buf()">nvim_create_buf()</A>|)
- |<A HREF="#nvim_win_set_config()">nvim_win_set_config()</A>| reconfigures a normal <A HREF="windows.html#window">window</A> into a float

To close <A HREF="motion.html#it">it</A> use |<A HREF="#nvim_win_close()">nvim_win_close()</A>| or a command such <A HREF="motion.html#as">as</A> |<A HREF="windows.html#:close">:close</A>|.

To check whether a <A HREF="windows.html#window">window</A> is floating, check whether the `relative` option in
its <A HREF="starting.html#config">config</A> is non-empty:

<B>    if vim.api.nvim_win_get_config(window_id).relative ~= '' then</B>
<B>      -- window with this window_id is floating</B>
<B>    end</B>


Buffer text can be highlighted by typical mechanisms (syntax highlighting,
|<A HREF="#api-highlights">api-highlights</A>|). The |<A HREF="syntax.html#hl-NormalFloat">hl-NormalFloat</A>| group highlights normal text;
<A HREF="options.html#'winhighlight'">'winhighlight'</A> can be used <A HREF="motion.html#as">as</A> usual to override groups locally. Floats inherit
<A HREF="options.html#options">options</A> from the current <A HREF="windows.html#window">window</A>; specify `style=minimal` in |<A HREF="#nvim_open_win()">nvim_open_win()</A>|
to disable various visual features such <A HREF="motion.html#as">as</A> the <A HREF="options.html#'number'">'number'</A> column.

Currently, floating <A HREF="windows.html#windows">windows</A> don't support some widgets like scrollbar.

The output of |<A HREF="starting.html#:mksession">:mksession</A>| does not include commands for restoring floating
<A HREF="windows.html#windows">windows</A>.

Example: create a float with scratch buffer:

<B>    let buf = nvim_create_buf(v:false, v:true)</B>
<B>    call nvim_buf_set_lines(buf, 0, -1, v:true, ["test", "text"])</B>
<B>    let opts = {'relative': 'cursor', 'width': 10, 'height': 2, 'col': 0,</B>
<B>        \ 'row': 1, 'anchor': 'NW', 'style': 'minimal'}</B>
<B>    let win = nvim_open_win(buf, 0, opts)</B>
<B>    " optional: change highlight, otherwise Pmenu is used</B>
<B>    call nvim_win_set_option(win, 'winhl', 'Normal:MyHighlight')</B>


==============================================================================

Extended marks                                  *<A NAME="api-extended-marks"></A><B>api-extended-marks</B>* *<A NAME="extmarks"></A><B>extmarks</B>*

Extended marks (extmarks) represent buffer annotations that track text changes
in the buffer. They can represent cursors, <A HREF="fold.html#folds">folds</A>, misspelled words, anything
that needs to track a logical location in the buffer over time. |<A HREF="#api-indexing">api-indexing</A>|

Extmark position works like &quot;<A HREF="motion.html#bar">bar</A>&quot; cursor: <A HREF="motion.html#it">it</A> exists between characters. Thus,
the maximum extmark index on a line is 1 more than the character index:

<B>     f o o b a r      line contents</B>
<B>     0 1 2 3 4 5      character positions (0-based)</B>
<B>    0 1 2 3 4 5 6     extmark positions (0-based)</B>

Extmarks have &quot;forward gravity&quot;: if you place the cursor directly on an
extmark position and enter some text, the extmark migrates forward.

<B>     f o o|b a r      line (| = cursor)</B>
<B>          3           extmark</B>

<B>     f o o z|b a r    line (| = cursor)</B>
<B>            4         extmark (after typing "z")</B>

If an extmark is on the last index of a line and you input a newline at that
point, the extmark will accordingly migrate to the next line:

<B>     f o o z b a r|   line (| = cursor)</B>
<B>                  7   extmark</B>

<B>     f o o z b a r    first line</B>
<B>                      extmarks (none present)</B>
<B>     |                second line (| = cursor)</B>
<B>     0                extmark (after typing &lt;CR&gt;)</B>


Example:

Let's set an extmark at the first row (row=0) and third column (column=2).
|<A HREF="#api-indexing">api-indexing</A>| Passing id=0 creates a new <A HREF="motion.html#mark">mark</A> and returns the id:

<B>      01 2345678</B>
<B>    0 ex|ample..</B>
         ^ extmark position

<B>    let g:mark_ns = nvim_create_namespace('myplugin')</B>
<B>    let g:mark_id = nvim_buf_set_extmark(0, g:mark_ns, 0, 2, {})</B>
 
We can get the <A HREF="motion.html#mark">mark</A> by its id:

<B>    echo nvim_buf_get_extmark_by_id(0, g:mark_ns, g:mark_id, {})</B>
<B>    =&gt; [0, 2]</B>

We can get all marks in a buffer by |<A HREF="#namespace">namespace</A>| (or by a range):

<B>    echo nvim_buf_get_extmarks(0, g:mark_ns, 0, -1, {})</B>
<B>    =&gt; [[1, 0, 2]]</B>

Deleting all surrounding text does NOT remove an extmark! To remove <A HREF="#extmarks">extmarks</A>
use |<A HREF="#nvim_buf_del_extmark()">nvim_buf_del_extmark()</A>|. Deleting &quot;x&quot; in our example:

<B>      0 12345678</B>
<B>    0 e|ample..</B>
        ^ extmark position

<B>    echo nvim_buf_get_extmark_by_id(0, g:mark_ns, g:mark_id, {})</B>
<B>    =&gt; [0, 1]</B>
 
    Note: Extmark &quot;gravity&quot; decides how <A HREF="motion.html#it">it</A> will <A HREF="intro.html#shift">shift</A> after a text edit.
          See |<A HREF="#nvim_buf_set_extmark()">nvim_buf_set_extmark()</A>|

Namespaces allow any <A HREF="usr_05.html#plugin">plugin</A> to manage only its own <A HREF="#extmarks">extmarks</A>, ignoring those
created by another <A HREF="usr_05.html#plugin">plugin</A>.

Extmark positions changed by an edit will be restored on undo/redo. Creating
and <A HREF="change.html#deleting">deleting</A> <A HREF="#extmarks">extmarks</A> is not a buffer change, thus new <A HREF="undo.html#undo">undo</A> states are not
created for extmark changes.

==============================================================================

Global Functions                                                  *<A NAME="api-global"></A><B>api-global</B>*


nvim__get_runtime({pat}, {all}, {*opts})                 *<A NAME="nvim__get_runtime()"></A><B>nvim__get_runtime()</B>*
    Find files in runtime directories

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {pat}   <A HREF="pattern.html#pattern">pattern</A> of files to search for
        {all}   whether to return all matches or only the first
        {opts}  is_lua: only search <A HREF="lua.html#lua">lua</A> subdirs

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#list">list</A> of absolute paths to the found files


nvim__id({obj})                                                   *<A NAME="nvim__id()"></A><B>nvim__id()</B>*
    Returns object given <A HREF="motion.html#as">as</A> argument.

    This <A HREF="#API">API</A> function is used for <A HREF="testing.html#testing">testing</A>. One should not rely on its presence
    in plugins.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {obj}  Object to return.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        its argument.


nvim__id_array({arr})                                       *<A NAME="nvim__id_array()"></A><B>nvim__id_array()</B>*
    Returns array given <A HREF="motion.html#as">as</A> argument.

    This <A HREF="#API">API</A> function is used for <A HREF="testing.html#testing">testing</A>. One should not rely on its presence
    in plugins.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {arr}  Array to return.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        its argument.


nvim__id_dictionary({dct})                             *<A NAME="nvim__id_dictionary()"></A><B>nvim__id_dictionary()</B>*
    Returns dictionary given <A HREF="motion.html#as">as</A> argument.

    This <A HREF="#API">API</A> function is used for <A HREF="testing.html#testing">testing</A>. One should not rely on its presence
    in plugins.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {dct}  <A HREF="eval.html#Dictionary">Dictionary</A> to return.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        its argument.


nvim__id_float({flt})                                       *<A NAME="nvim__id_float()"></A><B>nvim__id_float()</B>*
    Returns floating-point value given <A HREF="motion.html#as">as</A> argument.

    This <A HREF="#API">API</A> function is used for <A HREF="testing.html#testing">testing</A>. One should not rely on its presence
    in plugins.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {flt}  Value to return.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        its argument.


nvim__inspect_cell({grid}, {row}, {col})                *<A NAME="nvim__inspect_cell()"></A><B>nvim__inspect_cell()</B>*
    NB: if your <A HREF="ui.html#UI">UI</A> doesn't use hlstate, this will not return hlstate first
    time.


<A HREF="#nvim__stats()">nvim__stats()</A>                                                  *<A NAME="nvim__stats()"></A><B>nvim__stats()</B>*
    Gets internal stats.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Map of various internal stats.


nvim_call_atomic({calls})                                 *<A NAME="nvim_call_atomic()"></A><B>nvim_call_atomic()</B>*
    Calls many <A HREF="#API">API</A> methods atomically.

    This has two main usages:
    1. To perform several requests from an async <A HREF="repeat.html#context">context</A> atomically, i.e.
       without interleaving redraws, <A HREF="#RPC">RPC</A> requests from other clients, or user
       interactions (however <A HREF="#API">API</A> methods may trigger autocommands or event
       processing which have such side effects, e.g. |<A HREF="various.html#:sleep">:sleep</A>| may wake
       <A HREF="builtin.html#timers">timers</A>).
    2. To minimize <A HREF="#RPC">RPC</A> overhead (roundtrips) of a sequence of many requests.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {calls}  an array of calls, where each call is described by an array
                 with two elements: the request name, and an array of
                 arguments.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of two elements. The first is an array of return values. The
        second is NIL if all calls succeeded. If a call resulted in an error,
        <A HREF="motion.html#it">it</A> is a three-element array with the zero-based index of the call
        which resulted in an error, the error type and the error message. If
        an error occurred, the values from all preceding calls will still be
        returned.


nvim_chan_send({chan}, {data})                              *<A NAME="nvim_chan_send()"></A><B>nvim_chan_send()</B>*
    Send data to <A HREF="channel.html#channel">channel</A> `id`. For a <A HREF="job_control.html#job">job</A>, <A HREF="motion.html#it">it</A> writes <A HREF="motion.html#it">it</A> to the stdin of the
    process. For the stdio channel |<A HREF="channel.html#channel-stdio">channel-stdio</A>|, <A HREF="motion.html#it">it</A> writes to Nvim's
    stdout. For an internal <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> instance (|<A HREF="#nvim_open_term()">nvim_open_term()</A>|) <A HREF="motion.html#it">it</A> writes
    directly to <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> output. See |<A HREF="channel.html#channel-bytes">channel-bytes</A>| for more information.

    This function writes raw data, not <A HREF="#RPC">RPC</A> <A HREF="message.html#messages">messages</A>. If the <A HREF="channel.html#channel">channel</A> was
    created with `rpc=true` then the <A HREF="channel.html#channel">channel</A> expects <A HREF="#RPC">RPC</A> <A HREF="message.html#messages">messages</A>, use
    |<A HREF="vim.html">vim.rpcnotify()</A>| and |<A HREF="vim.html">vim.rpcrequest()</A>| instead.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only
        |<A HREF="vim.html">vim.api</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {chan}  id of the <A HREF="channel.html#channel">channel</A>
        {data}  data to write. 8-bit clean: can contain NUL bytes.


nvim_create_buf({listed}, {scratch})                       *<A NAME="nvim_create_buf()"></A><B>nvim_create_buf()</B>*
    Creates a new, empty, unnamed buffer.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {listed}   Sets <A HREF="options.html#'buflisted'">'buflisted'</A>
        {scratch}  Creates a &quot;throwaway&quot; |<A HREF="windows.html#scratch-buffer">scratch-buffer</A>| for temporary work
                   (always <A HREF="options.html#'nomodified'">'nomodified'</A>). Also sets <A HREF="options.html#'nomodeline'">'nomodeline'</A> on the
                   buffer.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Buffer handle, or 0 on error

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        buf_open_scratch


<A HREF="#nvim_del_current_line()">nvim_del_current_line()</A>                              *<A NAME="nvim_del_current_line()"></A><B>nvim_del_current_line()</B>*
    Deletes the current line.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active


nvim_del_keymap({mode}, <A HREF="map.html#{lhs}">{lhs}</A>)                             *<A NAME="nvim_del_keymap()"></A><B>nvim_del_keymap()</B>*
    Unmaps a global |<A HREF="map.html#mapping">mapping</A>| for the given mode.

    To unmap a buffer-local <A HREF="map.html#mapping">mapping</A>, use |<A HREF="#nvim_buf_del_keymap()">nvim_buf_del_keymap()</A>|.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_set_keymap()">nvim_set_keymap()</A>|


nvim_del_mark({name})                                        *<A NAME="nvim_del_mark()"></A><B>nvim_del_mark()</B>*
    Deletes an uppercase/file named mark. See |<A HREF="motion.html#mark-motions">mark-motions</A>|.

    Note:
        fails with error if a <A HREF="change.html#lowercase">lowercase</A> or buffer local named <A HREF="motion.html#mark">mark</A> is used.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  <A HREF="motion.html#Mark">Mark</A> name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the <A HREF="motion.html#mark">mark</A> was deleted, else false.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_del_mark()">nvim_buf_del_mark()</A>|
        |<A HREF="#nvim_get_mark()">nvim_get_mark()</A>|


nvim_del_var({name})                                          *<A NAME="nvim_del_var()"></A><B>nvim_del_var()</B>*
    Removes a global (g:) variable.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Variable name


nvim_echo({chunks}, {history}, {opts})                           *<A NAME="nvim_echo()"></A><B>nvim_echo()</B>*
    Echo a message.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {chunks}   A <A HREF="eval.html#list">list</A> of [text, hl_group] arrays, each representing a text
                   chunk with specified highlight. `hl_group` element can be
                   omitted for no highlight.
        {history}  if true, add to |<A HREF="message.html#message-history">message-history</A>|.
        {opts}     Optional parameters. Reserved for future use.


nvim_err_write({str})                                       *<A NAME="nvim_err_write()"></A><B>nvim_err_write()</B>*
    Writes a message to the Vim error buffer. Does not append &quot;\n&quot;, the
    message is buffered (won't display) until a <A HREF="intro.html#linefeed">linefeed</A> is written.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}  Message


nvim_err_writeln({str})                                   *<A NAME="nvim_err_writeln()"></A><B>nvim_err_writeln()</B>*
    Writes a message to the Vim error buffer. Appends &quot;\n&quot;, so the buffer is
    flushed (and displayed).

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}  Message

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        <A HREF="#nvim_err_write()">nvim_err_write()</A>


nvim_eval_statusline({str}, {*opts})                  *<A NAME="nvim_eval_statusline()"></A><B>nvim_eval_statusline()</B>*
    Evaluates statusline <A HREF="eval.html#string">string</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}   Statusline <A HREF="eval.html#string">string</A> (see <A HREF="options.html#'statusline'">'statusline'</A>).
        {opts}  Optional parameters.
                • <A HREF="windows.html#winid">winid</A>: (number) |<A HREF="windows.html#window-ID">window-ID</A>| of the window to use <A HREF="motion.html#as">as</A> <A HREF="repeat.html#context">context</A>
                  for statusline.
                • maxwidth: (number) Maximum width of statusline.
                • fillchar: (string) Character to fill blank spaces in the
                  statusline (see <A HREF="options.html#'fillchars'">'fillchars'</A>). Treated <A HREF="motion.html#as">as</A> single-width even
                  if <A HREF="motion.html#it">it</A> isn't.
                • highlights: (boolean) Return highlight information.
                • use_winbar: (boolean) Evaluate winbar instead of statusline.
                • use_tabline: (boolean) Evaluate tabline instead of
                  statusline. When true, {winid} is ignored. Mutually
                  <A HREF="motion.html#exclusive">exclusive</A> with {use_winbar}.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Dictionary">Dictionary</A> containing statusline information, with these keys:
        • str: (string) Characters that will be displayed on the statusline.
        • width: (number) Display width of the statusline.
        • highlights: Array containing highlight information of the
          statusline. Only included when the &quot;highlights&quot; key in {opts} is
          true. Each element of the array is a |<A HREF="eval.html#Dictionary">Dictionary</A>| with these keys:
          • start: (number) Byte index (0-based) of first character that uses
            the highlight.
          • group: (string) Name of highlight group.


nvim_exec_lua({code}, {args})                                *<A NAME="nvim_exec_lua()"></A><B>nvim_exec_lua()</B>*
    Execute <A HREF="lua.html#Lua">Lua</A> code. Parameters (if any) are available <A HREF="motion.html#as">as</A> `...` inside the
    chunk. The chunk can return a value.

    Only statements are executed. To evaluate an <A HREF="eval.html#expression">expression</A>, prefix <A HREF="motion.html#it">it</A> with
    `return`: return my_function(...)

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {code}  <A HREF="lua.html#Lua">Lua</A> code to execute
        {args}  Arguments to the code

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Return value of <A HREF="lua.html#Lua">Lua</A> code if present or NIL.


nvim_feedkeys({keys}, {mode}, {escape_ks})                   *<A NAME="nvim_feedkeys()"></A><B>nvim_feedkeys()</B>*
    Sends input-keys to Nvim, subject to various quirks controlled by `mode`
    flags. This is a blocking call, unlike |<A HREF="#nvim_input()">nvim_input()</A>|.

    On execution error: does not fail, but updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

    To input sequences like &lt;C-o&gt; use |<A HREF="#nvim_replace_termcodes()">nvim_replace_termcodes()</A>| (typically
    with escape_ks=false) to replace |<A HREF="intro.html#keycodes">keycodes</A>|, then pass the result to
    <A HREF="#nvim_feedkeys()">nvim_feedkeys()</A>.

    Example:
<B>        :let key = nvim_replace_termcodes("&lt;C-o&gt;", v:true, v:false, v:true)</B>
<B>        :call nvim_feedkeys(key, 'n', v:false)</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {keys}       to be typed
        {mode}       behavior flags, see |<A HREF="builtin.html#feedkeys()">feedkeys()</A>|
        {escape_ks}  If true, <A HREF="intro.html#escape">escape</A> K_SPECIAL bytes in `keys` This should be
                     false if you already used |<A HREF="#nvim_replace_termcodes()">nvim_replace_termcodes()</A>|, and
                     true otherwise.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        <A HREF="builtin.html#feedkeys()">feedkeys()</A>
        vim_strsave_escape_ks


<A HREF="#nvim_get_api_info()">nvim_get_api_info()</A>                                      *<A NAME="nvim_get_api_info()"></A><B>nvim_get_api_info()</B>*
    Returns a 2-tuple (Array), where item 0 is the current <A HREF="channel.html#channel">channel</A> id and item
    1 is the |<A HREF="#api-metadata">api-metadata</A>| map (Dictionary).

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        2-tuple [{channel-id}, {api-metadata}]

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|
        |<A HREF="#RPC">RPC</A>| only


nvim_get_chan_info({chan})                              *<A NAME="nvim_get_chan_info()"></A><B>nvim_get_chan_info()</B>*
    Gets information about a <A HREF="channel.html#channel">channel</A>.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Dictionary">Dictionary</A> describing a <A HREF="channel.html#channel">channel</A>, with these keys:
        • &quot;id&quot; Channel id.
        • &quot;argv&quot; (optional) Job arguments <A HREF="eval.html#list">list</A>.
        • &quot;stream&quot; Stream underlying the <A HREF="channel.html#channel">channel</A>.
          • &quot;stdio&quot; stdin and stdout of this Nvim instance
          • &quot;stderr&quot; stderr of this Nvim instance
          • &quot;socket&quot; TCP/IP socket or named pipe
          • &quot;<A HREF="job_control.html#job">job</A>&quot; Job with communication over its stdio.

        • &quot;mode&quot; How data received on the <A HREF="channel.html#channel">channel</A> is interpreted.
          • &quot;bytes&quot; Send and receive raw bytes.
          • &quot;terminal&quot; |<A HREF="nvim_terminal_emulator.html#terminal">terminal</A>| instance interprets ASCII sequences.
          • &quot;<A HREF="#rpc">rpc</A>&quot; |<A HREF="#RPC">RPC</A>| communication on the <A HREF="channel.html#channel">channel</A> is active.

        • &quot;pty&quot; (optional) Name of pseudoterminal. On a POSIX system this is a
          device path like &quot;/dev/pts/1&quot;. If the name is unknown, the key will
          still be present if a pty is used (e.g. for conpty on Windows).
        • &quot;buffer&quot; (optional) Buffer with connected |<A HREF="nvim_terminal_emulator.html#terminal">terminal</A>| instance.
        • &quot;client&quot; (optional) Info about the peer (client on the other end of
          the <A HREF="#RPC">RPC</A> channel), if provided by <A HREF="motion.html#it">it</A> via |<A HREF="#nvim_set_client_info()">nvim_set_client_info()</A>|.


nvim_get_color_by_name({name})                      *<A NAME="nvim_get_color_by_name()"></A><B>nvim_get_color_by_name()</B>*
    Returns the 24-bit RGB value of a |<A HREF="#nvim_get_color_map()">nvim_get_color_map()</A>| color name or
    &quot;#rrggbb&quot; hexadecimal <A HREF="eval.html#string">string</A>.

    Example:
<B>        :echo nvim_get_color_by_name("Pink")</B>
<B>        :echo nvim_get_color_by_name("#cbcbcb")</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Color name or &quot;#rrggbb&quot; <A HREF="eval.html#string">string</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        24-bit RGB value, or -1 for invalid argument.


<A HREF="#nvim_get_color_map()">nvim_get_color_map()</A>                                    *<A NAME="nvim_get_color_map()"></A><B>nvim_get_color_map()</B>*
    Returns a map of color names and RGB values.

    Keys are color names (e.g. &quot;Aqua&quot;) and values are 24-bit RGB color values
    (e.g. 65535).

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Map of color names and RGB values.


nvim_get_context({*opts})                                 *<A NAME="nvim_get_context()"></A><B>nvim_get_context()</B>*
    Gets a map of the current editor state.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opts}  Optional parameters.
                • types: <A HREF="eval.html#List">List</A> of |<A HREF="repeat.html#context-types">context-types</A>| (&quot;regs&quot;, &quot;jumps&quot;, &quot;bufs&quot;,
                  &quot;gvars&quot;, …) to gather, or empty for &quot;all&quot;.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        map of global |<A HREF="repeat.html#context">context</A>|.


<A HREF="#nvim_get_current_buf()">nvim_get_current_buf()</A>                                *<A NAME="nvim_get_current_buf()"></A><B>nvim_get_current_buf()</B>*
    Gets the current buffer.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Buffer handle


<A HREF="#nvim_get_current_line()">nvim_get_current_line()</A>                              *<A NAME="nvim_get_current_line()"></A><B>nvim_get_current_line()</B>*
    Gets the current line.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Current line <A HREF="eval.html#string">string</A>


<A HREF="#nvim_get_current_tabpage()">nvim_get_current_tabpage()</A>                        *<A NAME="nvim_get_current_tabpage()"></A><B>nvim_get_current_tabpage()</B>*
    Gets the current <A HREF="tabpage.html#tabpage">tabpage</A>.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Tabpage handle


<A HREF="#nvim_get_current_win()">nvim_get_current_win()</A>                                *<A NAME="nvim_get_current_win()"></A><B>nvim_get_current_win()</B>*
    Gets the current <A HREF="windows.html#window">window</A>.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Window handle


nvim_get_hl_by_id({hl_id}, {rgb})                        *<A NAME="nvim_get_hl_by_id()"></A><B>nvim_get_hl_by_id()</B>*
    Gets a highlight definition by id. |<A HREF="builtin.html#hlID()">hlID()</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {hl_id}  Highlight id <A HREF="motion.html#as">as</A> returned by |<A HREF="builtin.html#hlID()">hlID()</A>|
        {rgb}    Export RGB colors

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Highlight definition map

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        nvim_get_hl_by_name


nvim_get_hl_by_name({name}, {rgb})                     *<A NAME="nvim_get_hl_by_name()"></A><B>nvim_get_hl_by_name()</B>*
    Gets a highlight definition by name.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Highlight group name
        {rgb}   Export RGB colors

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Highlight definition map

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        nvim_get_hl_by_id


nvim_get_hl_id_by_name({name})                      *<A NAME="nvim_get_hl_id_by_name()"></A><B>nvim_get_hl_id_by_name()</B>*
    Gets a highlight group by name

    similar to |<A HREF="builtin.html#hlID()">hlID()</A>|, but allocates a new ID if not present.


nvim_get_keymap({mode})                                    *<A NAME="nvim_get_keymap()"></A><B>nvim_get_keymap()</B>*
    Gets a <A HREF="eval.html#list">list</A> of global (non-buffer-local) |<A HREF="map.html#mapping">mapping</A>| <A HREF="intro.html#definitions">definitions</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {mode}  Mode short-name (&quot;n&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;, &quot;<A HREF="visual.html#v">v</A>&quot;, <A HREF="userfunc.html#...">...</A>)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of |maparg()|-like dictionaries describing mappings. The
        &quot;buffer&quot; key is always zero.


nvim_get_mark({name}, {opts})                                *<A NAME="nvim_get_mark()"></A><B>nvim_get_mark()</B>*
    Return a tuple (row, col, buffer, buffername) representing the position of
    the uppercase/file named mark. See |<A HREF="motion.html#mark-motions">mark-motions</A>|.

    Marks are (1,0)-indexed. |<A HREF="#api-indexing">api-indexing</A>|

    Note:
        fails with error if a <A HREF="change.html#lowercase">lowercase</A> or buffer local named <A HREF="motion.html#mark">mark</A> is used.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  <A HREF="motion.html#Mark">Mark</A> name
        {opts}  Optional parameters. Reserved for future use.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        4-tuple (row, col, buffer, buffername), (0, 0, 0, <A HREF="motion.html#''">''</A>) if the <A HREF="motion.html#mark">mark</A> is
        not set.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_set_mark()">nvim_buf_set_mark()</A>|
        |<A HREF="#nvim_del_mark()">nvim_del_mark()</A>|


<A HREF="#nvim_get_mode()">nvim_get_mode()</A>                                              *<A NAME="nvim_get_mode()"></A><B>nvim_get_mode()</B>*
    Gets the current mode. |<A HREF="builtin.html#mode()">mode()</A>| &quot;blocking&quot; is true if Nvim is waiting for
    input.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Dictionary">Dictionary</A> { &quot;mode&quot;: <A HREF="eval.html#String">String</A>, &quot;blocking&quot;: <A HREF="eval.html#Boolean">Boolean</A> }

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|


nvim_get_proc({pid})                                         *<A NAME="nvim_get_proc()"></A><B>nvim_get_proc()</B>*
    Gets info describing process `pid`.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Map of process properties, or NIL if process not found.


nvim_get_proc_children({pid})                       *<A NAME="nvim_get_proc_children()"></A><B>nvim_get_proc_children()</B>*
    Gets the immediate children of process `pid`.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of child process ids, empty if process not found.


nvim_get_runtime_file({name}, {all})                 *<A NAME="nvim_get_runtime_file()"></A><B>nvim_get_runtime_file()</B>*
    Find files in runtime directories

    &quot;name&quot; can contain <A HREF="editing.html#wildcards">wildcards</A>. For example
    nvim_get_runtime_file(&quot;colors/*.vim&quot;, true) will return all color scheme
    files. Always use forward slashes (/) in the search <A HREF="pattern.html#pattern">pattern</A> for
    subdirectories regardless of platform.

    It is not an error to not find any files. An empty array is returned then.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  <A HREF="pattern.html#pattern">pattern</A> of files to search for
        {all}   whether to return all matches or only the first

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#list">list</A> of absolute paths to the found files


nvim_get_var({name})                                          *<A NAME="nvim_get_var()"></A><B>nvim_get_var()</B>*
    Gets a global (g:) variable.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Variable name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Variable value


nvim_get_vvar({name})                                        *<A NAME="nvim_get_vvar()"></A><B>nvim_get_vvar()</B>*
    Gets a <A HREF="eval.html#v:">v:</A> variable.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Variable name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Variable value


nvim_input({keys})                                              *<A NAME="nvim_input()"></A><B>nvim_input()</B>*
    Queues raw user-input. Unlike |<A HREF="#nvim_feedkeys()">nvim_feedkeys()</A>|, this uses a low-level
    input buffer and the call is non-blocking (input is processed
    asynchronously by the eventloop).

    On execution error: does not fail, but updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

    Note:
        |<A HREF="intro.html#keycodes">keycodes</A>| like <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> are translated, so &quot;<A HREF="change.html#&lt;">&lt;</A>&quot; is special. To input a
        literal &quot;<A HREF="change.html#&lt;">&lt;</A>&quot;, send &lt;LT&gt;.

    Note:
        For mouse <A HREF="autocmd.html#events">events</A> use |<A HREF="#nvim_input_mouse()">nvim_input_mouse()</A>|. The pseudokey form
        &quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot; is <A HREF="deprecated.html#deprecated">deprecated</A> since |<A HREF="#api-level">api-level</A>| 6.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {keys}  to be typed

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Number">Number</A> of bytes actually written (can be fewer than requested if the
        buffer becomes full).


                                                          *<A NAME="nvim_input_mouse()"></A><B>nvim_input_mouse()</B>*
nvim_input_mouse({button}, {action}, {modifier}, {grid}, {row}, {col})
    Send mouse event from <A HREF="gui.html#GUI">GUI</A>.

    Non-blocking: does not wait on any result, but queues the event to be
    processed soon by the event loop.

    Note:
        Currently this doesn't support &quot;scripting&quot; multiple mouse <A HREF="autocmd.html#events">events</A> by
        calling <A HREF="motion.html#it">it</A> multiple times in a loop: the intermediate mouse positions
        will be ignored. It should be used to implement real-time mouse input
        in a <A HREF="gui.html#GUI">GUI</A>. The <A HREF="deprecated.html#deprecated">deprecated</A> pseudokey form (&quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot;) of
        |<A HREF="#nvim_input()">nvim_input()</A>| has the same limitation.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {button}    Mouse button: one of &quot;left&quot;, &quot;right&quot;, &quot;middle&quot;, &quot;wheel&quot;,
                    &quot;move&quot;.
        {action}    For ordinary buttons, one of &quot;press&quot;, &quot;drag&quot;, &quot;release&quot;.
                    For the wheel, one of &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;.
                    Ignored for &quot;move&quot;.
        {modifier}  <A HREF="eval.html#String">String</A> of modifiers each represented by a single char. The
                    same specifiers are used <A HREF="motion.html#as">as</A> for a key press, except that
                    the &quot;<A HREF="motion.html#-">-</A>&quot; separator is optional, so &quot;C-A-&quot;, &quot;c-a&quot; and &quot;CA&quot;
                    can all be used to specify Ctrl+Alt+click.
        {grid}      Grid number if the client uses |<A HREF="ui.html#ui-multigrid">ui-multigrid</A>|, else 0.
        {row}       Mouse row-position (zero-based, like redraw <A HREF="autocmd.html#events">events</A>)
        {col}       Mouse column-position (zero-based, like redraw <A HREF="autocmd.html#events">events</A>)


<A HREF="#nvim_list_bufs()">nvim_list_bufs()</A>                                            *<A NAME="nvim_list_bufs()"></A><B>nvim_list_bufs()</B>*
    Gets the current <A HREF="eval.html#list">list</A> of buffer handles

    Includes unlisted (unloaded/deleted) <A HREF="windows.html#buffers">buffers</A>, like `:ls!`. Use
    |<A HREF="#nvim_buf_is_loaded()">nvim_buf_is_loaded()</A>| to check if a buffer is loaded.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#List">List</A> of buffer handles


<A HREF="#nvim_list_chans()">nvim_list_chans()</A>                                          *<A NAME="nvim_list_chans()"></A><B>nvim_list_chans()</B>*
    Get information about all open channels.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of <A HREF="eval.html#Dictionaries">Dictionaries</A>, each describing a <A HREF="channel.html#channel">channel</A> with the format
        specified at |<A HREF="#nvim_get_chan_info()">nvim_get_chan_info()</A>|.


<A HREF="#nvim_list_runtime_paths()">nvim_list_runtime_paths()</A>                          *<A NAME="nvim_list_runtime_paths()"></A><B>nvim_list_runtime_paths()</B>*
    Gets the paths contained in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#List">List</A> of paths


<A HREF="#nvim_list_tabpages()">nvim_list_tabpages()</A>                                    *<A NAME="nvim_list_tabpages()"></A><B>nvim_list_tabpages()</B>*
    Gets the current <A HREF="eval.html#list">list</A> of <A HREF="tabpage.html#tabpage">tabpage</A> handles.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#List">List</A> of <A HREF="tabpage.html#tabpage">tabpage</A> handles


<A HREF="#nvim_list_uis()">nvim_list_uis()</A>                                              *<A NAME="nvim_list_uis()"></A><B>nvim_list_uis()</B>*
    Gets a <A HREF="eval.html#list">list</A> of dictionaries representing attached UIs.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of <A HREF="ui.html#UI">UI</A> dictionaries, each with these keys:
        • &quot;height&quot; Requested height of the <A HREF="ui.html#UI">UI</A>
        • &quot;width&quot; Requested width of the <A HREF="ui.html#UI">UI</A>
        • &quot;rgb&quot; true if the <A HREF="ui.html#UI">UI</A> uses RGB colors (false implies |<A HREF="syntax.html#cterm-colors">cterm-colors</A>|)
        • &quot;ext_...&quot; Requested <A HREF="ui.html#UI">UI</A> extensions, see |<A HREF="ui.html#ui-option">ui-option</A>|
        • &quot;chan&quot; Channel id of remote <A HREF="ui.html#UI">UI</A> (not present for <A HREF="term.html#TUI">TUI</A>)


<A HREF="#nvim_list_wins()">nvim_list_wins()</A>                                            *<A NAME="nvim_list_wins()"></A><B>nvim_list_wins()</B>*
    Gets the current <A HREF="eval.html#list">list</A> of <A HREF="windows.html#window">window</A> handles.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#List">List</A> of <A HREF="windows.html#window">window</A> handles


nvim_load_context({dict})                                *<A NAME="nvim_load_context()"></A><B>nvim_load_context()</B>*
    Sets the current editor state from the given |<A HREF="repeat.html#context">context</A>| map.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {dict}  |<A HREF="repeat.html#Context">Context</A>| map.


nvim_notify({msg}, {log_level}, {opts})                        *<A NAME="nvim_notify()"></A><B>nvim_notify()</B>*
    Notify the user with a message

    Relays the call to vim.notify . By default forwards your message in the
    echo area but can be overridden to trigger desktop notifications.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {msg}        Message to display to the user
        {log_level}  The log level
        {opts}       Reserved for future use.


nvim_open_term({buffer}, {opts})                            *<A NAME="nvim_open_term()"></A><B>nvim_open_term()</B>*
    Open a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> instance in a buffer

    By default (and currently the only option) the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> will not be
    connected to an external process. Instead, input send on the <A HREF="channel.html#channel">channel</A> will
    be echoed directly by the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A>. This is useful to display ANSI
    <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> sequences returned <A HREF="motion.html#as">as</A> part of a <A HREF="#rpc">rpc</A> message, or similar.

    Note: to directly initiate the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> using the right size, display the
    buffer in a configured <A HREF="windows.html#window">window</A> before calling this. For instance, for a
    floating display, first create an empty buffer using |<A HREF="#nvim_create_buf()">nvim_create_buf()</A>|,
    then display <A HREF="motion.html#it">it</A> using |<A HREF="#nvim_open_win()">nvim_open_win()</A>|, and then call this function. Then
    |<A HREF="#nvim_chan_send()">nvim_chan_send()</A>| can be called immediately to process sequences in a
    virtual <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> having the intended size.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  the buffer to use (expected to be empty)
        {opts}    Optional parameters.
                  • on_input: <A HREF="lua.html#lua">lua</A> callback for input sent, <A HREF="insert.html#i">i</A> <A HREF="motion.html#e">e</A> keypresses in
                    <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> mode. Note: keypresses are sent raw <A HREF="motion.html#as">as</A> they would
                    be to the pty master end. For instance, a carriage return
                    is sent <A HREF="motion.html#as">as</A> a &quot;\r&quot;, not <A HREF="motion.html#as">as</A> a &quot;\n&quot;. |<A HREF="eval.html#textlock">textlock</A>| applies. It
                    is possible to call |<A HREF="#nvim_chan_send()">nvim_chan_send()</A>| directly in the
                    callback however. [&quot;input&quot;, term, bufnr, data]

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Channel id, or 0 on error


nvim_out_write({str})                                       *<A NAME="nvim_out_write()"></A><B>nvim_out_write()</B>*
    Writes a message to the Vim output buffer. Does not append &quot;\n&quot;, the
    message is buffered (won't display) until a <A HREF="intro.html#linefeed">linefeed</A> is written.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}  Message


nvim_paste({data}, {crlf}, {phase})                             *<A NAME="nvim_paste()"></A><B>nvim_paste()</B>*
    Pastes at cursor, in any mode.

    Invokes the `vim.paste` handler, which handles each mode appropriately.
    Sets redo/undo. Faster than |<A HREF="#nvim_input()">nvim_input()</A>|. Lines break at LF (&quot;\n&quot;).

    Errors ('nomodifiable', `vim.paste()` failure, …) are reflected in `err`
    but <A HREF="diff.html#do">do</A> not affect the return value (which is strictly decided by
    `vim.paste()`). On error, subsequent calls are ignored (&quot;drained&quot;) until
    the next <A HREF="provider.html#paste">paste</A> is initiated (phase 1 or -1).

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {data}   Multiline input. May be binary (containing NUL bytes).
        {crlf}   Also break lines at CR and CRLF.
        {phase}  -1: <A HREF="provider.html#paste">paste</A> in a single call (i.e. without streaming). To
                 &quot;stream&quot; a <A HREF="provider.html#paste">paste</A>, call `nvim_paste` sequentially with these `phase` values:
                 • 1: starts the <A HREF="provider.html#paste">paste</A> (exactly once)
                 • 2: continues the <A HREF="provider.html#paste">paste</A> (zero or more times)
                 • 3: ends the <A HREF="provider.html#paste">paste</A> (exactly once)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>

        • true: Client may continue pasting.
        • false: Client must cancel the <A HREF="provider.html#paste">paste</A>.


nvim_put({lines}, {type}, {after}, {follow})                      *<A NAME="nvim_put()"></A><B>nvim_put()</B>*
    Puts text at cursor, in any mode.

    Compare |<A HREF="change.html#:put">:put</A>| and |<A HREF="change.html#p">p</A>| which are always <A HREF="motion.html#linewise">linewise</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {lines}   |readfile()|-style list of lines. |channel-lines||||
        {type}    Edit behavior: any |<A HREF="builtin.html#getregtype()">getregtype()</A>| result, or:
                  • &quot;b&quot; |<A HREF="visual.html#blockwise-visual">blockwise-visual</A>| mode (may include width, e.g. &quot;b3&quot;)
                  • &quot;c&quot; |<A HREF="motion.html#charwise">charwise</A>| mode
                  • &quot;l&quot; |<A HREF="motion.html#linewise">linewise</A>| mode
                  • &quot;&quot; guess by contents, see |<A HREF="builtin.html#setreg()">setreg()</A>|
        {after}   If true insert after cursor (like |<A HREF="change.html#p">p</A>|), or before (like
                  |<A HREF="change.html#P">P</A>|).
        {follow}  If true place cursor at end of inserted text.


                                                    *<A NAME="nvim_replace_termcodes()"></A><B>nvim_replace_termcodes()</B>*
nvim_replace_termcodes({str}, {from_part}, {do_lt}, {special})
    Replaces <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> codes and |<A HREF="intro.html#keycodes">keycodes</A>| (&lt;CR&gt;, <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>, <A HREF="userfunc.html#...">...</A>) in a <A HREF="eval.html#string">string</A> with
    the internal representation.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}        <A HREF="eval.html#String">String</A> to be converted.
        {from_part}  Legacy Vim parameter. Usually true.
        {do_lt}      Also translate <A HREF="intro.html#&lt;lt&gt;">&lt;lt&gt;</A>. Ignored if `special` is false.
        {special}    <A HREF="insert.html#Replace">Replace</A> |<A HREF="intro.html#keycodes">keycodes</A>|, e.g. <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> becomes a &quot;\r&quot; char.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        replace_termcodes
        cpoptions


                                                *<A NAME="nvim_select_popupmenu_item()"></A><B>nvim_select_popupmenu_item()</B>*
nvim_select_popupmenu_item({item}, {insert}, {finish}, {opts})
    Selects an item in the completion popupmenu.

    If |<A HREF="insert.html#ins-completion">ins-completion</A>| is not active this <A HREF="#API">API</A> call is silently ignored.
    Useful for an external <A HREF="ui.html#UI">UI</A> using |<A HREF="ui.html#ui-popupmenu">ui-popupmenu</A>| to <A HREF="intro.html#control">control</A> the popupmenu
    with the mouse. Can also be used in a <A HREF="map.html#mapping">mapping</A>; use &lt;cmd&gt; |<A HREF="map.html#:map-cmd">:map-cmd</A>| to
    ensure the <A HREF="map.html#mapping">mapping</A> doesn't end completion mode.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {item}    Index (zero-based) of the item to select. Value of -1
                  selects nothing and restores the original text.
        {insert}  Whether the selection should be inserted in the buffer.
        {finish}  Finish the completion and dismiss the popupmenu. Implies
                  `insert`.
        {opts}    Optional parameters. Reserved for future use.


                                                      *<A NAME="nvim_set_client_info()"></A><B>nvim_set_client_info()</B>*
nvim_set_client_info({name}, {version}, {type}, {methods}, {attributes})
    Self-identifies the client.

    The client/plugin/application should call this after connecting, to
    provide hints about its identity and purpose, for debugging and
    orchestration.

    Can be called more than once; the caller should <A HREF="diff.html#merge">merge</A> old info if
    appropriate. Example: library first identifies the <A HREF="channel.html#channel">channel</A>, then a <A HREF="usr_05.html#plugin">plugin</A>
    using that library later identifies itself.

    Note:
        &quot;Something is better than nothing&quot;. You don't need to include all the
        fields.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}        Short name for the connected client
        {version}     <A HREF="eval.html#Dictionary">Dictionary</A> describing the version, with these (optional)
                      keys:
                      • &quot;major&quot; major version (defaults to 0 if not set, for
                        no release yet)
                      • &quot;minor&quot; minor version
                      • &quot;patch&quot; patch number
                      • &quot;prerelease&quot; <A HREF="eval.html#string">string</A> describing a prerelease, like
                        &quot;<A HREF="develop.html#dev">dev</A>&quot; or &quot;beta1&quot;
                      • &quot;commit&quot; hash or similar identifier of commit
        {type}        Must be one of the following values. Client libraries
                      should default to &quot;remote&quot; unless overridden by the
                      user.
                      • &quot;remote&quot; remote client connected to Nvim.
                      • &quot;<A HREF="ui.html#ui">ui</A>&quot; <A HREF="gui.html#gui">gui</A> frontend
                      • &quot;embedder&quot; application using Nvim <A HREF="motion.html#as">as</A> a component (for
                        example, IDE/editor implementing a vim mode).
                      • &quot;host&quot; <A HREF="usr_05.html#plugin">plugin</A> host, typically started by <A HREF="nvim.html#nvim">nvim</A>
                      • &quot;<A HREF="usr_05.html#plugin">plugin</A>&quot; single <A HREF="usr_05.html#plugin">plugin</A>, started by <A HREF="nvim.html#nvim">nvim</A>
        {methods}     Builtin methods in the client. For a host, this does not
                      include <A HREF="usr_05.html#plugin">plugin</A> methods which will be discovered later.
                      The key should be the <A HREF="eval.html#method">method</A> name, the values are dicts
                      with these (optional) keys (more keys may be added in
                      future versions of Nvim, thus unknown keys are ignored.
                      Clients must only use keys defined in this or later
                      versions of Nvim):
                      • &quot;async&quot; if true, send <A HREF="motion.html#as">as</A> a notification. If false or
                        unspecified, use a blocking request
                      • &quot;nargs&quot; <A HREF="eval.html#Number">Number</A> of arguments. Could be a single integer
                        or an array of two integers, minimum and maximum
                        <A HREF="motion.html#inclusive">inclusive</A>.
        {attributes}  Arbitrary string:string map of informal client
                      properties. Suggested keys:
                      • &quot;website&quot;: Client homepage URL (e.g. GitHub
                        repository)
                      • &quot;<A HREF="uganda.html#license">license</A>&quot;: License description (&quot;Apache 2&quot;, &quot;GPLv3&quot;,
                        &quot;MIT&quot;, …)
                      • &quot;logo&quot;: URI or path to image, preferably small logo or
                        icon. .png or .svg format is preferred.


nvim_set_current_buf({buffer})                        *<A NAME="nvim_set_current_buf()"></A><B>nvim_set_current_buf()</B>*
    Sets the current buffer.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle


nvim_set_current_dir({dir})                           *<A NAME="nvim_set_current_dir()"></A><B>nvim_set_current_dir()</B>*
    Changes the global working directory.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {dir}  Directory path


nvim_set_current_line({line})                        *<A NAME="nvim_set_current_line()"></A><B>nvim_set_current_line()</B>*
    Sets the current line.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {line}  Line contents


nvim_set_current_tabpage({tabpage})               *<A NAME="nvim_set_current_tabpage()"></A><B>nvim_set_current_tabpage()</B>*
    Sets the current <A HREF="tabpage.html#tabpage">tabpage</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle


nvim_set_current_win({window})                        *<A NAME="nvim_set_current_win()"></A><B>nvim_set_current_win()</B>*
    Sets the current <A HREF="windows.html#window">window</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle


nvim_set_hl({ns_id}, {name}, {*val})                           *<A NAME="nvim_set_hl()"></A><B>nvim_set_hl()</B>*
    Sets a highlight group.

    Note:
        Unlike the `:highlight` command which can update a highlight group,
        this function completely replaces the definition. For example:
        `nvim_set_hl(0, '<A HREF="visual.html#Visual">Visual</A>', {})` will clear the highlight group
        '<A HREF="visual.html#Visual">Visual</A>'.

    Note:
        The fg and bg keys also accept the <A HREF="eval.html#string">string</A> values `&quot;fg&quot;` or `&quot;bg&quot;`
        which act <A HREF="motion.html#as">as</A> aliases to the corresponding foreground and background
        values of the <A HREF="intro.html#Normal">Normal</A> group. If the <A HREF="intro.html#Normal">Normal</A> group has not been defined,
        using these values results in an error.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {ns_id}  Namespace id for this highlight |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|.
                 Use 0 to set a highlight group globally |<A HREF="syntax.html#:highlight">:highlight</A>|.
        {name}   Highlight group name, e.g. &quot;ErrorMsg&quot;
        {val}    Highlight definition map, accepts the following keys:
                 • fg (or foreground): color name or &quot;#RRGGBB&quot;, see note.
                 • bg (or background): color name or &quot;#RRGGBB&quot;, see note.
                 • sp (or special): color name or &quot;#RRGGBB&quot;
                 • blend: integer between 0 and 100
                 • <A HREF="syntax.html#bold">bold</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#standout">standout</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#underline">underline</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#undercurl">undercurl</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#underdouble">underdouble</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#underdotted">underdotted</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#underdashed">underdashed</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#strikethrough">strikethrough</A>: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#italic">italic</A>: <A HREF="options.html#boolean">boolean</A>
                 • reverse: <A HREF="options.html#boolean">boolean</A>
                 • <A HREF="syntax.html#nocombine">nocombine</A>: <A HREF="options.html#boolean">boolean</A>
                 • link: name of another highlight group to link to, see
                   |<A HREF="syntax.html#:hi-link">:hi-link</A>|.
                 • default: Don't override existing definition |<A HREF="syntax.html#:hi-default">:hi-default</A>|
                 • ctermfg: Sets foreground of cterm color |<A HREF="syntax.html#ctermfg">ctermfg</A>|
                 • ctermbg: Sets background of cterm color |<A HREF="syntax.html#ctermbg">ctermbg</A>|
                 • cterm: cterm attribute map, like |<A HREF="syntax.html#highlight-args">highlight-args</A>|. If not
                   set, cterm attributes will match those from the attribute
                   map documented above.


nvim_set_hl_ns({ns_id})                                     *<A NAME="nvim_set_hl_ns()"></A><B>nvim_set_hl_ns()</B>*
    Set active <A HREF="#namespace">namespace</A> for highlights. This can be set for a single <A HREF="windows.html#window">window</A>,
    see |<A HREF="#nvim_win_set_hl_ns()">nvim_win_set_hl_ns()</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {ns_id}  the <A HREF="#namespace">namespace</A> to use


nvim_set_hl_ns_fast({ns_id})                           *<A NAME="nvim_set_hl_ns_fast()"></A><B>nvim_set_hl_ns_fast()</B>*
    Set active <A HREF="#namespace">namespace</A> for highlights while redrawing.

    This function meant to be called while redrawing, primarily from
    |<A HREF="#nvim_set_decoration_provider()">nvim_set_decoration_provider()</A>| on_win and on_line callbacks, which are
    allowed to change the <A HREF="#namespace">namespace</A> during a redraw cycle.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {ns_id}  the <A HREF="#namespace">namespace</A> to activate


nvim_set_keymap({mode}, <A HREF="map.html#{lhs}">{lhs}</A>, <A HREF="map.html#{rhs}">{rhs}</A>, {*opts})             *<A NAME="nvim_set_keymap()"></A><B>nvim_set_keymap()</B>*
    Sets a global |<A HREF="map.html#mapping">mapping</A>| for the given mode.

    To set a buffer-local <A HREF="map.html#mapping">mapping</A>, use |<A HREF="#nvim_buf_set_keymap()">nvim_buf_set_keymap()</A>|.

    Unlike |<A HREF="map.html#:map">:map</A>|, leading/trailing <A HREF="pattern.html#whitespace">whitespace</A> is accepted <A HREF="motion.html#as">as</A> part of the
    <A HREF="map.html#{lhs}">{lhs}</A> or <A HREF="map.html#{rhs}">{rhs}</A>. Empty <A HREF="map.html#{rhs}">{rhs}</A> is |<A HREF="intro.html#&lt;Nop&gt;">&lt;Nop&gt;</A>|. |<A HREF="intro.html#keycodes">keycodes</A>| are replaced <A HREF="motion.html#as">as</A> usual.

    Example:
<B>        call nvim_set_keymap('n', ' &lt;NL&gt;', '', {'nowait': v:true})</B>
 

    is equivalent to:
<B>        nmap &lt;nowait&gt; &lt;Space&gt;&lt;NL&gt; &lt;Nop&gt;</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {mode}  Mode short-name (map command prefix: &quot;<A HREF="pattern.html#n">n</A>&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;, &quot;<A HREF="visual.html#v">v</A>&quot;, &quot;<A HREF="change.html#x">x</A>&quot;, …) or
                &quot;!&quot; for |<A HREF="map.html#:map!">:map!</A>|, or empty <A HREF="eval.html#string">string</A> for |<A HREF="map.html#:map">:map</A>|.
        {lhs}   Left-hand-side |<A HREF="map.html#{lhs}">{lhs}</A>| of the <A HREF="map.html#mapping">mapping</A>.
        {rhs}   Right-hand-side |<A HREF="map.html#{rhs}">{rhs}</A>| of the <A HREF="map.html#mapping">mapping</A>.
        {opts}  Optional parameters map: keys are |<A HREF="map.html#:map-arguments">:map-arguments</A>|, values are
                booleans (default false). Accepts all |<A HREF="map.html#:map-arguments">:map-arguments</A>| <A HREF="motion.html#as">as</A> keys
                excluding |<A HREF="autocmd.html#&lt;buffer&gt;">&lt;buffer&gt;</A>| but including |<A HREF="map.html#:noremap">:noremap</A>| and &quot;desc&quot;.
                Unknown key is an error. &quot;desc&quot; can be used to give a
                description to the <A HREF="map.html#mapping">mapping</A>. When called from <A HREF="lua.html#Lua">Lua</A>, also accepts
                a &quot;callback&quot; key that takes a <A HREF="lua.html#Lua">Lua</A> function to call when the
                <A HREF="map.html#mapping">mapping</A> is executed. When &quot;<A HREF="eval.html#expr">expr</A>&quot; is true, &quot;replace_keycodes&quot;
                (boolean) can be used to replace <A HREF="intro.html#keycodes">keycodes</A> in the resulting
                <A HREF="eval.html#string">string</A> (see |<A HREF="#nvim_replace_termcodes()">nvim_replace_termcodes()</A>|), and a <A HREF="lua.html#Lua">Lua</A> callback
                returning `nil` is equivalent to returning an empty <A HREF="eval.html#string">string</A>.


nvim_set_var({name}, {value})                                 *<A NAME="nvim_set_var()"></A><B>nvim_set_var()</B>*
    Sets a global (g:) variable.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}   Variable name
        {value}  Variable value


nvim_set_vvar({name}, {value})                               *<A NAME="nvim_set_vvar()"></A><B>nvim_set_vvar()</B>*
    Sets a <A HREF="eval.html#v:">v:</A> variable, if <A HREF="motion.html#it">it</A> is not readonly.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}   Variable name
        {value}  Variable value


nvim_strwidth({text})                                        *<A NAME="nvim_strwidth()"></A><B>nvim_strwidth()</B>*
    Calculates the number of display cells occupied by `text`. Control
    characters including <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> <A HREF="intro.html#count">count</A> <A HREF="motion.html#as">as</A> one cell.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {text}  Some text

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Number">Number</A> of cells


nvim_subscribe({event})                                     *<A NAME="nvim_subscribe()"></A><B>nvim_subscribe()</B>*
    Subscribes to event broadcasts.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        <A HREF="autocmd.html#{event}">{event}</A>  Event type <A HREF="eval.html#string">string</A>


nvim_unsubscribe({event})                                 *<A NAME="nvim_unsubscribe()"></A><B>nvim_unsubscribe()</B>*
    Unsubscribes to event broadcasts.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        <A HREF="autocmd.html#{event}">{event}</A>  Event type <A HREF="eval.html#string">string</A>


==============================================================================

Vimscript Functions                                            *<A NAME="api-vimscript"></A><B>api-vimscript</B>*


                                                   *<A NAME="nvim_call_dict_function()"></A><B>nvim_call_dict_function()</B>*
nvim_call_dict_function({dict}, {fn}, {args})
    Calls a VimL |<A HREF="eval.html#Dictionary-function">Dictionary-function</A>| with the given arguments.

    On execution error: fails with VimL error, updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {dict}  <A HREF="eval.html#Dictionary">Dictionary</A>, or <A HREF="eval.html#String">String</A> evaluating to a VimL |<A HREF="eval.html#self">self</A>| <A HREF="eval.html#dict">dict</A>
        {fn}    Name of the function defined on the VimL <A HREF="eval.html#dict">dict</A>
        {args}  Function arguments packed in an Array

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Result of the function call


nvim_call_function({fn}, {args})                        *<A NAME="nvim_call_function()"></A><B>nvim_call_function()</B>*
    Calls a VimL function with the given arguments.

    On execution error: fails with VimL error, updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {fn}    Function to call
        {args}  Function arguments packed in an Array

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Result of the function call


nvim_command({command})                                       *<A NAME="nvim_command()"></A><B>nvim_command()</B>*
    Executes an <A HREF="intro.html#Ex">Ex</A> command.

    On execution error: fails with VimL error, updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

    Prefer using |<A HREF="#nvim_cmd()">nvim_cmd()</A>| or |<A HREF="#nvim_exec()">nvim_exec()</A>| over this. To evaluate multiple
    lines of Vim <A HREF="usr_41.html#script">script</A> or an <A HREF="intro.html#Ex">Ex</A> command directly, use |<A HREF="#nvim_exec()">nvim_exec()</A>|. To
    construct an <A HREF="intro.html#Ex">Ex</A> command using a structured format and then execute <A HREF="motion.html#it">it</A>, use
    |<A HREF="#nvim_cmd()">nvim_cmd()</A>|. To modify an <A HREF="intro.html#Ex">Ex</A> command before evaluating <A HREF="motion.html#it">it</A>, use
    |<A HREF="#nvim_parse_cmd()">nvim_parse_cmd()</A>| in conjunction with |<A HREF="#nvim_cmd()">nvim_cmd()</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {command}  <A HREF="intro.html#Ex">Ex</A> command <A HREF="eval.html#string">string</A>


nvim_eval({expr})                                                *<A NAME="nvim_eval()"></A><B>nvim_eval()</B>*
    Evaluates a VimL |<A HREF="eval.html#expression">expression</A>|. <A HREF="eval.html#Dictionaries">Dictionaries</A> and <A HREF="eval.html#Lists">Lists</A> are recursively
    expanded.

    On execution error: fails with VimL error, updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {expr}  VimL <A HREF="eval.html#expression">expression</A> <A HREF="eval.html#string">string</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Evaluation result or expanded object


nvim_exec({src}, {output})                                       *<A NAME="nvim_exec()"></A><B>nvim_exec()</B>*
    Executes Vimscript (multiline block of <A HREF="intro.html#Ex">Ex</A> commands), like anonymous
    |<A HREF="repeat.html#:source">:source</A>|.

    Unlike |<A HREF="#nvim_command()">nvim_command()</A>| this function supports heredocs, script-scope
    (s:), etc.

    On execution error: fails with VimL error, updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {src}     Vimscript code
        {output}  Capture and return all (non-error, non-shell |<A HREF="various.html#:!">:!</A>|) output

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Output (non-error, non-shell |<A HREF="various.html#:!">:!</A>|) if `output` is true, else empty
        <A HREF="eval.html#string">string</A>.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="builtin.html#execute()">execute()</A>|
        |<A HREF="#nvim_command()">nvim_command()</A>|
        |<A HREF="#nvim_cmd()">nvim_cmd()</A>|


                                                     *<A NAME="nvim_parse_expression()"></A><B>nvim_parse_expression()</B>*
nvim_parse_expression({expr}, {flags}, {highlight})
    Parse a VimL <A HREF="eval.html#expression">expression</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {expr}       Expression to parse. Always treated <A HREF="motion.html#as">as</A> a single line.
        {flags}      Flags:
                     • &quot;<A HREF="motion.html#m">m</A>&quot; if multiple expressions in a row are allowed (only
                       the first one will be parsed),
                     • &quot;<A HREF="motion.html#E">E</A>&quot; if EOC tokens are not allowed (determines whether
                       they will stop parsing process or be recognized <A HREF="motion.html#as">as</A> an
                       operator/space, though also yielding an error).
                     • &quot;<A HREF="motion.html#l">l</A>&quot; when needing to start parsing with lvalues for
                       &quot;<A HREF="eval.html#:let">:let</A>&quot; or &quot;<A HREF="eval.html#:for">:for</A>&quot;. Common flag sets:
                     • &quot;<A HREF="motion.html#m">m</A>&quot; to parse like for &quot;<A HREF="eval.html#:echo">:echo</A>&quot;.
                     • &quot;<A HREF="motion.html#E">E</A>&quot; to parse like for &quot;&lt;C-r&gt;=&quot;.
                     • empty <A HREF="eval.html#string">string</A> for &quot;<A HREF="userfunc.html#:call">:call</A>&quot;.
                     • &quot;lm&quot; to parse for &quot;<A HREF="eval.html#:let">:let</A>&quot;.
        {highlight}  If true, return value will also include &quot;highlight&quot; key
                     containing array of 4-tuples (arrays) (Integer, <A HREF="eval.html#Integer">Integer</A>,
                     <A HREF="eval.html#Integer">Integer</A>, String), where first three numbers define the
                     highlighted region and represent line, starting column
                     and ending column (latter <A HREF="motion.html#exclusive">exclusive</A>: one should highlight
                     region [start_col, end_col)).

<B><FONT COLOR="PURPLE">    Return: </FONT></B>

        • AST: top-level dictionary with these keys:
          • &quot;error&quot;: <A HREF="eval.html#Dictionary">Dictionary</A> with error, present only if parser saw some
            error. Contains the following keys:
            • &quot;message&quot;: <A HREF="eval.html#String">String</A>, error message in printf format, translated.
              Must contain exactly one &quot;&#37;.*s&quot;.
            • &quot;arg&quot;: <A HREF="eval.html#String">String</A>, error message argument.

          • &quot;len&quot;: Amount of bytes successfully parsed. With flags equal to &quot;&quot;
            that should be equal to the length of <A HREF="eval.html#expr">expr</A> <A HREF="eval.html#string">string</A>. (“Successfully
            parsed” here means “participated in AST creation”, not “till the
            first error”.)
          • &quot;ast&quot;: AST, either nil or a dictionary with these keys:
            • &quot;type&quot;: node type, one of the value names from ExprASTNodeType
              stringified without &quot;kExprNode&quot; prefix.
            • &quot;start&quot;: a pair [line, column] describing where node is
              &quot;started&quot; where &quot;line&quot; is always 0 (will not be 0 if you will be
              using nvim_parse_viml() on e.g. &quot;<A HREF="eval.html#:let">:let</A>&quot;, but that is not present
              yet). Both elements are Integers.
            • &quot;len&quot;: “length” of the node. This and &quot;start&quot; are there for
              debugging purposes primary (debugging parser and providing debug
              information).
            • &quot;children&quot;: a <A HREF="eval.html#list">list</A> of nodes described in top/&quot;ast&quot;. There always
              is zero, one or two children, key will not be present if node
              has no children. Maximum number of children may be found in
              node_maxchildren array.

        • Local values (present only for certain nodes):
          • &quot;scope&quot;: a single <A HREF="eval.html#Integer">Integer</A>, specifies scope for &quot;Option&quot; and
            &quot;PlainIdentifier&quot; nodes. For &quot;Option&quot; <A HREF="motion.html#it">it</A> is one of ExprOptScope
            values, for &quot;PlainIdentifier&quot; <A HREF="motion.html#it">it</A> is one of ExprVarScope values.
          • &quot;ident&quot;: identifier (without scope, if any), present for &quot;Option&quot;,
            &quot;PlainIdentifier&quot;, &quot;PlainKey&quot; and &quot;Environment&quot; nodes.
          • &quot;name&quot;: <A HREF="eval.html#Integer">Integer</A>, <A HREF="intro.html#register">register</A> name (one character) or -1. Only present
            for &quot;Register&quot; nodes.
          • &quot;cmp_type&quot;: <A HREF="eval.html#String">String</A>, comparison type, one of the value names from
            ExprComparisonType, stringified without &quot;kExprCmp&quot; prefix. Only
            present for &quot;Comparison&quot; nodes.
          • &quot;ccs_strategy&quot;: <A HREF="eval.html#String">String</A>, <A HREF="change.html#case">case</A> comparison strategy, one of the value
            names from ExprCaseCompareStrategy, stringified without
            &quot;kCCStrategy&quot; prefix. Only present for &quot;Comparison&quot; nodes.
          • &quot;augmentation&quot;: <A HREF="eval.html#String">String</A>, augmentation type for &quot;Assignment&quot; nodes.
            Is either an empty <A HREF="eval.html#string">string</A>, &quot;Add&quot;, &quot;Subtract&quot; or &quot;Concat&quot; for &quot;<A HREF="change.html#=">=</A>&quot;,
            &quot;+=&quot;, &quot;-=&quot; or &quot;.=&quot; respectively.
          • &quot;invert&quot;: <A HREF="eval.html#Boolean">Boolean</A>, true if result of comparison needs to be
            inverted. Only present for &quot;Comparison&quot; nodes.
          • &quot;ivalue&quot;: <A HREF="eval.html#Integer">Integer</A>, integer value for &quot;<A HREF="eval.html#Integer">Integer</A>&quot; nodes.
          • &quot;fvalue&quot;: <A HREF="eval.html#Float">Float</A>, floating-point value for &quot;<A HREF="eval.html#Float">Float</A>&quot; nodes.
          • &quot;svalue&quot;: <A HREF="eval.html#String">String</A>, value for &quot;SingleQuotedString&quot; and
            &quot;DoubleQuotedString&quot; nodes.


==============================================================================

Command Functions                                                *<A NAME="api-command"></A><B>api-command</B>*


                                              *<A NAME="nvim_buf_create_user_command()"></A><B>nvim_buf_create_user_command()</B>*
nvim_buf_create_user_command({buffer}, {name}, {command}, {*opts})
    Create a new user command |<A HREF="map.html#user-commands">user-commands</A>| in the given buffer.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        nvim_create_user_command


                                                 *<A NAME="nvim_buf_del_user_command()"></A><B>nvim_buf_del_user_command()</B>*
nvim_buf_del_user_command({buffer}, {name})
    Delete a buffer-local user-defined command.

    Only commands created with |<A HREF="map.html#:command-buffer">:command-buffer</A>| or
    |<A HREF="#nvim_buf_create_user_command()">nvim_buf_create_user_command()</A>| can be deleted with this function.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer.
        {name}    Name of the command to delete.


nvim_buf_get_commands({buffer}, {*opts})             *<A NAME="nvim_buf_get_commands()"></A><B>nvim_buf_get_commands()</B>*
    Gets a map of buffer-local |<A HREF="map.html#user-commands">user-commands</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {opts}    Optional parameters. Currently not used.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Map of maps describing commands.


nvim_cmd({*cmd}, {*opts})                                         *<A NAME="nvim_cmd()"></A><B>nvim_cmd()</B>*
    Executes an <A HREF="intro.html#Ex">Ex</A> command.

    Unlike |<A HREF="#nvim_command()">nvim_command()</A>| this command takes a structured <A HREF="eval.html#Dictionary">Dictionary</A> instead
    of a <A HREF="eval.html#String">String</A>. This allows for easier construction and manipulation of an <A HREF="intro.html#Ex">Ex</A>
    command. This also allows for things such <A HREF="motion.html#as">as</A> having spaces inside a
    command argument, expanding filenames in a command that otherwise doesn't
    expand filenames, etc. Command arguments may also be <A HREF="eval.html#Number">Number</A>, <A HREF="eval.html#Boolean">Boolean</A> or
    <A HREF="eval.html#String">String</A>.

    The first argument may also be used instead of <A HREF="intro.html#count">count</A> for commands that
    support <A HREF="motion.html#it">it</A> in order to make their usage simpler with |<A HREF="vim.html">vim.cmd()</A>|. For
    example, instead of `vim.cmd.bdelete{ <A HREF="intro.html#count">count</A> = 2 }`, you may <A HREF="diff.html#do">do</A>
    `vim.cmd.bdelete(2)`.

    On execution error: fails with VimL error, updates <A HREF="eval.html#v:errmsg">v:errmsg</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {cmd}   Command to execute. Must be a <A HREF="eval.html#Dictionary">Dictionary</A> that can contain the
                same values <A HREF="motion.html#as">as</A> the return value of |<A HREF="#nvim_parse_cmd()">nvim_parse_cmd()</A>| except
                &quot;addr&quot;, &quot;nargs&quot; and &quot;nextcmd&quot; which are ignored if provided.
                All values except for &quot;cmd&quot; are optional.
        {opts}  Optional parameters.
                • output: (boolean, default false) Whether to return command
                  output.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Command output (non-error, non-shell |<A HREF="various.html#:!">:!</A>|) if `output` is true, else
        empty <A HREF="eval.html#string">string</A>.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_exec()">nvim_exec()</A>|
        |<A HREF="#nvim_command()">nvim_command()</A>|


                                                  *<A NAME="nvim_create_user_command()"></A><B>nvim_create_user_command()</B>*
nvim_create_user_command({name}, {command}, {*opts})
    Create a new user command |<A HREF="map.html#user-commands">user-commands</A>|

    {name} is the name of the new command. The name must begin with an
    <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A>.

    {command} is the replacement text or <A HREF="lua.html#Lua">Lua</A> function to execute.

    Example:
<B>       :call nvim_create_user_command('SayHello', 'echo "Hello world!"', {})</B>
<B>       :SayHello</B>
<B>       Hello world!</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}     Name of the new user command. Must begin with an <A HREF="change.html#uppercase">uppercase</A>
                   <A HREF="print.html#letter">letter</A>.
        {command}  Replacement command to execute when this user command is
                   executed. When called from <A HREF="lua.html#Lua">Lua</A>, the command can also be a
                   <A HREF="lua.html#Lua">Lua</A> function. The function is called with a single table
                   argument that contains the following keys:
                   • args: (string) The args passed to the command, if any
                     |<A HREF="map.html#&lt;args&gt;">&lt;args&gt;</A>|
                   • fargs: (table) The args split by unescaped <A HREF="pattern.html#whitespace">whitespace</A>
                     (when more than one argument is allowed), if any
                     |<A HREF="map.html#&lt;f-args&gt;">&lt;f-args&gt;</A>|
                   • bang: (boolean) &quot;true&quot; if the command was executed with a
                     ! modifier |<A HREF="map.html#&lt;bang&gt;">&lt;bang&gt;</A>|
                   • line1: (number) The starting line of the command range
                     |<A HREF="map.html#&lt;line1&gt;">&lt;line1&gt;</A>|
                   • line2: (number) The final line of the command range
                     |<A HREF="map.html#&lt;line2&gt;">&lt;line2&gt;</A>|
                   • range: (number) The number of items in the command range:
                     0, 1, or 2 |<A HREF="map.html#&lt;range&gt;">&lt;range&gt;</A>|
                   • count: (number) Any count supplied |<A HREF="map.html#&lt;count&gt;">&lt;count&gt;</A>|
                   • reg: (string) The optional <A HREF="intro.html#register">register</A>, if specified |<A HREF="map.html#&lt;reg&gt;">&lt;reg&gt;</A>|
                   • mods: (string) Command modifiers, if any |<A HREF="map.html#&lt;mods&gt;">&lt;mods&gt;</A>|
                   • smods: (table) Command modifiers in a structured format.
                     Has the same structure <A HREF="motion.html#as">as</A> the &quot;mods&quot; key of
                     |<A HREF="#nvim_parse_cmd()">nvim_parse_cmd()</A>|.
        {opts}     Optional command attributes. See |<A HREF="map.html#command-attributes">command-attributes</A>| for
                   more details. To use <A HREF="options.html#boolean">boolean</A> attributes (such <A HREF="motion.html#as">as</A>
                   |<A HREF="map.html#:command-bang">:command-bang</A>| or |<A HREF="map.html#:command-bar">:command-bar</A>|) set the value to &quot;true&quot;.
                   In addition to the <A HREF="eval.html#string">string</A> <A HREF="options.html#options">options</A> listed in
                   |<A HREF="map.html#:command-complete">:command-complete</A>|, the &quot;complete&quot; key also accepts a <A HREF="lua.html#Lua">Lua</A>
                   function which works like the &quot;customlist&quot; completion mode
                   |<A HREF="map.html#:command-completion-customlist">:command-completion-customlist</A>|. Additional parameters:
                   • desc: (string) Used for listing the command when a <A HREF="lua.html#Lua">Lua</A>
                     function is used for {command}.
                   • force: (boolean, default true) Override any previous
                     definition.
                   • preview: (function) Preview callback for <A HREF="options.html#'inccommand'">'inccommand'</A>
                     |<A HREF="map.html#:command-preview">:command-preview</A>|


nvim_del_user_command({name})                        *<A NAME="nvim_del_user_command()"></A><B>nvim_del_user_command()</B>*
    Delete a user-defined command.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Name of the command to delete.


nvim_get_commands({*opts})                               *<A NAME="nvim_get_commands()"></A><B>nvim_get_commands()</B>*
    Gets a map of global (non-buffer-local) <A HREF="intro.html#Ex">Ex</A> commands.

    Currently only |<A HREF="map.html#user-commands">user-commands</A>| are supported, not builtin <A HREF="intro.html#Ex">Ex</A> commands.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opts}  Optional parameters. Currently only supports {&quot;builtin&quot;:false}

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Map of maps describing commands.


nvim_parse_cmd({str}, {opts})                               *<A NAME="nvim_parse_cmd()"></A><B>nvim_parse_cmd()</B>*
    Parse command line.

    Doesn't check the validity of command arguments.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#api-fast">api-fast</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {str}   Command line <A HREF="eval.html#string">string</A> to parse. Cannot contain &quot;\n&quot;.
        {opts}  Optional parameters. Reserved for future use.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Dictionary">Dictionary</A> containing command information, with these keys:
        • cmd: (string) Command name.
        • range: (array) (optional) Command range (|<A HREF="map.html#&lt;line1&gt;">&lt;line1&gt;</A>| |<A HREF="map.html#&lt;line2&gt;">&lt;line2&gt;</A>|).
          Omitted if command doesn't accept a range. Otherwise, has no
          elements if no range was specified, one element if only a single
          range item was specified, or two elements if both range items were
          specified.
        • count: (number) (optional) Command |<A HREF="map.html#&lt;count&gt;">&lt;count&gt;</A>|. Omitted if command
          cannot take a <A HREF="intro.html#count">count</A>.
        • reg: (string) (optional) Command |<A HREF="map.html#&lt;register&gt;">&lt;register&gt;</A>|. Omitted if command
          cannot take a <A HREF="intro.html#register">register</A>.
        • bang: (boolean) Whether command contains a |<A HREF="map.html#&lt;bang&gt;">&lt;bang&gt;</A>| (!) modifier.
        • args: (array) Command arguments.
        • addr: (string) Value of |<A HREF="map.html#:command-addr">:command-addr</A>|. Uses short name.
        • nargs: (string) Value of |<A HREF="map.html#:command-nargs">:command-nargs</A>|.
        • nextcmd: (string) Next command if there are multiple commands
          separated by a |<A HREF="cmdline.html#:bar">:bar</A>|. Empty if there isn't a next command.
        • magic: (dictionary) Which characters have special meaning in the
          command arguments.
          • file: (boolean) The command expands filenames. Which means
            characters such <A HREF="motion.html#as">as</A> &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot;, &quot;<A HREF="pattern.html##">#</A>&quot; and <A HREF="editing.html#wildcards">wildcards</A> are expanded.
          • <A HREF="motion.html#bar">bar</A>: (boolean) The &quot;|&quot; character is treated <A HREF="motion.html#as">as</A> a command separator
            and the double <A HREF="change.html#quote">quote</A> character (&quot;) is treated <A HREF="motion.html#as">as</A> the start of a
            comment.

        • mods: (dictionary) |<A HREF="map.html#:command-modifiers">:command-modifiers</A>|.
          • filter: (dictionary) |<A HREF="various.html#:filter">:filter</A>|.
            • <A HREF="pattern.html#pattern">pattern</A>: (string) Filter <A HREF="pattern.html#pattern">pattern</A>. Empty <A HREF="eval.html#string">string</A> if there is no
              <A HREF="change.html#filter">filter</A>.
            • force: (boolean) Whether <A HREF="change.html#filter">filter</A> is inverted or not.

          • silent: (boolean) |<A HREF="various.html#:silent">:silent</A>|.
          • emsg_silent: (boolean) |<A HREF="various.html#:silent!">:silent!</A>|.
          • unsilent: (boolean) |<A HREF="various.html#:unsilent">:unsilent</A>|.
          • sandbox: (boolean) |<A HREF="eval.html#:sandbox">:sandbox</A>|.
          • noautocmd: (boolean) |<A HREF="autocmd.html#:noautocmd">:noautocmd</A>|.
          • browse: (boolean) |<A HREF="editing.html#:browse">:browse</A>|.
          • confirm: (boolean) |<A HREF="editing.html#:confirm">:confirm</A>|.
          • hide: (boolean) |<A HREF="windows.html#:hide">:hide</A>|.
          • horizontal: (boolean) |<A HREF="windows.html#:horizontal">:horizontal</A>|.
          • keepalt: (boolean) |<A HREF="editing.html#:keepalt">:keepalt</A>|.
          • keepjumps: (boolean) |<A HREF="motion.html#:keepjumps">:keepjumps</A>|.
          • keepmarks: (boolean) |<A HREF="motion.html#:keepmarks">:keepmarks</A>|.
          • keeppatterns: (boolean) |<A HREF="cmdline.html#:keeppatterns">:keeppatterns</A>|.
          • lockmarks: (boolean) |<A HREF="motion.html#:lockmarks">:lockmarks</A>|.
          • noswapfile: (boolean) |<A HREF="recover.html#:noswapfile">:noswapfile</A>|.
          • tab: (integer) |<A HREF="tabpage.html#:tab">:tab</A>|. -1 when omitted.
          • verbose: (integer) |<A HREF="various.html#:verbose">:verbose</A>|. -1 when omitted.
          • vertical: (boolean) |<A HREF="windows.html#:vertical">:vertical</A>|.
          • split: (string) Split modifier <A HREF="eval.html#string">string</A>, is an empty <A HREF="eval.html#string">string</A> when
            there's no split modifier. If there is a split modifier <A HREF="motion.html#it">it</A> can be
            one of:
            • &quot;aboveleft&quot;: |<A HREF="windows.html#:aboveleft">:aboveleft</A>|.
            • &quot;belowright&quot;: |<A HREF="windows.html#:belowright">:belowright</A>|.
            • &quot;topleft&quot;: |<A HREF="windows.html#:topleft">:topleft</A>|.
            • &quot;botright&quot;: |<A HREF="windows.html#:botright">:botright</A>|.


==============================================================================

Options Functions                                                *<A NAME="api-options"></A><B>api-options</B>*


nvim_buf_get_option({buffer}, {name})                  *<A NAME="nvim_buf_get_option()"></A><B>nvim_buf_get_option()</B>*
    Gets a buffer option value

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    Option name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Option value


nvim_buf_set_option({buffer}, {name}, {value})         *<A NAME="nvim_buf_set_option()"></A><B>nvim_buf_set_option()</B>*
    Sets a buffer option value. Passing `nil` <A HREF="motion.html#as">as</A> value deletes the option
    (only works if there's a global fallback)

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    Option name
        {value}   Option value


<A HREF="#nvim_get_all_options_info()">nvim_get_all_options_info()</A>                      *<A NAME="nvim_get_all_options_info()"></A><B>nvim_get_all_options_info()</B>*
    Gets the option information for all <A HREF="options.html#options">options</A>.

    The dictionary has the full option names <A HREF="motion.html#as">as</A> keys and option metadata
    dictionaries <A HREF="motion.html#as">as</A> detailed at |<A HREF="#nvim_get_option_info()">nvim_get_option_info()</A>|.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        dictionary of all <A HREF="options.html#options">options</A>


nvim_get_option({name})                                    *<A NAME="nvim_get_option()"></A><B>nvim_get_option()</B>*
    Gets the global value of an option.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Option name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Option value (global)


nvim_get_option_info({name})                          *<A NAME="nvim_get_option_info()"></A><B>nvim_get_option_info()</B>*
    Gets the option information for one option

    Resulting dictionary has keys:
    • name: Name of the option (like <A HREF="options.html#'filetype'">'filetype'</A>)
    • shortname: Shortened name of the option (like <A HREF="options.html#'ft'">'ft'</A>)
    • type: type of option (&quot;string&quot;, &quot;number&quot; or &quot;<A HREF="options.html#boolean">boolean</A>&quot;)
    • default: The default value for the option
    • was_set: Whether the option was set.
    • last_set_sid: Last set <A HREF="usr_41.html#script">script</A> id (if any)
    • last_set_linenr: line number where option was set
    • last_set_chan: Channel where option was set (0 for local)
    • scope: one of &quot;global&quot;, &quot;win&quot;, or &quot;buf&quot;
    • global_local: whether win or buf option has a global value
    • commalist: <A HREF="eval.html#List">List</A> of comma separated values
    • flaglist: <A HREF="eval.html#List">List</A> of single char flags

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Option name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Option Information


nvim_get_option_value({name}, {*opts})               *<A NAME="nvim_get_option_value()"></A><B>nvim_get_option_value()</B>*
    Gets the value of an option. The behavior of this function matches that of
    |:set|: the local value of an option is returned if <A HREF="motion.html#it">it</A> exists; otherwise,
    the global value is returned. Local values always correspond to the
    current buffer or <A HREF="windows.html#window">window</A>, unless &quot;buf&quot; or &quot;win&quot; is set in {opts}.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Option name
        {opts}  Optional parameters
                • scope: One of &quot;global&quot; or &quot;local&quot;. Analogous to |<A HREF="options.html#:setglobal">:setglobal</A>|
                  and |<A HREF="options.html#:setlocal">:setlocal</A>|, respectively.
                • win: |<A HREF="windows.html#window-ID">window-ID</A>|. Used for getting window local <A HREF="options.html#options">options</A>.
                • buf: Buffer number. Used for getting buffer local <A HREF="options.html#options">options</A>.
                  Implies {scope} is &quot;local&quot;.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Option value


nvim_set_option({name}, {value})                           *<A NAME="nvim_set_option()"></A><B>nvim_set_option()</B>*
    Sets the global value of an option.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}   Option name
        {value}  New option value


                                                     *<A NAME="nvim_set_option_value()"></A><B>nvim_set_option_value()</B>*
nvim_set_option_value({name}, {value}, {*opts})
    Sets the value of an option. The behavior of this function matches that of
    |:set|: for <A HREF="options.html#global-local">global-local</A> <A HREF="options.html#options">options</A>, both the global and local value are set
    unless otherwise specified with {scope}.

    Note the <A HREF="options.html#options">options</A> {win} and {buf} cannot be used together.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}   Option name
        {value}  New option value
        {opts}   Optional parameters
                 • scope: One of &quot;global&quot; or &quot;local&quot;. Analogous to
                   |<A HREF="options.html#:setglobal">:setglobal</A>| and |<A HREF="options.html#:setlocal">:setlocal</A>|, respectively.
                 • win: |<A HREF="windows.html#window-ID">window-ID</A>|. Used for setting window local option.
                 • buf: Buffer number. Used for setting buffer local option.


nvim_win_get_option({window}, {name})                  *<A NAME="nvim_win_get_option()"></A><B>nvim_win_get_option()</B>*
    Gets a <A HREF="windows.html#window">window</A> option value

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {name}    Option name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Option value


nvim_win_set_option({window}, {name}, {value})         *<A NAME="nvim_win_set_option()"></A><B>nvim_win_set_option()</B>*
    Sets a <A HREF="windows.html#window">window</A> option value. Passing `nil` <A HREF="motion.html#as">as</A> value deletes the option
    (only works if there's a global fallback)

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {name}    Option name
        {value}   Option value


==============================================================================

Buffer Functions                                                  *<A NAME="api-buffer"></A><B>api-buffer</B>*


For more information on buffers, see |<A HREF="windows.html#buffers">buffers</A>|.

<B><FONT COLOR="PURPLE">Unloaded Buffers:</FONT></B>

Buffers may be unloaded by the |<A HREF="windows.html#:bunload">:bunload</A>| command or the buffer's
|<A HREF="options.html#'bufhidden'">'bufhidden'</A>| option. When a buffer is unloaded its file contents are
freed from memory and vim cannot operate on the buffer lines until <A HREF="motion.html#it">it</A> is
reloaded (usually by opening the buffer again in a new <A HREF="windows.html#window">window</A>). <A HREF="#API">API</A>
methods such <A HREF="motion.html#as">as</A> |<A HREF="#nvim_buf_get_lines()">nvim_buf_get_lines()</A>| and |<A HREF="#nvim_buf_line_count()">nvim_buf_line_count()</A>| will be
affected.

You can use |<A HREF="#nvim_buf_is_loaded()">nvim_buf_is_loaded()</A>| or |<A HREF="#nvim_buf_line_count()">nvim_buf_line_count()</A>| to check
whether a buffer is loaded.


nvim_buf_attach({buffer}, {send_buffer}, {opts})           *<A NAME="nvim_buf_attach()"></A><B>nvim_buf_attach()</B>*
    Activates buffer-update <A HREF="autocmd.html#events">events</A> on a <A HREF="channel.html#channel">channel</A>, or <A HREF="motion.html#as">as</A> <A HREF="lua.html#Lua">Lua</A> callbacks.

    Example (Lua): capture buffer updates in a global `events` variable (use &quot;print(vim.inspect(events))&quot; to see its contents):
<B>      events = {}</B>
<B>      vim.api.nvim_buf_attach(0, false, {</B>
<B>        on_lines=function(...) table.insert(events, {...}) end})</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}       Buffer handle, or 0 for current buffer
        {send_buffer}  True if the initial notification should contain the
                       whole buffer: first notification will be
                       `nvim_buf_lines_event`. Else the first notification
                       will be `nvim_buf_changedtick_event`. Not for <A HREF="lua.html#Lua">Lua</A>
                       callbacks.
        {opts}         Optional parameters.
                       • on_lines: <A HREF="lua.html#Lua">Lua</A> callback invoked on change. Return `true` to detach. Args:
                         • the <A HREF="eval.html#string">string</A> &quot;lines&quot;
                         • buffer handle
                         • <A HREF="eval.html#b:changedtick">b:changedtick</A>
                         • first line that changed (zero-indexed)
                         • last line that was changed
                         • last line in the updated range
                         • byte <A HREF="intro.html#count">count</A> of previous contents
                         • deleted_codepoints (if `utf_sizes` is true)
                         • deleted_codeunits (if `utf_sizes` is true)

                       • on_bytes: <A HREF="lua.html#lua">lua</A> callback invoked on change. This
                         callback receives more granular information about the
                         change compared to on_lines. Return `true` to detach. Args:
                         • the <A HREF="eval.html#string">string</A> &quot;bytes&quot;
                         • buffer handle
                         • <A HREF="eval.html#b:changedtick">b:changedtick</A>
                         • start row of the changed text (zero-indexed)
                         • start column of the changed text
                         • byte offset of the changed text (from the start of
                           the buffer)
                         • old end row of the changed text
                         • old end column of the changed text
                         • old end byte length of the changed text
                         • new end row of the changed text
                         • new end column of the changed text
                         • new end byte length of the changed text

                       • on_changedtick: <A HREF="lua.html#Lua">Lua</A> callback invoked on changedtick
                         increment without text change. Args:
                         • the <A HREF="eval.html#string">string</A> &quot;changedtick&quot;
                         • buffer handle
                         • <A HREF="eval.html#b:changedtick">b:changedtick</A>

                       • on_detach: <A HREF="lua.html#Lua">Lua</A> callback invoked on detach. Args:
                         • the <A HREF="eval.html#string">string</A> &quot;detach&quot;
                         • buffer handle

                       • on_reload: <A HREF="lua.html#Lua">Lua</A> callback invoked on <A HREF="editing.html#reload">reload</A>. The entire
                         buffer content should be considered changed. Args:
                         • the <A HREF="eval.html#string">string</A> &quot;<A HREF="editing.html#reload">reload</A>&quot;
                         • buffer handle

                       • utf_sizes: include UTF-32 and UTF-16 size of the
                         replaced region, <A HREF="motion.html#as">as</A> args to `on_lines`.
                       • preview: also attach to command preview (i.e.
                         <A HREF="options.html#'inccommand'">'inccommand'</A>) <A HREF="autocmd.html#events">events</A>.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        False if attach failed (invalid parameter, or buffer isn't loaded);
        otherwise True. TODO: LUA_API_NO_EVAL

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_detach()">nvim_buf_detach()</A>|
        |<A HREF="#api-buffer-updates-lua">api-buffer-updates-lua</A>|


nvim_buf_call({buffer}, {fun})                               *<A NAME="nvim_buf_call()"></A><B>nvim_buf_call()</B>*
    call a function with buffer <A HREF="motion.html#as">as</A> temporary current buffer

    This temporarily switches current buffer to &quot;buffer&quot;. If the current
    <A HREF="windows.html#window">window</A> already shows &quot;buffer&quot;, the <A HREF="windows.html#window">window</A> is not switched If a <A HREF="windows.html#window">window</A>
    inside the current <A HREF="tabpage.html#tabpage">tabpage</A> (including a float) already shows the buffer
    One of these <A HREF="windows.html#windows">windows</A> will be set <A HREF="motion.html#as">as</A> current <A HREF="windows.html#window">window</A> temporarily. Otherwise
    a temporary scratch <A HREF="windows.html#window">window</A> (called the &quot;<A HREF="autocmd.html#autocmd">autocmd</A> window&quot; for historical
    reasons) will be used.

    This is useful e.g. to call vimL <A HREF="eval.html#functions">functions</A> that only work with the current
    buffer/window currently, like |<A HREF="builtin.html#termopen()">termopen()</A>|.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="vim.html">vim.api</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {fun}     Function to call inside the buffer (currently <A HREF="lua.html#lua">lua</A> callable
                  only)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Return value of function. NB: will deepcopy <A HREF="lua.html#lua">lua</A> values currently, use
        upvalues to send <A HREF="lua.html#lua">lua</A> references in and out.


nvim_buf_del_keymap({buffer}, {mode}, <A HREF="map.html#{lhs}">{lhs}</A>)           *<A NAME="nvim_buf_del_keymap()"></A><B>nvim_buf_del_keymap()</B>*
    Unmaps a buffer-local |<A HREF="map.html#mapping">mapping</A>| for the given mode.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_del_keymap()">nvim_del_keymap()</A>|


nvim_buf_del_mark({buffer}, {name})                      *<A NAME="nvim_buf_del_mark()"></A><B>nvim_buf_del_mark()</B>*
    Deletes a named mark in the buffer. See |<A HREF="motion.html#mark-motions">mark-motions</A>|.

    Note:
        only deletes marks set in the buffer, if the <A HREF="motion.html#mark">mark</A> is not set in the
        buffer <A HREF="motion.html#it">it</A> will return false.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer to set the <A HREF="motion.html#mark">mark</A> on
        {name}    <A HREF="motion.html#Mark">Mark</A> name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the <A HREF="motion.html#mark">mark</A> was deleted, else false.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_set_mark()">nvim_buf_set_mark()</A>|
        |<A HREF="#nvim_del_mark()">nvim_del_mark()</A>|


nvim_buf_del_var({buffer}, {name})                        *<A NAME="nvim_buf_del_var()"></A><B>nvim_buf_del_var()</B>*
    Removes a buffer-scoped (b:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    Variable name


nvim_buf_delete({buffer}, {opts})                          *<A NAME="nvim_buf_delete()"></A><B>nvim_buf_delete()</B>*
    Deletes the buffer. See |<A HREF="windows.html#:bwipeout">:bwipeout</A>|

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {opts}    Optional parameters. Keys:
                  • force: Force deletion and ignore unsaved changes.
                  • unload: Unloaded only, <A HREF="diff.html#do">do</A> not delete. See |<A HREF="windows.html#:bunload">:bunload</A>|


nvim_buf_detach({buffer})                                  *<A NAME="nvim_buf_detach()"></A><B>nvim_buf_detach()</B>*
    Deactivates buffer-update <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        False if detach failed (because the buffer isn't loaded); otherwise
        True.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_attach()">nvim_buf_attach()</A>|
        |<A HREF="#api-lua-detach">api-lua-detach</A>| for detaching <A HREF="lua.html#Lua">Lua</A> callbacks


nvim_buf_get_changedtick({buffer})                *<A NAME="nvim_buf_get_changedtick()"></A><B>nvim_buf_get_changedtick()</B>*
    Gets a changed tick of a buffer

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        `b:changedtick` value.


nvim_buf_get_keymap({buffer}, {mode})                  *<A NAME="nvim_buf_get_keymap()"></A><B>nvim_buf_get_keymap()</B>*
    Gets a <A HREF="eval.html#list">list</A> of buffer-local |<A HREF="map.html#mapping">mapping</A>| <A HREF="intro.html#definitions">definitions</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {mode}    Mode short-name (&quot;n&quot;, &quot;<A HREF="insert.html#i">i</A>&quot;, &quot;<A HREF="visual.html#v">v</A>&quot;, <A HREF="userfunc.html#...">...</A>)
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of |maparg()|-like dictionaries describing mappings. The
        &quot;buffer&quot; key holds the associated buffer handle.


                                                        *<A NAME="nvim_buf_get_lines()"></A><B>nvim_buf_get_lines()</B>*
nvim_buf_get_lines({buffer}, {start}, {end}, {strict_indexing})
    Gets a line-range from the buffer.

    Indexing is zero-based, end-exclusive. Negative indices are interpreted <A HREF="motion.html#as">as</A>
    length+1+index: -1 refers to the index past the end. So to get the last
    element use start=-2 and end=-1.

    Out-of-bounds indices are clamped to the nearest valid value, unless
    `strict_indexing` is set.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}           Buffer handle, or 0 for current buffer
        {start}            First line index
        {end}              Last line index, <A HREF="motion.html#exclusive">exclusive</A>
        {strict_indexing}  Whether out-of-bounds should be an error.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of lines, or empty array for unloaded buffer.


nvim_buf_get_mark({buffer}, {name})                      *<A NAME="nvim_buf_get_mark()"></A><B>nvim_buf_get_mark()</B>*
    Returns a tuple (row,col) representing the position of the named <A HREF="motion.html#mark">mark</A>. See
    |<A HREF="motion.html#mark-motions">mark-motions</A>|.

    Marks are (1,0)-indexed. |<A HREF="#api-indexing">api-indexing</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    <A HREF="motion.html#Mark">Mark</A> name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (row, col) tuple, (0, 0) if the <A HREF="motion.html#mark">mark</A> is not set, or is an
        uppercase/file <A HREF="motion.html#mark">mark</A> set in another buffer.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_set_mark()">nvim_buf_set_mark()</A>|
        |<A HREF="#nvim_buf_del_mark()">nvim_buf_del_mark()</A>|


nvim_buf_get_name({buffer})                              *<A NAME="nvim_buf_get_name()"></A><B>nvim_buf_get_name()</B>*
    Gets the full file name for the buffer

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Buffer name


nvim_buf_get_offset({buffer}, {index})                 *<A NAME="nvim_buf_get_offset()"></A><B>nvim_buf_get_offset()</B>*
    Returns the byte offset of a line (0-indexed). |<A HREF="#api-indexing">api-indexing</A>|

    Line 1 (index=0) has offset 0. <A HREF="mbyte.html#UTF-8">UTF-8</A> bytes are counted. EOL is one byte.
    <A HREF="options.html#'fileformat'">'fileformat'</A> and <A HREF="options.html#'fileencoding'">'fileencoding'</A> are ignored. The line index just after the
    last line gives the total <A HREF="editing.html#byte-count">byte-count</A> of the buffer. A final EOL byte is
    counted if <A HREF="motion.html#it">it</A> would be written, see <A HREF="options.html#'eol'">'eol'</A>.

    Unlike |<A HREF="builtin.html#line2byte()">line2byte()</A>|, throws error for out-of-bounds indexing. Returns -1
    for unloaded buffer.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {index}   Line index

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Integer">Integer</A> byte offset, or -1 for unloaded buffer.


                                                         *<A NAME="nvim_buf_get_text()"></A><B>nvim_buf_get_text()</B>*
nvim_buf_get_text({buffer}, {start_row}, {start_col}, {end_row}, {end_col},
                  {opts})
    Gets a range from the buffer.

    This differs from |<A HREF="#nvim_buf_get_lines()">nvim_buf_get_lines()</A>| in that <A HREF="motion.html#it">it</A> allows retrieving only
    portions of a line.

    Indexing is zero-based. Row indices are end-inclusive, and column indices
    are end-exclusive.

    Prefer |<A HREF="#nvim_buf_get_lines()">nvim_buf_get_lines()</A>| when retrieving entire lines.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}     Buffer handle, or 0 for current buffer
        {start_row}  First line index
        {start_col}  Starting column (byte offset) on first line
        {end_row}    Last line index, <A HREF="motion.html#inclusive">inclusive</A>
        {end_col}    Ending column (byte offset) on last line, <A HREF="motion.html#exclusive">exclusive</A>
        {opts}       Optional parameters. Currently unused.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of lines, or empty array for unloaded buffer.


nvim_buf_get_var({buffer}, {name})                        *<A NAME="nvim_buf_get_var()"></A><B>nvim_buf_get_var()</B>*
    Gets a buffer-scoped (b:) variable.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    Variable name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Variable value


nvim_buf_is_loaded({buffer})                            *<A NAME="nvim_buf_is_loaded()"></A><B>nvim_buf_is_loaded()</B>*
    Checks if a buffer is valid and loaded. See |<A HREF="#api-buffer">api-buffer</A>| for more info
    about unloaded <A HREF="windows.html#buffers">buffers</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the buffer is valid and loaded, false otherwise.


nvim_buf_is_valid({buffer})                              *<A NAME="nvim_buf_is_valid()"></A><B>nvim_buf_is_valid()</B>*
    Checks if a buffer is valid.

    Note:
        Even if a buffer is valid <A HREF="motion.html#it">it</A> may have been unloaded. See |<A HREF="#api-buffer">api-buffer</A>|
        for more info about unloaded <A HREF="windows.html#buffers">buffers</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the buffer is valid, false otherwise.


nvim_buf_line_count({buffer})                          *<A NAME="nvim_buf_line_count()"></A><B>nvim_buf_line_count()</B>*
    Returns the number of lines in the given buffer.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Line <A HREF="intro.html#count">count</A>, or 0 for unloaded buffer. |<A HREF="#api-buffer">api-buffer</A>|


                                                       *<A NAME="nvim_buf_set_keymap()"></A><B>nvim_buf_set_keymap()</B>*
nvim_buf_set_keymap({buffer}, {mode}, <A HREF="map.html#{lhs}">{lhs}</A>, <A HREF="map.html#{rhs}">{rhs}</A>, {*opts})
    Sets a buffer-local |<A HREF="map.html#mapping">mapping</A>| for the given mode.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_set_keymap()">nvim_set_keymap()</A>|


                                                        *<A NAME="nvim_buf_set_lines()"></A><B>nvim_buf_set_lines()</B>*
nvim_buf_set_lines({buffer}, {start}, {end}, {strict_indexing}, {replacement})
    Sets (replaces) a line-range in the buffer.

    Indexing is zero-based, end-exclusive. Negative indices are interpreted <A HREF="motion.html#as">as</A>
    length+1+index: -1 refers to the index past the end. So to change or
    delete the last element use start=-2 and end=-1.

    To insert lines at a given index, set `start` and `end` to the same index.
    To delete a range of lines, set `replacement` to an empty array.

    Out-of-bounds indices are clamped to the nearest valid value, unless
    `strict_indexing` is set.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}           Buffer handle, or 0 for current buffer
        {start}            First line index
        {end}              Last line index, <A HREF="motion.html#exclusive">exclusive</A>
        {strict_indexing}  Whether out-of-bounds should be an error.
        {replacement}      Array of lines to use <A HREF="motion.html#as">as</A> replacement


                                                         *<A NAME="nvim_buf_set_mark()"></A><B>nvim_buf_set_mark()</B>*
nvim_buf_set_mark({buffer}, {name}, {line}, {col}, {opts})
    Sets a named <A HREF="motion.html#mark">mark</A> in the given buffer, all marks are allowed
    file/uppercase, visual, last change, etc. See |<A HREF="motion.html#mark-motions">mark-motions</A>|.

    Marks are (1,0)-indexed. |<A HREF="#api-indexing">api-indexing</A>|

    Note:
        Passing 0 <A HREF="motion.html#as">as</A> line deletes the <A HREF="motion.html#mark">mark</A>

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer to set the <A HREF="motion.html#mark">mark</A> on
        {name}    <A HREF="motion.html#Mark">Mark</A> name
        {line}    Line number
        {col}     Column/row number
        {opts}    Optional parameters. Reserved for future use.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the <A HREF="motion.html#mark">mark</A> was set, else false.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_buf_del_mark()">nvim_buf_del_mark()</A>|
        |<A HREF="#nvim_buf_get_mark()">nvim_buf_get_mark()</A>|


nvim_buf_set_name({buffer}, {name})                      *<A NAME="nvim_buf_set_name()"></A><B>nvim_buf_set_name()</B>*
    Sets the full file name for a buffer

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    Buffer name


                                                         *<A NAME="nvim_buf_set_text()"></A><B>nvim_buf_set_text()</B>*
nvim_buf_set_text({buffer}, {start_row}, {start_col}, {end_row}, {end_col},
                  {replacement})
    Sets (replaces) a range in the buffer

    This is recommended over |<A HREF="#nvim_buf_set_lines()">nvim_buf_set_lines()</A>| when only modifying parts
    of a line, <A HREF="motion.html#as">as</A> <A HREF="#extmarks">extmarks</A> will be preserved on non-modified parts of the
    touched lines.

    Indexing is zero-based. Row indices are end-inclusive, and column indices
    are end-exclusive.

    To insert text at a given `(row, column)` location, use `start_row =
    end_row = row` and `start_col = end_col = col`. To delete the text in a
    range, use `replacement = {}`.

    Prefer |<A HREF="#nvim_buf_set_lines()">nvim_buf_set_lines()</A>| if you are only adding or <A HREF="change.html#deleting">deleting</A> entire
    lines.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}       Buffer handle, or 0 for current buffer
        {start_row}    First line index
        {start_col}    Starting column (byte offset) on first line
        {end_row}      Last line index, <A HREF="motion.html#inclusive">inclusive</A>
        {end_col}      Ending column (byte offset) on last line, <A HREF="motion.html#exclusive">exclusive</A>
        {replacement}  Array of lines to use <A HREF="motion.html#as">as</A> replacement


nvim_buf_set_var({buffer}, {name}, {value})               *<A NAME="nvim_buf_set_var()"></A><B>nvim_buf_set_var()</B>*
    Sets a buffer-scoped (b:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {name}    Variable name
        {value}   Variable value


==============================================================================

Extmark Functions                                                *<A NAME="api-extmark"></A><B>api-extmark</B>*


                                                    *<A NAME="nvim_buf_add_highlight()"></A><B>nvim_buf_add_highlight()</B>*
nvim_buf_add_highlight({buffer}, {ns_id}, {hl_group}, {line}, {col_start},
                       {col_end})
    Adds a highlight to buffer.

    Useful for plugins that dynamically generate highlights to a buffer (like
    a semantic highlighter or linter). The function adds a single highlight to
    a buffer. Unlike |<A HREF="builtin.html#matchaddpos()">matchaddpos()</A>| highlights follow changes to line
    numbering (as lines are inserted/removed above the highlighted line), like
    <A HREF="sign.html#signs">signs</A> and marks <A HREF="diff.html#do">do</A>.

    Namespaces are used for batch deletion/updating of a set of highlights. To
    create a namespace, use |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>| which returns a
    <A HREF="#namespace">namespace</A> id. Pass <A HREF="motion.html#it">it</A> in to this function <A HREF="motion.html#as">as</A> `ns_id` to add highlights to
    the <A HREF="#namespace">namespace</A>. All highlights in the same <A HREF="#namespace">namespace</A> can then be cleared
    with single call to |<A HREF="#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</A>|. If the highlight never
    will be deleted by an <A HREF="#API">API</A> call, pass `ns_id = -1`.

    As a shorthand, `ns_id = 0` can be used to create a new <A HREF="#namespace">namespace</A> for the
    highlight, the allocated id is then returned. If `hl_group` is the empty
    <A HREF="eval.html#string">string</A> no highlight is added, but a new `ns_id` is still returned. This is
    supported for backwards compatibility, new code should use
    |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>| to create a new empty namespace.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}     Buffer handle, or 0 for current buffer
        {ns_id}      <A HREF="#namespace">namespace</A> to use or -1 for ungrouped highlight
        {hl_group}   Name of the highlight group to use
        {line}       Line to highlight (zero-indexed)
        {col_start}  Start of (byte-indexed) column range to highlight
        {col_end}    End of (byte-indexed) column range to highlight, or -1 to
                     highlight to end of line

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        The ns_id that was used


                                                  *<A NAME="nvim_buf_clear_namespace()"></A><B>nvim_buf_clear_namespace()</B>*
nvim_buf_clear_namespace({buffer}, {ns_id}, {line_start}, {line_end})
    Clears namespaced <A HREF="vimindex.html#objects">objects</A> (highlights, <A HREF="#extmarks">extmarks</A>, virtual text) from a
    region.

    Lines are 0-indexed. |<A HREF="#api-indexing">api-indexing</A>| To clear the <A HREF="#namespace">namespace</A> in the entire
    buffer, specify line_start=0 and line_end=-1.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}      Buffer handle, or 0 for current buffer
        {ns_id}       Namespace to clear, or -1 to clear all namespaces.
        {line_start}  Start of range of lines to clear
        {line_end}    End of range of lines to clear (exclusive) or -1 to
                      clear to end of buffer.


nvim_buf_del_extmark({buffer}, {ns_id}, {id})         *<A NAME="nvim_buf_del_extmark()"></A><B>nvim_buf_del_extmark()</B>*
    Removes an extmark.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
        {id}      Extmark id

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the extmark was found, else false


                                                *<A NAME="nvim_buf_get_extmark_by_id()"></A><B>nvim_buf_get_extmark_by_id()</B>*
nvim_buf_get_extmark_by_id({buffer}, {ns_id}, {id}, {opts})
    Gets the position (0-indexed) of an extmark.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
        {id}      Extmark id
        {opts}    Optional parameters. Keys:
                  • details: Whether to include the details <A HREF="eval.html#dict">dict</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        0-indexed (row, col) tuple or empty <A HREF="eval.html#list">list</A> () if extmark id was absent


                                                     *<A NAME="nvim_buf_get_extmarks()"></A><B>nvim_buf_get_extmarks()</B>*
nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts})
    Gets <A HREF="#extmarks">extmarks</A> in &quot;traversal order&quot; from a |<A HREF="motion.html#charwise">charwise</A>| region defined by
    buffer positions (inclusive, 0-indexed |<A HREF="#api-indexing">api-indexing</A>|).

    Region can be given <A HREF="motion.html#as">as</A> (row,col) tuples, or valid extmark ids (whose
    positions define the bounds). 0 and -1 are understood <A HREF="motion.html#as">as</A> (0,0) and (-1,-1)
    respectively, thus the following are equivalent:

<B>    nvim_buf_get_extmarks(0, my_ns, 0, -1, {})</B>
<B>    nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})</B>
 

    If `end` is <A HREF="various.html#less">less</A> than `start`, traversal works backwards. (Useful with
    `limit`, to get the first marks prior to a given position.)

    Example:

<B>    local a   = vim.api</B>
<B>    local pos = a.nvim_win_get_cursor(0)</B>
<B>    local ns  = a.nvim_create_namespace('my-plugin')</B>
<B>    -- Create new extmark at line 1, column 1.</B>
<B>    local m1  = a.nvim_buf_set_extmark(0, ns, 0, 0, {})</B>
<B>    -- Create new extmark at line 3, column 1.</B>
<B>    local m2  = a.nvim_buf_set_extmark(0, ns, 0, 2, {})</B>
<B>    -- Get extmarks only from line 3.</B>
<B>    local ms  = a.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})</B>
<B>    -- Get all marks in this buffer + namespace.</B>
<B>    local all = a.nvim_buf_get_extmarks(0, ns, 0, -1, {})</B>
<B>    print(vim.inspect(ms))</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
        {start}   Start of range: a 0-indexed (row, col) or valid extmark id
                  (whose position defines the bound). |<A HREF="#api-indexing">api-indexing</A>|
        {end}     End of range (inclusive): a 0-indexed (row, col) or valid
                  extmark id (whose position defines the bound).
                  |<A HREF="#api-indexing">api-indexing</A>|
        {opts}    Optional parameters. Keys:
                  • limit: Maximum number of marks to return
                  • details Whether to include the details <A HREF="eval.html#dict">dict</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#List">List</A> of [extmark_id, row, col] tuples in &quot;traversal order&quot;.


                                                      *<A NAME="nvim_buf_set_extmark()"></A><B>nvim_buf_set_extmark()</B>*
nvim_buf_set_extmark({buffer}, {ns_id}, {line}, {col}, {*opts})
    Creates or updates an extmark.

    By default a new extmark is created when no id is passed in, but <A HREF="motion.html#it">it</A> is
    also possible to create a new <A HREF="motion.html#mark">mark</A> by passing in a previously unused id or
    move an existing <A HREF="motion.html#mark">mark</A> by passing in its id. The caller must then keep
    track of existing and unused ids itself. (Useful over <A HREF="#RPC">RPC</A>, to avoid
    waiting for the return value.)

    Using the optional arguments, <A HREF="motion.html#it">it</A> is possible to use this to highlight a
    range of text, and also to associate virtual text to the <A HREF="motion.html#mark">mark</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer handle, or 0 for current buffer
        {ns_id}   Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
        {line}    Line where to place the <A HREF="motion.html#mark">mark</A>, 0-based. |<A HREF="#api-indexing">api-indexing</A>|
        {col}     Column where to place the <A HREF="motion.html#mark">mark</A>, 0-based. |<A HREF="#api-indexing">api-indexing</A>|
        {opts}    Optional parameters.
                  • id : id of the extmark to edit.
                  • end_row : ending line of the <A HREF="motion.html#mark">mark</A>, 0-based <A HREF="motion.html#inclusive">inclusive</A>.
                  • end_col : ending col of the <A HREF="motion.html#mark">mark</A>, 0-based <A HREF="motion.html#exclusive">exclusive</A>.
                  • hl_group : name of the highlight group used to highlight
                    this <A HREF="motion.html#mark">mark</A>.
                  • hl_eol : when true, for a multiline highlight covering the
                    EOL of a line, continue the highlight for the rest of the
                    screen line (just like for <A HREF="diff.html#diff">diff</A> and cursorline highlight).
                  • virt_text : virtual text to link to this <A HREF="motion.html#mark">mark</A>. A <A HREF="eval.html#list">list</A> of
                    [text, highlight] tuples, each representing a text chunk
                    with specified highlight. `highlight` element can either
                    be a single highlight group, or an array of multiple
                    highlight groups that will be stacked (highest priority
                    last). A highlight group can be supplied either <A HREF="motion.html#as">as</A> a
                    <A HREF="eval.html#string">string</A> or <A HREF="motion.html#as">as</A> an integer, the latter which can be obtained
                    using |<A HREF="#nvim_get_hl_id_by_name()">nvim_get_hl_id_by_name()</A>|.
                  • virt_text_pos : position of virtual text. Possible values:
                    • &quot;eol&quot;: right after eol character (default)
                    • &quot;overlay&quot;: display over the specified column, without
                      shifting the underlying text.
                    • &quot;right_align&quot;: display right aligned in the <A HREF="windows.html#window">window</A>.

                  • virt_text_win_col : position the virtual text at a fixed
                    <A HREF="windows.html#window">window</A> column (starting from the first text column)
                  • virt_text_hide : hide the virtual text when the background
                    text is selected or hidden due to horizontal scroll
                    <A HREF="options.html#'nowrap'">'nowrap'</A>
                  • hl_mode : <A HREF="intro.html#control">control</A> how highlights are combined with the
                    highlights of the text. Currently only affects virt_text
                    highlights, but might affect `hl_group` in later versions.
                    • &quot;replace&quot;: only show the virt_text color. This is the
                      default
                    • &quot;combine&quot;: combine with background text color
                    • &quot;blend&quot;: blend with background text color.

                  • virt_lines : virtual lines to add next to this <A HREF="motion.html#mark">mark</A> This
                    should be an array over lines, where each line in turn is
                    an array over [text, highlight] tuples. In general, buffer
                    and <A HREF="windows.html#window">window</A> <A HREF="options.html#options">options</A> <A HREF="diff.html#do">do</A> not affect the display of the text.
                    In particular <A HREF="options.html#'wrap'">'wrap'</A> and <A HREF="options.html#'linebreak'">'linebreak'</A> <A HREF="options.html#options">options</A> <A HREF="diff.html#do">do</A> not take
                    effect, so the number of extra screen lines will always
                    match the size of the array. However the <A HREF="options.html#'tabstop'">'tabstop'</A> buffer
                    option is still used for hard tabs. By default lines are
                    placed below the buffer line containing the <A HREF="motion.html#mark">mark</A>.
                  • virt_lines_above: place virtual lines above instead.
                  • virt_lines_leftcol: Place <A HREF="#extmarks">extmarks</A> in the leftmost column
                    of the <A HREF="windows.html#window">window</A>, bypassing sign and number columns.
                  • ephemeral : for use with |<A HREF="#nvim_set_decoration_provider()">nvim_set_decoration_provider()</A>|
                    callbacks. The <A HREF="motion.html#mark">mark</A> will only be used for the current
                    redraw cycle, and not be permantently stored in the
                    buffer.
                  • right_gravity : <A HREF="options.html#boolean">boolean</A> that indicates the direction the
                    extmark will be shifted in when new text is inserted (true
                    for right, false for left). defaults to true.
                  • end_right_gravity : <A HREF="options.html#boolean">boolean</A> that indicates the direction
                    the extmark end position (if <A HREF="motion.html#it">it</A> exists) will be shifted in
                    when new text is inserted (true for right, false for
                    left). Defaults to false.
                  • priority: a priority value for the highlight group or sign
                    attribute. For example <A HREF="treesitter.html#treesitter">treesitter</A> highlighting uses a
                    value of 100.
                  • strict: <A HREF="options.html#boolean">boolean</A> that indicates extmark should not be
                    placed if the line or column value is past the end of the
                    buffer or end of the line respectively. Defaults to true.
                  • sign_text: <A HREF="eval.html#string">string</A> of length 1-2 used to display in the
                    sign column. Note: ranges are unsupported and decorations
                    are only applied to start_row
                  • sign_hl_group: name of the highlight group used to
                    highlight the sign column text. Note: ranges are
                    unsupported and decorations are only applied to start_row
                  • number_hl_group: name of the highlight group used to
                    highlight the number column. Note: ranges are unsupported
                    and decorations are only applied to start_row
                  • line_hl_group: name of the highlight group used to
                    highlight the whole line. Note: ranges are unsupported and
                    decorations are only applied to start_row
                  • cursorline_hl_group: name of the highlight group used to
                    highlight the line when the cursor is on the same line <A HREF="motion.html#as">as</A>
                    the <A HREF="motion.html#mark">mark</A> and <A HREF="options.html#'cursorline'">'cursorline'</A> is enabled. Note: ranges are
                    unsupported and decorations are only applied to start_row
                  • <A HREF="syntax.html#conceal">conceal</A>: <A HREF="eval.html#string">string</A> which should be either empty or a single
                    character. Enable concealing similar to |<A HREF="syntax.html#:syn-conceal">:syn-conceal</A>|.
                    When a character is supplied <A HREF="motion.html#it">it</A> is used <A HREF="motion.html#as">as</A> |<A HREF="syntax.html#:syn-cchar">:syn-cchar</A>|.
                    &quot;hl_group&quot; is used <A HREF="motion.html#as">as</A> highlight for the cchar if provided,
                    otherwise <A HREF="motion.html#it">it</A> defaults to |<A HREF="syntax.html#hl-Conceal">hl-Conceal</A>|.
                  • <A HREF="spell.html#spell">spell</A>: <A HREF="options.html#boolean">boolean</A> indicating that <A HREF="spell.html#spell">spell</A> checking should be
                    performed within this extmark
                  • ui_watched: <A HREF="options.html#boolean">boolean</A> that indicates the <A HREF="motion.html#mark">mark</A> should be
                    drawn by a <A HREF="ui.html#UI">UI</A>. When set, the <A HREF="ui.html#UI">UI</A> will receive win_extmark
                    <A HREF="autocmd.html#events">events</A>. Note: the <A HREF="motion.html#mark">mark</A> is positioned by virt_text
                    attributes. Can be used together with virt_text.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Id of the created/updated extmark


nvim_create_namespace({name})                        *<A NAME="nvim_create_namespace()"></A><B>nvim_create_namespace()</B>*

    Creates a new *<A NAME="namespace"></A><B>namespace</B>* or gets an existing one.

    Namespaces are used for buffer highlights and virtual text, see
    |<A HREF="#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>| and |<A HREF="#nvim_buf_set_extmark()">nvim_buf_set_extmark()</A>|.

    Namespaces can be named or anonymous. If `name` matches an existing
    <A HREF="#namespace">namespace</A>, the associated id is returned. If `name` is an empty <A HREF="eval.html#string">string</A> a
    new, anonymous <A HREF="#namespace">namespace</A> is created.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  Namespace name or empty <A HREF="eval.html#string">string</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Namespace id


<A HREF="#nvim_get_namespaces()">nvim_get_namespaces()</A>                                  *<A NAME="nvim_get_namespaces()"></A><B>nvim_get_namespaces()</B>*
    Gets existing, non-anonymous namespaces.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#dict">dict</A> that maps from names to <A HREF="#namespace">namespace</A> ids.


                                              *<A NAME="nvim_set_decoration_provider()"></A><B>nvim_set_decoration_provider()</B>*
nvim_set_decoration_provider({ns_id}, {*opts})
    Set or change decoration <A HREF="provider.html#provider">provider</A> for a <A HREF="#namespace">namespace</A>

    This is a very general purpose interface for having <A HREF="lua.html#lua">lua</A> callbacks being
    triggered during the redraw code.

    The expected usage is to set <A HREF="#extmarks">extmarks</A> for the currently redrawn buffer.
    |<A HREF="#nvim_buf_set_extmark()">nvim_buf_set_extmark()</A>| can be called to add marks on a per-window or
    per-lines basis. Use the `ephemeral` key to only use the <A HREF="motion.html#mark">mark</A> for the
    current screen redraw (the callback will be called again for the next
    redraw ).

    Note: this function should not be called often. Rather, the callbacks
    themselves can be used to throttle unneeded callbacks. the `on_start`
    callback can return `false` to disable the <A HREF="provider.html#provider">provider</A> until the next redraw.
    Similarly, return `false` in `on_win` will skip the `on_lines` calls for
    that <A HREF="windows.html#window">window</A> (but any <A HREF="#extmarks">extmarks</A> set in `on_win` will still be used). A
    <A HREF="usr_05.html#plugin">plugin</A> managing multiple sources of decoration should ideally only set one
    <A HREF="provider.html#provider">provider</A>, and <A HREF="diff.html#merge">merge</A> the sources internally. You can use multiple `ns_id`
    for the <A HREF="#extmarks">extmarks</A> set/modified inside the callback anyway.

    Note: doing anything other than setting <A HREF="#extmarks">extmarks</A> is considered
    experimental. Doing things like <A HREF="change.html#changing">changing</A> <A HREF="options.html#options">options</A> are not expliticly
    forbidden, but is likely to have unexpected consequences (such <A HREF="motion.html#as">as</A> 100&#37; CPU
    consumption). doing `vim.rpcnotify` should be OK, but `vim.rpcrequest` is
    quite dubious for the moment.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="vim.html">vim.api</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {ns_id}  Namespace id from |<A HREF="#nvim_create_namespace()">nvim_create_namespace()</A>|
        {opts}   Table of callbacks:
                 • on_start: called first on each screen redraw [&quot;start&quot;,
                   tick]
                 • on_buf: called for each buffer being redrawn (before <A HREF="windows.html#window">window</A>
                   callbacks) [&quot;buf&quot;, bufnr, tick]
                 • on_win: called when starting to redraw a specific <A HREF="windows.html#window">window</A>.
                   [&quot;win&quot;, <A HREF="windows.html#winid">winid</A>, bufnr, topline, botline_guess]
                 • on_line: called for each buffer line being redrawn. (The
                   interaction with fold lines is subject to change) [&quot;win&quot;,
                   <A HREF="windows.html#winid">winid</A>, bufnr, row]
                 • on_end: called at the end of a redraw cycle [&quot;end&quot;, tick]


==============================================================================

Window Functions                                                  *<A NAME="api-window"></A><B>api-window</B>*


nvim_win_call({window}, {fun})                               *<A NAME="nvim_win_call()"></A><B>nvim_win_call()</B>*
    Calls a function with <A HREF="windows.html#window">window</A> <A HREF="motion.html#as">as</A> temporary current <A HREF="windows.html#window">window</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="vim.html">vim.api</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {fun}     Function to call inside the <A HREF="windows.html#window">window</A> (currently <A HREF="lua.html#lua">lua</A> callable
                  only)

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Return value of function. NB: will deepcopy <A HREF="lua.html#lua">lua</A> values currently, use
        upvalues to send <A HREF="lua.html#lua">lua</A> references in and out.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="builtin.html#win_execute()">win_execute()</A>|
        |<A HREF="#nvim_buf_call()">nvim_buf_call()</A>|


nvim_win_close({window}, {force})                           *<A NAME="nvim_win_close()"></A><B>nvim_win_close()</B>*
    Closes the window (like |<A HREF="windows.html#:close">:close</A>| with a |<A HREF="windows.html#window-ID">window-ID</A>|).

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {force}   Behave like `:close!` The last <A HREF="windows.html#window">window</A> of a buffer with
                  unwritten changes can be closed. The buffer will become
                  hidden, even if <A HREF="options.html#'hidden'">'hidden'</A> is not set.


nvim_win_del_var({window}, {name})                        *<A NAME="nvim_win_del_var()"></A><B>nvim_win_del_var()</B>*
    Removes a window-scoped (w:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {name}    Variable name


nvim_win_get_buf({window})                                *<A NAME="nvim_win_get_buf()"></A><B>nvim_win_get_buf()</B>*
    Gets the current buffer in a <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Buffer handle


nvim_win_get_cursor({window})                          *<A NAME="nvim_win_get_cursor()"></A><B>nvim_win_get_cursor()</B>*
    Gets the (1,0)-indexed cursor position in the <A HREF="windows.html#window">window</A>. |<A HREF="#api-indexing">api-indexing</A>|

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (row, col) tuple


nvim_win_get_height({window})                          *<A NAME="nvim_win_get_height()"></A><B>nvim_win_get_height()</B>*
    Gets the <A HREF="windows.html#window">window</A> height

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Height <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of rows


nvim_win_get_number({window})                          *<A NAME="nvim_win_get_number()"></A><B>nvim_win_get_number()</B>*
    Gets the <A HREF="windows.html#window">window</A> number

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Window number


nvim_win_get_position({window})                      *<A NAME="nvim_win_get_position()"></A><B>nvim_win_get_position()</B>*
    Gets the <A HREF="windows.html#window">window</A> position in display cells. First position is zero.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        (row, col) tuple with the <A HREF="windows.html#window">window</A> position


nvim_win_get_tabpage({window})                        *<A NAME="nvim_win_get_tabpage()"></A><B>nvim_win_get_tabpage()</B>*
    Gets the <A HREF="windows.html#window">window</A> <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Tabpage that contains the <A HREF="windows.html#window">window</A>


nvim_win_get_var({window}, {name})                        *<A NAME="nvim_win_get_var()"></A><B>nvim_win_get_var()</B>*
    Gets a window-scoped (w:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {name}    Variable name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Variable value


nvim_win_get_width({window})                            *<A NAME="nvim_win_get_width()"></A><B>nvim_win_get_width()</B>*
    Gets the <A HREF="windows.html#window">window</A> width

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Width <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of columns


nvim_win_hide({window})                                      *<A NAME="nvim_win_hide()"></A><B>nvim_win_hide()</B>*
    Closes the <A HREF="windows.html#window">window</A> and hide the buffer <A HREF="motion.html#it">it</A> contains (like |<A HREF="windows.html#:hide">:hide</A>| with a
    |<A HREF="windows.html#window-ID">window-ID</A>|).

    Like |<A HREF="windows.html#:hide">:hide</A>| the buffer becomes hidden unless another <A HREF="windows.html#window">window</A> is editing
    <A HREF="motion.html#it">it</A>, or <A HREF="options.html#'bufhidden'">'bufhidden'</A> is `unload`, `delete` or `wipe` <A HREF="motion.html#as">as</A> opposed to |<A HREF="windows.html#:close">:close</A>|
    or |<A HREF="#nvim_win_close()">nvim_win_close()</A>|, which will close the buffer.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>


nvim_win_is_valid({window})                              *<A NAME="nvim_win_is_valid()"></A><B>nvim_win_is_valid()</B>*
    Checks if a <A HREF="windows.html#window">window</A> is valid

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the <A HREF="windows.html#window">window</A> is valid, false otherwise


nvim_win_set_buf({window}, {buffer})                      *<A NAME="nvim_win_set_buf()"></A><B>nvim_win_set_buf()</B>*
    Sets the current buffer in a <A HREF="windows.html#window">window</A>, without side effects

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {buffer}  Buffer handle


nvim_win_set_cursor({window}, {pos})                   *<A NAME="nvim_win_set_cursor()"></A><B>nvim_win_set_cursor()</B>*
    Sets the (1,0)-indexed cursor position in the <A HREF="windows.html#window">window</A>. |<A HREF="#api-indexing">api-indexing</A>| This
    scrolls the <A HREF="windows.html#window">window</A> even if <A HREF="motion.html#it">it</A> is not the current one.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {pos}     (row, col) tuple representing the new position


nvim_win_set_height({window}, {height})                *<A NAME="nvim_win_set_height()"></A><B>nvim_win_set_height()</B>*
    Sets the <A HREF="windows.html#window">window</A> height.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {height}  Height <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of rows


nvim_win_set_hl_ns({window}, {ns_id})                   *<A NAME="nvim_win_set_hl_ns()"></A><B>nvim_win_set_hl_ns()</B>*
    Set highlight <A HREF="#namespace">namespace</A> for a <A HREF="windows.html#window">window</A>. This will use highlights defined in
    this <A HREF="#namespace">namespace</A>, but fall back to global highlights (ns=0) when missing.

    This takes precedence over the <A HREF="options.html#'winhighlight'">'winhighlight'</A> option.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {ns_id}  the <A HREF="#namespace">namespace</A> to use


nvim_win_set_var({window}, {name}, {value})               *<A NAME="nvim_win_set_var()"></A><B>nvim_win_set_var()</B>*
    Sets a window-scoped (w:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {name}    Variable name
        {value}   Variable value


nvim_win_set_width({window}, {width})                   *<A NAME="nvim_win_set_width()"></A><B>nvim_win_set_width()</B>*
    Sets the <A HREF="windows.html#window">window</A> width. This will only succeed if the screen is split
    vertically.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {width}   Width <A HREF="motion.html#as">as</A> a <A HREF="intro.html#count">count</A> of columns


==============================================================================

Win_Config Functions                                          *<A NAME="api-win_config"></A><B>api-win_config</B>*


nvim_open_win({buffer}, {enter}, {*config})                  *<A NAME="nvim_open_win()"></A><B>nvim_open_win()</B>*
    Open a new <A HREF="windows.html#window">window</A>.

    Currently this is used to open floating and external <A HREF="windows.html#windows">windows</A>. Floats are
    <A HREF="windows.html#windows">windows</A> that are drawn above the split layout, at some anchor position in
    some other <A HREF="windows.html#window">window</A>. Floats can be drawn internally or by external <A HREF="gui.html#GUI">GUI</A> with
    the |<A HREF="ui.html#ui-multigrid">ui-multigrid</A>| extension. External <A HREF="windows.html#windows">windows</A> are only supported with
    multigrid GUIs, and are displayed <A HREF="motion.html#as">as</A> separate top-level <A HREF="windows.html#windows">windows</A>.

    For a general overview of floats, see |<A HREF="#api-floatwin">api-floatwin</A>|.

    Exactly one of `external` and `relative` must be specified. The `width`
    and `height` of the new <A HREF="windows.html#window">window</A> must be specified.

    With relative=editor (row=0,col=0) refers to the top-left corner of the
    screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right
    corner. Fractional values are allowed, but the builtin implementation
    (used by non-multigrid UIs) will always round down to nearest integer.

    Out-of-bounds values, and configurations that make the float not fit
    inside the main editor, are allowed. The builtin implementation truncates
    values so floats are fully within the main screen grid. External GUIs
    could let floats hover outside of the main <A HREF="windows.html#window">window</A> like a tooltip, but this
    should not be used to specify arbitrary WM screen positions.

    Example (Lua): window-relative float
<B>        vim.api.nvim_open_win(0, false,</B>
<B>          {relative='win', row=3, col=3, width=12, height=3})</B>
 

    Example (Lua): buffer-relative float (travels <A HREF="motion.html#as">as</A> buffer is scrolled)
<B>        vim.api.nvim_open_win(0, false,</B>
<B>          {relative='win', width=12, height=3, bufpos={100,10}})</B>
 

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        not allowed when |<A HREF="eval.html#textlock">textlock</A>| is active

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {buffer}  Buffer to display, or 0 for current buffer
        {enter}   Enter the <A HREF="windows.html#window">window</A> (make <A HREF="motion.html#it">it</A> the current <A HREF="windows.html#window">window</A>)
        {config}  Map defining the <A HREF="windows.html#window">window</A> configuration. Keys:
                  • relative: Sets the <A HREF="windows.html#window">window</A> layout to &quot;floating&quot;, placed at
                    (row,col) coordinates relative to:
                    • &quot;editor&quot; The global editor grid
                    • &quot;win&quot; Window given by the `win` field, or current
                      <A HREF="windows.html#window">window</A>.
                    • &quot;cursor&quot; Cursor position in current <A HREF="windows.html#window">window</A>.

                  • win: |<A HREF="windows.html#window-ID">window-ID</A>| for relative=&quot;win&quot;.
                  • anchor: Decides which corner of the float to place at
                    (row,col):
                    • &quot;NW&quot; northwest (default)
                    • &quot;NE&quot; northeast
                    • &quot;SW&quot; southwest
                    • &quot;SE&quot; southeast

                  • width: Window width (in character cells). Minimum of 1.
                  • height: Window height (in character cells). Minimum of 1.
                  • bufpos: Places float relative to buffer text (only when
                    relative=&quot;win&quot;). Takes a tuple of zero-indexed [line,
                    column]. `row` and `col` if given are applied relative to this position, else they
                    default to:
                    • `row=1` and `col=0` if `anchor` is &quot;NW&quot; or &quot;NE&quot;
                    • `row=0` and `col=0` if `anchor` is &quot;SW&quot; or &quot;SE&quot; (thus
                      like a tooltip near the buffer text).

                  • row: Row position in units of &quot;screen cell height&quot;, may be
                    fractional.
                  • col: Column position in units of &quot;screen cell width&quot;, may
                    be fractional.
                  • focusable: Enable focus by user actions (wincmds, mouse
                    <A HREF="autocmd.html#events">events</A>). Defaults to true. Non-focusable <A HREF="windows.html#windows">windows</A> can be
                    entered by |<A HREF="#nvim_set_current_win()">nvim_set_current_win()</A>|.
                  • external: <A HREF="gui.html#GUI">GUI</A> should display the <A HREF="windows.html#window">window</A> <A HREF="motion.html#as">as</A> an external
                    top-level <A HREF="windows.html#window">window</A>. Currently accepts no other positioning
                    configuration together with this.
                  • zindex: Stacking order. floats with higher `zindex` go on top on floats with lower indices. Must be larger
                    than zero. The following screen elements have hard-coded
                    z-indices:
                    • 100: insert completion popupmenu
                    • 200: message scrollback
                    • 250: <A HREF="cmdline.html#cmdline">cmdline</A> completion popupmenu (when
                      wildoptions+=pum) The default value for floats are 50.
                      In general, values below 100 are recommended, unless
                      there is a good reason to overshadow builtin elements.

                  • style: Configure the appearance of the <A HREF="windows.html#window">window</A>. Currently
                    only takes one non-empty value:
                    • &quot;minimal&quot; Nvim will display the <A HREF="windows.html#window">window</A> with many <A HREF="ui.html#UI">UI</A>
                      <A HREF="options.html#options">options</A> disabled. This is useful when displaying a
                      temporary float where the text should not be edited.
                      Disables <A HREF="options.html#'number'">'number'</A>, <A HREF="options.html#'relativenumber'">'relativenumber'</A>, <A HREF="options.html#'cursorline'">'cursorline'</A>,
                      <A HREF="options.html#'cursorcolumn'">'cursorcolumn'</A>, <A HREF="options.html#'foldcolumn'">'foldcolumn'</A>, <A HREF="options.html#'spell'">'spell'</A> and <A HREF="options.html#'list'">'list'</A>
                      <A HREF="options.html#options">options</A>. <A HREF="options.html#'signcolumn'">'signcolumn'</A> is changed to `auto` and
                      <A HREF="options.html#'colorcolumn'">'colorcolumn'</A> is cleared. The end-of-buffer region is
                      hidden by setting `eob` flag of <A HREF="options.html#'fillchars'">'fillchars'</A> to a space
                      char, and clearing the |<A HREF="syntax.html#hl-EndOfBuffer">hl-EndOfBuffer</A>| region in
                      <A HREF="options.html#'winhighlight'">'winhighlight'</A>.

                  • border: Style of (optional) <A HREF="windows.html#window">window</A> border. This can either
                    be a <A HREF="eval.html#string">string</A> or an array. The <A HREF="eval.html#string">string</A> values are
                    • &quot;none&quot;: No border (default).
                    • &quot;single&quot;: A single line box.
                    • &quot;double&quot;: A double line box.
                    • &quot;rounded&quot;: Like &quot;single&quot;, but with rounded corners (&quot;╭&quot;
                      etc.).
                    • &quot;solid&quot;: Adds padding by a single <A HREF="pattern.html#whitespace">whitespace</A> cell.
                    • &quot;shadow&quot;: A drop shadow effect by blending with the
                      background.
                    • If <A HREF="motion.html#it">it</A> is an array, <A HREF="motion.html#it">it</A> should have a length of eight or
                      any divisor of eight. The array will specifify the eight
                      chars building up the border in a clockwise fashion
                      starting with the top-left corner. As an example, the
                      double box style could be specified <A HREF="motion.html#as">as</A> [ &quot;╔&quot;, &quot;═&quot; ,&quot;╗&quot;,
                      &quot;║&quot;, &quot;╝&quot;, &quot;═&quot;, &quot;╚&quot;, &quot;║&quot; ]. If the number of chars are
                      <A HREF="various.html#less">less</A> than eight, they will be repeated. Thus an ASCII
                      border could be specified <A HREF="motion.html#as">as</A> [ &quot;<A HREF="pattern.html#/">/</A>&quot;, &quot;<A HREF="motion.html#-">-</A>&quot;, &quot;\\&quot;, &quot;|&quot; ], or
                      all chars the same <A HREF="motion.html#as">as</A> [ &quot;<A HREF="change.html#x">x</A>&quot; ]. An empty <A HREF="eval.html#string">string</A> can be
                      used to turn off a specific border, for instance, [ &quot;&quot;,
                      &quot;&quot;, &quot;&quot;, &quot;<A HREF="change.html#&gt;">&gt;</A>&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;<A HREF="change.html#&lt;">&lt;</A>&quot; ] will only make vertical
                      borders but not horizontal ones. By default,
                      `FloatBorder` highlight is used, which links to
                      `WinSeparator` when not defined. It could also be
                      specified by character: [ {&quot;+&quot;, &quot;MyCorner&quot;}, {&quot;x&quot;,
                      &quot;MyBorder&quot;} ].

                  • noautocmd: If true then no buffer-related <A HREF="autocmd.html#autocommand">autocommand</A>
                    <A HREF="autocmd.html#events">events</A> such <A HREF="motion.html#as">as</A> |<A HREF="autocmd.html#BufEnter">BufEnter</A>|, |<A HREF="autocmd.html#BufLeave">BufLeave</A>| or |<A HREF="autocmd.html#BufWinEnter">BufWinEnter</A>| may
                    fire from calling this function.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Window handle, or 0 on error


nvim_win_get_config({window})                          *<A NAME="nvim_win_get_config()"></A><B>nvim_win_get_config()</B>*
    Gets <A HREF="windows.html#window">window</A> configuration.

    The returned value may be given to |<A HREF="#nvim_open_win()">nvim_open_win()</A>|.

    `relative` is empty for normal <A HREF="windows.html#windows">windows</A>.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Map defining the <A HREF="windows.html#window">window</A> configuration, see |<A HREF="#nvim_open_win()">nvim_open_win()</A>|


nvim_win_set_config({window}, {*config})               *<A NAME="nvim_win_set_config()"></A><B>nvim_win_set_config()</B>*
    Configures <A HREF="windows.html#window">window</A> layout. Currently only for floating and external <A HREF="windows.html#windows">windows</A>
    (including <A HREF="change.html#changing">changing</A> a split <A HREF="windows.html#window">window</A> to those layouts).

    When reconfiguring a floating <A HREF="windows.html#window">window</A>, absent option keys will not be
    changed. `row`/`col` and `relative` must be reconfigured together.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {window}  Window handle, or 0 for current <A HREF="windows.html#window">window</A>
        {config}  Map defining the <A HREF="windows.html#window">window</A> configuration, see |<A HREF="#nvim_open_win()">nvim_open_win()</A>|

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_open_win()">nvim_open_win()</A>|


==============================================================================

Tabpage Functions                                                *<A NAME="api-tabpage"></A><B>api-tabpage</B>*


nvim_tabpage_del_var({tabpage}, {name})               *<A NAME="nvim_tabpage_del_var()"></A><B>nvim_tabpage_del_var()</B>*
    Removes a tab-scoped (t:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>
        {name}     Variable name


nvim_tabpage_get_number({tabpage})                 *<A NAME="nvim_tabpage_get_number()"></A><B>nvim_tabpage_get_number()</B>*
    Gets the <A HREF="tabpage.html#tabpage">tabpage</A> number

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Tabpage number


nvim_tabpage_get_var({tabpage}, {name})               *<A NAME="nvim_tabpage_get_var()"></A><B>nvim_tabpage_get_var()</B>*
    Gets a tab-scoped (t:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>
        {name}     Variable name

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Variable value


nvim_tabpage_get_win({tabpage})                       *<A NAME="nvim_tabpage_get_win()"></A><B>nvim_tabpage_get_win()</B>*
    Gets the current <A HREF="windows.html#window">window</A> in a <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Window handle


nvim_tabpage_is_valid({tabpage})                     *<A NAME="nvim_tabpage_is_valid()"></A><B>nvim_tabpage_is_valid()</B>*
    Checks if a <A HREF="tabpage.html#tabpage">tabpage</A> is valid

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        true if the <A HREF="tabpage.html#tabpage">tabpage</A> is valid, false otherwise


nvim_tabpage_list_wins({tabpage})                   *<A NAME="nvim_tabpage_list_wins()"></A><B>nvim_tabpage_list_wins()</B>*
    Gets the <A HREF="windows.html#windows">windows</A> in a <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#List">List</A> of <A HREF="windows.html#windows">windows</A> in `tabpage`


                                                      *<A NAME="nvim_tabpage_set_var()"></A><B>nvim_tabpage_set_var()</B>*
nvim_tabpage_set_var({tabpage}, {name}, {value})
    Sets a tab-scoped (t:) variable

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {tabpage}  Tabpage handle, or 0 for current <A HREF="tabpage.html#tabpage">tabpage</A>
        {name}     Variable name
        {value}    Variable value


==============================================================================

Autocmd Functions                                                *<A NAME="api-autocmd"></A><B>api-autocmd</B>*


nvim_clear_autocmds({*opts})                           *<A NAME="nvim_clear_autocmds()"></A><B>nvim_clear_autocmds()</B>*
    Clear all autocommands that match the corresponding {opts}. To delete a
    particular autocmd, see |<A HREF="#nvim_del_autocmd()">nvim_del_autocmd()</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opts}  Parameters
                • event: (string|table) Examples:
                  • event: &quot;pat1&quot;
                  • event: { &quot;pat1&quot; }
                  • event: { &quot;pat1&quot;, &quot;pat2&quot;, &quot;pat3&quot; }

                • <A HREF="pattern.html#pattern">pattern</A>: (string|table)
                  • <A HREF="pattern.html#pattern">pattern</A> or patterns to match exactly.
                    • For example, if you have `*.py` <A HREF="motion.html#as">as</A> that <A HREF="pattern.html#pattern">pattern</A> for the
                      <A HREF="autocmd.html#autocmd">autocmd</A>, you must pass `*.py` exactly to clear <A HREF="motion.html#it">it</A>.
                      `test.py` will not match the <A HREF="pattern.html#pattern">pattern</A>.

                  • defaults to clearing all patterns.
                  • NOTE: Cannot be used with {buffer}

                • buffer: (bufnr)
                  • clear only |<A HREF="autocmd.html#autocmd-buflocal">autocmd-buflocal</A>| autocommands.
                  • NOTE: Cannot be used with {pattern}

                • group: (string|int) The augroup name or id.
                  • NOTE: If not passed, will only delete autocmds not in any group.


nvim_create_augroup({name}, {*opts})                   *<A NAME="nvim_create_augroup()"></A><B>nvim_create_augroup()</B>*
    Create or get an <A HREF="autocmd.html#autocommand">autocommand</A> group |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|.

    To get an existing group id, <A HREF="diff.html#do">do</A>:
<B>        local id = vim.api.nvim_create_augroup("MyGroup", {</B>
<B>            clear = false</B>
<B>        })</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  <A HREF="eval.html#String">String</A>: The name of the group
        {opts}  <A HREF="eval.html#Dictionary">Dictionary</A> Parameters
                • clear (bool) optional: defaults to true. Clear existing
                  commands if the group already exists |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Integer">Integer</A> id of the created group.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|


nvim_create_autocmd({event}, {*opts})                  *<A NAME="nvim_create_autocmd()"></A><B>nvim_create_autocmd()</B>*
    Create an |<A HREF="autocmd.html#autocommand">autocommand</A>|

    The <A HREF="#API">API</A> allows for two (mutually <A HREF="motion.html#exclusive">exclusive</A>) types of actions to be
    executed when the <A HREF="autocmd.html#autocommand">autocommand</A> triggers: a callback function (Lua or
    Vimscript), or a command (like regular autocommands).

    Example using callback:
<B>        -- Lua function</B>
<B>        local myluafun = function() print("This buffer enters") end</B>

<B>        -- Vimscript function name (as a string)</B>
<B>        local myvimfun = "g:MyVimFunction"</B>

<B>        vim.api.nvim_create_autocmd({"BufEnter", "BufWinEnter"}, {</B>
<B>          pattern = {"*.c", "*.h"},</B>
<B>          callback = myluafun,  -- Or myvimfun</B>
<B>        })</B>
 

    <A HREF="lua.html#Lua">Lua</A> <A HREF="eval.html#functions">functions</A> receive a table with information about the <A HREF="autocmd.html#autocmd">autocmd</A> event <A HREF="motion.html#as">as</A>
    an argument. To use a function which itself accepts another (optional)
    parameter, wrap the function in a <A HREF="eval.html#lambda">lambda</A>:

<B>    -- Lua function with an optional parameter.</B>
<B>    -- The autocmd callback would pass a table as argument but this</B>
<B>    -- function expects number|nil</B>
<B>    local myluafun = function(bufnr) bufnr = bufnr or vim.api.nvim_get_current_buf() end</B>

<B>    vim.api.nvim_create_autocmd({"BufEnter", "BufWinEnter"}, {</B>
<B>      pattern = {"*.c", "*.h"},</B>
<B>      callback = function() myluafun() end,</B>
<B>    })</B>
 

    Example using command:
<B>        vim.api.nvim_create_autocmd({"BufEnter", "BufWinEnter"}, {</B>
<B>          pattern = {"*.c", "*.h"},</B>
<B>          command = "echo 'Entering a C or C++ file'",</B>
<B>        })</B>
 

    Example values for <A HREF="pattern.html#pattern">pattern</A>:
<B>      pattern = "*.py"</B>
<B>      pattern = { "*.py", "*.pyi" }</B>
 

    Example values for event:
<B>      "BufWritePre"</B>
<B>      {"CursorHold", "BufWritePre", "BufWritePost"}</B>
 

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        <A HREF="autocmd.html#{event}">{event}</A>  (string|array) The event or <A HREF="autocmd.html#events">events</A> to <A HREF="intro.html#register">register</A> this
                 <A HREF="autocmd.html#autocommand">autocommand</A>
        {opts}   <A HREF="eval.html#Dictionary">Dictionary</A> of <A HREF="autocmd.html#autocommand">autocommand</A> <A HREF="options.html#options">options</A>:
                 • group (string|integer) optional: the <A HREF="autocmd.html#autocommand">autocommand</A> group name
                   or id to match against.
                 • <A HREF="pattern.html#pattern">pattern</A> (string|array) optional: <A HREF="pattern.html#pattern">pattern</A> or patterns to
                   match against |<A HREF="autocmd.html#autocmd-pattern">autocmd-pattern</A>|.
                 • buffer (integer) optional: buffer number for buffer local
                   autocommands |<A HREF="autocmd.html#autocmd-buflocal">autocmd-buflocal</A>|. Cannot be used with
                   {pattern}.
                 • desc (string) optional: description of the <A HREF="autocmd.html#autocommand">autocommand</A>.
                 • callback (function|string) optional: if a <A HREF="eval.html#string">string</A>, the name
                   of a Vimscript function to call when this <A HREF="autocmd.html#autocommand">autocommand</A> is
                   triggered. Otherwise, a <A HREF="lua.html#Lua">Lua</A> function which is called when
                   this <A HREF="autocmd.html#autocommand">autocommand</A> is triggered. Cannot be used with
                   {command}. <A HREF="lua.html#Lua">Lua</A> callbacks can return true to delete the
                   <A HREF="autocmd.html#autocommand">autocommand</A>; in addition, they accept a single table
                   argument with the following keys:
                   • id: (number) the <A HREF="autocmd.html#autocommand">autocommand</A> id
                   • event: (string) the name of the event that triggered the
                     <A HREF="autocmd.html#autocommand">autocommand</A> |<A HREF="autocmd.html#autocmd-events">autocmd-events</A>|
                   • group: (number|nil) the <A HREF="autocmd.html#autocommand">autocommand</A> group id, if <A HREF="motion.html#it">it</A>
                     exists
                   • match: (string) the expanded value of |<A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A>|
                   • buf: (number) the expanded value of |<A HREF="cmdline.html#&lt;abuf&gt;">&lt;abuf&gt;</A>|
                   • file: (string) the expanded value of |<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>|
                   • data: (any) arbitrary data passed to
                     |<A HREF="#nvim_exec_autocmds()">nvim_exec_autocmds()</A>|

                 • command (string) optional: Vim command to execute on event.
                   Cannot be used with {callback}
                 • once (boolean) optional: defaults to false. Run the
                   <A HREF="autocmd.html#autocommand">autocommand</A> only once |<A HREF="autocmd.html#autocmd-once">autocmd-once</A>|.
                 • nested (boolean) optional: defaults to false. Run nested
                   autocommands |<A HREF="autocmd.html#autocmd-nested">autocmd-nested</A>|.

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        <A HREF="eval.html#Integer">Integer</A> id of the created <A HREF="autocmd.html#autocommand">autocommand</A>.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="autocmd.html#autocommand">autocommand</A>|
        |<A HREF="#nvim_del_autocmd()">nvim_del_autocmd()</A>|


nvim_del_augroup_by_id({id})                        *<A NAME="nvim_del_augroup_by_id()"></A><B>nvim_del_augroup_by_id()</B>*
    Delete an <A HREF="autocmd.html#autocommand">autocommand</A> group by id.

    To get a group id one can use |<A HREF="#nvim_get_autocmds()">nvim_get_autocmds()</A>|.

    NOTE: behavior differs from |<A HREF="autocmd.html#:augroup-delete">:augroup-delete</A>|. When <A HREF="change.html#deleting">deleting</A> a group,
    autocommands contained in this group will also be deleted and cleared.
    This group will no longer exist.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {id}  <A HREF="eval.html#Integer">Integer</A> The id of the group.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_del_augroup_by_name()">nvim_del_augroup_by_name()</A>|
        |<A HREF="#nvim_create_augroup()">nvim_create_augroup()</A>|


nvim_del_augroup_by_name({name})                  *<A NAME="nvim_del_augroup_by_name()"></A><B>nvim_del_augroup_by_name()</B>*
    Delete an <A HREF="autocmd.html#autocommand">autocommand</A> group by name.

    NOTE: behavior differs from |<A HREF="autocmd.html#:augroup-delete">:augroup-delete</A>|. When <A HREF="change.html#deleting">deleting</A> a group,
    autocommands contained in this group will also be deleted and cleared.
    This group will no longer exist.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {name}  <A HREF="eval.html#String">String</A> The name of the group.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|


nvim_del_autocmd({id})                                    *<A NAME="nvim_del_autocmd()"></A><B>nvim_del_autocmd()</B>*
    Delete an <A HREF="autocmd.html#autocommand">autocommand</A> by id.

    NOTE: Only autocommands created via the <A HREF="#API">API</A> have an id.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {id}  <A HREF="eval.html#Integer">Integer</A> The id returned by nvim_create_autocmd

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="#nvim_create_autocmd()">nvim_create_autocmd()</A>|


nvim_exec_autocmds({event}, {*opts})                    *<A NAME="nvim_exec_autocmds()"></A><B>nvim_exec_autocmds()</B>*
    Execute all autocommands for <A HREF="autocmd.html#{event}">{event}</A> that match the corresponding {opts}
    |<A HREF="autocmd.html#autocmd-execute">autocmd-execute</A>|.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        <A HREF="autocmd.html#{event}">{event}</A>  (String|Array) The event or <A HREF="autocmd.html#events">events</A> to execute
        {opts}   <A HREF="eval.html#Dictionary">Dictionary</A> of <A HREF="autocmd.html#autocommand">autocommand</A> <A HREF="options.html#options">options</A>:
                 • group (string|integer) optional: the <A HREF="autocmd.html#autocommand">autocommand</A> group name
                   or id to match against. |<A HREF="autocmd.html#autocmd-groups">autocmd-groups</A>|.
                 • <A HREF="pattern.html#pattern">pattern</A> (string|array) optional: defaults to &quot;*&quot;
                   |<A HREF="autocmd.html#autocmd-pattern">autocmd-pattern</A>|. Cannot be used with {buffer}.
                 • buffer (integer) optional: buffer number
                   |<A HREF="autocmd.html#autocmd-buflocal">autocmd-buflocal</A>|. Cannot be used with {pattern}.
                 • <A HREF="options.html#modeline">modeline</A> (bool) optional: defaults to true. Process the
                   modeline after the autocommands |<A HREF="autocmd.html#&lt;nomodeline&gt;">&lt;nomodeline&gt;</A>|.
                 • data (any): arbitrary data to send to the <A HREF="autocmd.html#autocommand">autocommand</A>
                   callback. See |<A HREF="#nvim_create_autocmd()">nvim_create_autocmd()</A>| for details.

<B><FONT COLOR="PURPLE">    See also: </FONT></B>
        |<A HREF="autocmd.html#:doautocmd">:doautocmd</A>|


nvim_get_autocmds({*opts})                               *<A NAME="nvim_get_autocmds()"></A><B>nvim_get_autocmds()</B>*
    Get all autocommands that match the corresponding {opts}.

    These examples will get autocommands matching ALL the given criteria:
<B>      -- Matches all criteria</B>
<B>      autocommands = vim.api.nvim_get_autocmds({</B>
<B>        group = "MyGroup",</B>
<B>        event = {"BufEnter", "BufWinEnter"},</B>
<B>        pattern = {"*.c", "*.h"}</B>
<B>      })</B>

<B>      -- All commands from one group</B>
<B>      autocommands = vim.api.nvim_get_autocmds({</B>
<B>        group = "MyGroup",</B>
<B>      })</B>
 

    NOTE: When multiple patterns or <A HREF="autocmd.html#events">events</A> are provided, <A HREF="motion.html#it">it</A> will find all the
    autocommands that match any combination of them.

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {opts}  <A HREF="eval.html#Dictionary">Dictionary</A> with at least one of the following:
                • group (string|integer): the <A HREF="autocmd.html#autocommand">autocommand</A> group name or id to
                  match against.
                • event (string|array): event or <A HREF="autocmd.html#events">events</A> to match against
                  |<A HREF="autocmd.html#autocmd-events">autocmd-events</A>|.
                • <A HREF="pattern.html#pattern">pattern</A> (string|array): <A HREF="pattern.html#pattern">pattern</A> or patterns to match against
                  |<A HREF="autocmd.html#autocmd-pattern">autocmd-pattern</A>|. Cannot be used with {buffer}
                • buffer: Buffer number or <A HREF="eval.html#list">list</A> of buffer numbers for buffer
                  local autocommands |<A HREF="autocmd.html#autocmd-buflocal">autocmd-buflocal</A>|. Cannot be used with
                  {pattern}

<B><FONT COLOR="PURPLE">    Return: </FONT></B>
        Array of autocommands matching the criteria, with each item containing
        the following fields:
        • id (number): the <A HREF="autocmd.html#autocommand">autocommand</A> id (only when defined with the <A HREF="#API">API</A>).
        • group (integer): the <A HREF="autocmd.html#autocommand">autocommand</A> group id.
        • group_name (string): the <A HREF="autocmd.html#autocommand">autocommand</A> group name.
        • desc (string): the <A HREF="autocmd.html#autocommand">autocommand</A> description.
        • event (string): the <A HREF="autocmd.html#autocommand">autocommand</A> event.
        • command (string): the <A HREF="autocmd.html#autocommand">autocommand</A> command. Note: this will be empty
          if a callback is set.
        • callback (function|<A HREF="eval.html#string">string</A>|nil): <A HREF="lua.html#Lua">Lua</A> function or name of a Vim <A HREF="usr_41.html#script">script</A>
          function which is executed when this <A HREF="autocmd.html#autocommand">autocommand</A> is triggered.
        • once (boolean): whether the <A HREF="autocmd.html#autocommand">autocommand</A> is only run once.
        • <A HREF="pattern.html#pattern">pattern</A> (string): the <A HREF="autocmd.html#autocommand">autocommand</A> <A HREF="pattern.html#pattern">pattern</A>. If the <A HREF="autocmd.html#autocommand">autocommand</A> is
          buffer local YXXYautocmd-buffer-local|:
        • buflocal (boolean): true if the <A HREF="autocmd.html#autocommand">autocommand</A> is buffer local.
        • buffer (number): the buffer number.


==============================================================================

<A HREF="ui.html#UI">UI</A> Functions                                                          *<A NAME="api-ui"></A><B>api-ui</B>*


nvim_ui_attach({width}, {height}, {options})                *<A NAME="nvim_ui_attach()"></A><B>nvim_ui_attach()</B>*
    Activates <A HREF="ui.html#UI">UI</A> <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>.

    Entry point of all <A HREF="ui.html#UI">UI</A> clients. Allows |<A HREF="starting.html#--embed">--embed</A>| to continue <A HREF="starting.html#startup">startup</A>.
    Implies that the client is ready to show the <A HREF="ui.html#UI">UI</A>. Adds the client to the
    list of UIs. |<A HREF="#nvim_list_uis()">nvim_list_uis()</A>|

    Note:
        If multiple <A HREF="ui.html#UI">UI</A> clients are attached, the global screen dimensions
        degrade to the smallest client. E.g. if client A requests 80x40 but
        client <A HREF="motion.html#B">B</A> requests 200x100, the global screen has size 80x40.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {width}    Requested screen columns
        {height}   Requested screen rows
        {options}  |<A HREF="ui.html#ui-option">ui-option</A>| map


<A HREF="#nvim_ui_detach()">nvim_ui_detach()</A>                                            *<A NAME="nvim_ui_detach()"></A><B>nvim_ui_detach()</B>*
    Deactivates <A HREF="ui.html#UI">UI</A> <A HREF="autocmd.html#events">events</A> on the <A HREF="channel.html#channel">channel</A>.

    Removes the client from the list of UIs. |<A HREF="#nvim_list_uis()">nvim_list_uis()</A>|

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only


                                                    *<A NAME="nvim_ui_pum_set_bounds()"></A><B>nvim_ui_pum_set_bounds()</B>*
nvim_ui_pum_set_bounds({width}, {height}, {row}, {col})
    Tells Nvim the geometry of the popupmenu, to align floating <A HREF="windows.html#windows">windows</A> with
    an external popup menu.

    Note that this <A HREF="eval.html#method">method</A> is not to be confused with
    |<A HREF="#nvim_ui_pum_set_height()">nvim_ui_pum_set_height()</A>|, which sets the number of visible items in the
    popup menu, while this function sets the bounding box of the popup menu,
    including visual elements such <A HREF="motion.html#as">as</A> borders and sliders. Floats need not use
    the same font size, nor be anchored to exact grid corners, so one can set
    floating-point numbers to the popup menu geometry.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {width}   Popupmenu width.
        {height}  Popupmenu height.
        {row}     Popupmenu row.
        {col}     Popupmenu height.


nvim_ui_pum_set_height({height})                    *<A NAME="nvim_ui_pum_set_height()"></A><B>nvim_ui_pum_set_height()</B>*
    Tells Nvim the number of elements displaying in the popupmenu, to decide
    <A HREF="scroll.html#&lt;PageUp&gt;">&lt;PageUp&gt;</A> and <A HREF="scroll.html#&lt;PageDown&gt;">&lt;PageDown&gt;</A> <A HREF="intro.html#movement">movement</A>.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {height}  Popupmenu height, must be greater than zero.


nvim_ui_set_option({name}, {value})                     *<A NAME="nvim_ui_set_option()"></A><B>nvim_ui_set_option()</B>*
    TODO: Documentation

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only


nvim_ui_try_resize({width}, {height})                   *<A NAME="nvim_ui_try_resize()"></A><B>nvim_ui_try_resize()</B>*
    TODO: Documentation

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only


                                                   *<A NAME="nvim_ui_try_resize_grid()"></A><B>nvim_ui_try_resize_grid()</B>*
nvim_ui_try_resize_grid({grid}, {width}, {height})
    Tell Nvim to resize a grid. Triggers a grid_resize event with the
    requested grid size or the maximum size if <A HREF="motion.html#it">it</A> exceeds size <A HREF="vi_diff.html#limits">limits</A>.

    On invalid grid handle, fails with error.

<B><FONT COLOR="PURPLE">    Attributes: </FONT></B>
        |<A HREF="#RPC">RPC</A>| only

<B><FONT COLOR="PURPLE">    Parameters: </FONT></B>
        {grid}    The handle of the grid to be changed.
        {width}   The new requested width.
        {height}  The new requested height.

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
