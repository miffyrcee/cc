
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>About fixtures — pytest documentation</title>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/basic.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments_pytest.css" rel="stylesheet" type="text/css"/>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
<script src="../_static/jquery.js"></script>
<script src="../_static/underscore.js"></script>
<script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
<script src="../_static/doctools.js"></script>
<script src="../_static/sphinx_highlight.js"></script>
<link href="../_static/favicon.png" rel="shortcut icon"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="goodpractices.html" rel="next" title="Good Integration Practices"/>
<link href="anatomy.html" rel="prev" title="Anatomy of a test"/>
<script>DOCUMENTATION_OPTIONS.URL_ROOT = '';</script>
</head><body>
<div aria-label="related navigation" class="related" role="navigation">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a href="../py-modindex.html" title="Python Module Index">modules</a></li>
<li class="right">
<a accesskey="N" href="goodpractices.html" title="Good Integration Practices">next</a> |</li>
<li class="right">
<a accesskey="P" href="anatomy.html" title="Anatomy of a test">previous</a> |</li>
<li class="nav-item nav-item-0"><a href="../contents.html">pytest-7.3</a> »</li>
<li class="nav-item nav-item-this"><a href="">About fixtures</a></li>
</ul>
</div>
<div class="document">
<div class="documentwrapper">
<div class="body" role="main">
<a class="dashAnchor" name="//apple_ref/cpp/Section/About fixtures"></a><section id="about-fixtures">
<span id="id1"></span><h1>About fixtures<a class="headerlink" href="#about-fixtures" title="Permalink to this heading">¶</a></h1>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../how-to/fixtures.html#how-to-fixtures"><span class="std std-ref">How to use fixtures</span></a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../reference/fixtures.html#reference-fixtures"><span class="std std-ref">Fixtures reference</span></a></p>
</div>
<p>pytest fixtures are designed to be explicit, modular and scalable.</p>
<section id="what-fixtures-are">
<h2>What fixtures are<a class="headerlink" href="#what-fixtures-are" title="Permalink to this heading">¶</a></h2>
<p>In testing, a <a class="reference external" href="https://en.wikipedia.org/wiki/Test_fixture#Software">fixture</a>
provides a defined, reliable and consistent context for the tests. This could
include environment (for example a database configured with known parameters)
or content (such as a dataset).</p>
<p>Fixtures define the steps and data that constitute the <em>arrange</em> phase of a
test (see <a class="reference internal" href="anatomy.html#test-anatomy"><span class="std std-ref">Anatomy of a test</span></a>). In pytest, they are functions you define that
serve this purpose. They can also be used to define a test’s <em>act</em> phase; this
is a powerful technique for designing more complex tests.</p>
<p>The services, state, or other operating environments set up by fixtures are
accessed by test functions through arguments. For each fixture used by a test
function there is typically a parameter (named after the fixture) in the test
function’s definition.</p>
<p>We can tell pytest that a particular function is a fixture by decorating it with
<a class="reference internal" href="../reference/reference.html#pytest.fixture" title="pytest.fixture"><code class="xref py py-func docutils literal notranslate"><span class="pre">@pytest.fixture</span></code></a>. Here’s a simple example of
what a fixture in pytest might look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="k">class</span> <span class="nc">Fruit</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">my_fruit</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Fruit</span><span class="p">(</span><span class="s2">"apple"</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">fruit_basket</span><span class="p">(</span><span class="n">my_fruit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Fruit</span><span class="p">(</span><span class="s2">"banana"</span><span class="p">),</span> <span class="n">my_fruit</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_my_fruit_in_basket</span><span class="p">(</span><span class="n">my_fruit</span><span class="p">,</span> <span class="n">fruit_basket</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">my_fruit</span> <span class="ow">in</span> <span class="n">fruit_basket</span>
</pre></div>
</div>
<p>Tests don’t have to be limited to a single fixture, either. They can depend on
as many fixtures as you want, and fixtures can use other fixtures, as well. This
is where pytest’s fixture system really shines.</p>
</section>
<section id="improvements-over-xunit-style-setup-teardown-functions">
<h2>Improvements over xUnit-style setup/teardown functions<a class="headerlink" href="#improvements-over-xunit-style-setup-teardown-functions" title="Permalink to this heading">¶</a></h2>
<p>pytest fixtures offer dramatic improvements over the classic xUnit
style of setup/teardown functions:</p>
<ul class="simple">
<li><p>fixtures have explicit names and are activated by declaring their use
from test functions, modules, classes or whole projects.</p></li>
<li><p>fixtures are implemented in a modular manner, as each fixture name
triggers a <em>fixture function</em> which can itself use other fixtures.</p></li>
<li><p>fixture management scales from simple unit to complex
functional testing, allowing to parametrize fixtures and tests according
to configuration and component options, or to re-use fixtures
across function, class, module or whole test session scopes.</p></li>
<li><p>teardown logic can be easily, and safely managed, no matter how many fixtures
are used, without the need to carefully handle errors by hand or micromanage
the order that cleanup steps are added.</p></li>
</ul>
<p>In addition, pytest continues to support <a class="reference internal" href="../how-to/xunit_setup.html#xunitsetup"><span class="std std-ref">How to implement xunit-style set-up</span></a>.  You can mix
both styles, moving incrementally from classic to new style, as you
prefer.  You can also start out from existing <a class="reference internal" href="../how-to/unittest.html#unittest-testcase"><span class="std std-ref">unittest.TestCase
style</span></a> or <a class="reference internal" href="../how-to/nose.html#nosestyle"><span class="std std-ref">nose based</span></a> projects.</p>
</section>
<section id="fixture-errors">
<h2>Fixture errors<a class="headerlink" href="#fixture-errors" title="Permalink to this heading">¶</a></h2>
<p>pytest does its best to put all the fixtures for a given test in a linear order
so that it can see which fixture happens first, second, third, and so on. If an
earlier fixture has a problem, though, and raises an exception, pytest will stop
executing fixtures for that test and mark the test as having an error.</p>
<p>When a test is marked as having an error, it doesn’t mean the test failed,
though. It just means the test couldn’t even be attempted because one of the
things it depends on had a problem.</p>
<p>This is one reason why it’s a good idea to cut out as many unnecessary
dependencies as possible for a given test. That way a problem in something
unrelated isn’t causing us to have an incomplete picture of what may or may not
have issues.</p>
<p>Here’s a quick example to help explain:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">append_first</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">append_second</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">append_first</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">append_third</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">append_second</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>If, for whatever reason, <code class="docutils literal notranslate"><span class="pre">order.append(1)</span></code> had a bug and it raises an exception,
we wouldn’t be able to know if <code class="docutils literal notranslate"><span class="pre">order.extend([2])</span></code> or <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+=</span> <span class="pre">[3]</span></code> would
also have problems. After <code class="docutils literal notranslate"><span class="pre">append_first</span></code> throws an exception, pytest won’t run
any more fixtures for <code class="docutils literal notranslate"><span class="pre">test_order</span></code>, and it won’t even try to run
<code class="docutils literal notranslate"><span class="pre">test_order</span></code> itself. The only things that would’ve run would be <code class="docutils literal notranslate"><span class="pre">order</span></code> and
<code class="docutils literal notranslate"><span class="pre">append_first</span></code>.</p>
</section>
<section id="sharing-test-data">
<h2>Sharing test data<a class="headerlink" href="#sharing-test-data" title="Permalink to this heading">¶</a></h2>
<p>If you want to make test data from files available to your tests, a good way
to do this is by loading these data in a fixture for use by your tests.
This makes use of the automatic caching mechanisms of pytest.</p>
<p>Another good approach is by adding the data files in the <code class="docutils literal notranslate"><span class="pre">tests</span></code> folder.
There are also community plugins available to help to manage this aspect of
testing, e.g. <a class="reference external" href="https://pypi.org/project/pytest-datadir/">pytest-datadir</a> and <a class="reference external" href="https://pypi.org/project/pytest-datafiles/">pytest-datafiles</a>.</p>
</section>
<section id="a-note-about-fixture-cleanup">
<a class="dashAnchor" name="//apple_ref/cpp/Section/A note about fixture cleanup"></a><span id="fixtures-signal-cleanup"></span><h2>A note about fixture cleanup<a class="headerlink" href="#a-note-about-fixture-cleanup" title="Permalink to this heading">¶</a></h2>
<p>pytest does not do any special processing for <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.SIGTERM" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIGTERM</span></code></a> and
<code class="xref py py-data docutils literal notranslate"><span class="pre">SIGQUIT</span></code> signals (<a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.SIGINT" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">SIGINT</span></code></a> is handled naturally
by the Python runtime via <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>), so fixtures that manage external resources which are important
to be cleared when the Python process is terminated (by those signals) might leak resources.</p>
<p>The reason pytest does not handle those signals to perform fixture cleanup is that signal handlers are global,
and changing them might interfere with the code under execution.</p>
<p>If fixtures in your suite need special care regarding termination in those scenarios,
see <a class="reference external" href="https://github.com/pytest-dev/pytest/issues/5243#issuecomment-491522595">this comment</a> in the issue
tracker for a possible workaround.</p>
</section>
</section>
<div class="clearer"></div>
</div>
</div>
<span id="sidebar-top"></span>
<div class="clearer"></div>
</div>
<div class="footer" role="contentinfo">
        © Copyright 2015, holger krekel and pytest-dev team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
<script src="../_static/version_warning_offset.js"></script>
</body>
</html>