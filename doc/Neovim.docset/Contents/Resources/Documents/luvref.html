<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Nvim documentation: luvref</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Nvim documentation: luvref</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="luvref.txt"></A><B>luvref.txt</B>*               Nvim


                    LUV REFERENCE MANUAL


This file documents the <A HREF="lua.html#Lua">Lua</A> bindings for the LibUV library which is used for
Nvim's event-loop and is accessible from <A HREF="lua.html#Lua">Lua</A> via |<A HREF="vim.html">vim.loop</A>| (e.g., |<A HREF="uv.html">uv.version()</A>|
is exposed <A HREF="motion.html#as">as</A> `vim.loop.version()`).

For information about this manual, see |<A HREF="#luv-credits">luv-credits</A>|.

For further examples, see https://github.com/luvit/luv/tree/master/examples.

==============================================================================

INTRODUCTION                                                  *<A NAME="luv"></A><B>luv</B>* *<A NAME="luv-intro"></A><B>luv-intro</B>* *<A NAME="uv"></A><B>uv</B>*

The <A HREF="#luv">luv</A> (https://github.com/luvit/luv) project provides access to the
multi-platform support library libuv (https://github.com/libuv/libuv) in <A HREF="lua.html#Lua">Lua</A>
code. It was primarily developed for the luvit
(https://github.com/luvit/luvit) project <A HREF="motion.html#as">as</A> the built-in `uv` module, but can
be used in other <A HREF="lua.html#Lua">Lua</A> environments.

More information about the core libuv library can be found at the original
libuv documentation page (https://docs.libuv.org/).

<B><FONT COLOR="PURPLE">TCP Echo Server Example</FONT></B>

Here is a small example showing a TCP echo server:

   
<B>    local uv = vim.loop</B>

<B>    local server = uv.new_tcp()</B>
<B>    server:bind("127.0.0.1", 1337)</B>
<B>    server:listen(128, function (err)</B>
<B>      assert(not err, err)</B>
<B>      local client = uv.new_tcp()</B>
<B>      server:accept(client)</B>
<B>      client:read_start(function (err, chunk)</B>
<B>        assert(not err, err)</B>
<B>        if chunk then</B>
<B>          client:write(chunk)</B>
<B>        else</B>
<B>          client:shutdown()</B>
<B>          client:close()</B>
<B>        end</B>
<B>      end)</B>
<B>    end)</B>
<B>    print("TCP server listening at 127.0.0.1 port 1337")</B>
<B>    uv.run() -- an explicit run call is necessary outside of luvit</B>
 

<B><FONT COLOR="PURPLE">Module Layout</FONT></B>

The <A HREF="#luv">luv</A> library contains a single <A HREF="lua.html#Lua">Lua</A> module referred to hereafter <A HREF="motion.html#as">as</A> `uv` for
simplicity. This module consists mostly of <A HREF="eval.html#functions">functions</A> with names corresponding
to their original libuv versions. For example, the libuv function
`uv_tcp_bind` has a <A HREF="#luv">luv</A> version at |<A HREF="uv.html">uv.tcp_bind()</A>|. Currently, only one
non-function field exists: `uv.constants`, which is a table.

<B><FONT COLOR="PURPLE">Functions vs Methods</FONT></B>

In addition to having simple <A HREF="eval.html#functions">functions</A>, <A HREF="#luv">luv</A> provides an optional method-style
<A HREF="api.html#API">API</A>. For example, `uv.tcp_bind(server, host, port)` can alternatively be
called <A HREF="motion.html#as">as</A> `server:bind(host, port)` . Note that the first argument `server`
becomes the object and `tcp_` is removed from the function name. Method forms
are documented below where they exist.

<B><FONT COLOR="PURPLE">Synchronous vs Asynchronous Functions</FONT></B>

Functions that accept a callback are asynchronous. These <A HREF="eval.html#functions">functions</A> may
immediately return results to the caller to indicate their initial status, but
their final execution is deferred until at least the next libuv loop
iteration. After completion, their callbacks are executed with any results
passed to <A HREF="motion.html#it">it</A>.

Functions that <A HREF="diff.html#do">do</A> not accept a callback are synchronous. These <A HREF="eval.html#functions">functions</A>
immediately return their results to the caller.

Some (generally FS and DNS) <A HREF="eval.html#functions">functions</A> can behave either synchronously or
asynchronously. If a callback is provided to these <A HREF="eval.html#functions">functions</A>, they behave
asynchronously; if no callback is provided, they behave synchronously.

<B><FONT COLOR="PURPLE">Pseudo-Types</FONT></B>

Some unique types are defined. These are not actual types in <A HREF="lua.html#Lua">Lua</A>, but they are
used here to facilitate documenting consistent behavior:
- `fail`: an assertable `nil, <A HREF="eval.html#string">string</A>, string` tuple (see |<A HREF="#luv-error-handling">luv-error-handling</A>|)
- `callable`: a `function`; or a `table` or `userdata` with a `__call`
  metamethod
- `buffer`: a `string` or a sequential `table` of `string`s
- `threadargs`: variable arguments (`...`) of type `nil`, `boolean`, `number`,
  `string`, or `userdata`

==============================================================================

CONTENTS                                                          *<A NAME="luv-contents"></A><B>luv-contents</B>*

This documentation is mostly a retelling of the libuv <A HREF="api.html#API">API</A> documentation
	<A HREF="http://docs.libuv.org/en/v1.x/api.html">http://docs.libuv.org/en/v1.x/api.html</A> within the context of luv's Lua API.
Low-level implementation details and unexposed C <A HREF="eval.html#functions">functions</A> and types are not
documented here except for when they are relevant to behavior seen in the <A HREF="lua.html#Lua">Lua</A>
module.

- |<A HREF="#luv-error-handling">luv-error-handling</A>| — Error handling
- |<A HREF="#luv-version-checking">luv-version-checking</A>| — Version checking
- |<A HREF="#uv_loop_t">uv_loop_t</A>| — Event loop
- |<A HREF="#uv_req_t">uv_req_t</A>| — Base request
- |<A HREF="#uv_handle_t">uv_handle_t</A>| — Base handle
  - |<A HREF="#uv_timer_t">uv_timer_t</A>| — Timer handle
  - |<A HREF="#uv_prepare_t">uv_prepare_t</A>| — Prepare handle
  - |<A HREF="#uv_check_t">uv_check_t</A>| — Check handle
  - |<A HREF="#uv_idle_t">uv_idle_t</A>| — Idle handle
  - |<A HREF="#uv_async_t">uv_async_t</A>| — Async handle
  - |<A HREF="#uv_poll_t">uv_poll_t</A>| — Poll handle
  - |<A HREF="#uv_signal_t">uv_signal_t</A>| — <A HREF="autocmd.html#Signal">Signal</A> handle
  - |<A HREF="#uv_process_t">uv_process_t</A>| — Process handle
  - |<A HREF="#uv_stream_t">uv_stream_t</A>| — Stream handle
    - |<A HREF="#uv_tcp_t">uv_tcp_t</A>| — TCP handle
    - |<A HREF="#uv_pipe_t">uv_pipe_t</A>| — Pipe handle
    - |<A HREF="#uv_tty_t">uv_tty_t</A>| — TTY handle
  - |<A HREF="#uv_udp_t">uv_udp_t</A>| — UDP handle
  - |<A HREF="#uv_fs_event_t">uv_fs_event_t</A>| — FS Event handle
  - |<A HREF="#uv_fs_poll_t">uv_fs_poll_t</A>| — FS Poll handle
- |<A HREF="#luv-file-system-operations">luv-file-system-operations</A>| — File system operations
- |<A HREF="#luv-thread-pool-work-scheduling">luv-thread-pool-work-scheduling</A>| — Thread pool work scheduling
- |<A HREF="#luv-dns-utility-functions">luv-dns-utility-functions</A>| — DNS utility functions
- |<A HREF="#luv-threading-and-synchronization-utilities">luv-threading-and-synchronization-utilities</A>| — Threading and
  synchronization utilities
- |<A HREF="#luv-miscellaneous-utilities">luv-miscellaneous-utilities</A>| — Miscellaneous utilities
- |<A HREF="#luv-metrics-operations">luv-metrics-operations</A>| — Metrics operations

==============================================================================

ERROR HANDLING                                              *<A NAME="luv-error-handling"></A><B>luv-error-handling</B>*

In libuv, <A HREF="message.html#errors">errors</A> are negative numbered constants; however, these <A HREF="message.html#errors">errors</A> and
the <A HREF="eval.html#functions">functions</A> used to handle them are not exposed to <A HREF="#luv">luv</A> users. Instead, if an
internal error is encountered, the <A HREF="#luv">luv</A> function will return to the caller an
assertable `nil, err, name` tuple.

- `nil` idiomatically indicates failure
- `err` is a <A HREF="eval.html#string">string</A> with the format `{name}: {message}`
  - `{name}` is the error name provided internally by `uv_err_name`
  - `{message}` is a human-readable message provided internally by
    `uv_strerror`
- `name` is the same <A HREF="eval.html#string">string</A> used to construct `err`

This tuple is referred to below <A HREF="motion.html#as">as</A> the `fail` pseudo-type.

When a function is called successfully, <A HREF="motion.html#it">it</A> will return either a value that is
relevant to the operation of the function, or the integer `0` to indicate
success, or sometimes nothing at all. These cases are documented below.

==============================================================================

VERSION CHECKING                                          *<A NAME="luv-version-checking"></A><B>luv-version-checking</B>*


<A HREF="#uv.version()">uv.version()</A>                                                      *<A NAME="uv.version()"></A><B>uv.version()</B>*

                Returns the libuv version packed into a single integer. 8 bits
                are used for each component, with the patch number stored in
                the 8 least significant bits. For example, this would be
                0x010203 in libuv 1.2.3.

                Returns: `integer`


<A HREF="#uv.version_string()">uv.version_string()</A>                                        *<A NAME="uv.version_string()"></A><B>uv.version_string()</B>*

                Returns the libuv version number <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>. For example,
                this would be &quot;1.2.3&quot; in libuv 1.2.3. For non-release
                versions, the version suffix is included.

                Returns: `string`

==============================================================================

`uv_loop_t` — Event loop                                *<A NAME="luv-event-loop"></A><B>luv-event-loop</B>* *<A NAME="uv_loop_t"></A><B>uv_loop_t</B>*

The event loop is the central part of libuv's functionality. It takes care of
polling for I/O and scheduling callbacks to be run based on different sources
of <A HREF="autocmd.html#events">events</A>.

In <A HREF="#luv">luv</A>, there is an implicit <A HREF="#uv">uv</A> loop for every <A HREF="lua.html#Lua">Lua</A> state that loads the
library. You can use this library in an multi-threaded environment <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A>
each thread has it's own <A HREF="lua.html#Lua">Lua</A> state with its corresponding own <A HREF="#uv">uv</A> loop. This
loop is not directly exposed to users in the <A HREF="lua.html#Lua">Lua</A> module.


<A HREF="#uv.loop_close()">uv.loop_close()</A>                                                *<A NAME="uv.loop_close()"></A><B>uv.loop_close()</B>*

                Closes all internal loop resources. In normal execution, the
                loop will automatically be closed when <A HREF="motion.html#it">it</A> is garbage collected
                by <A HREF="lua.html#Lua">Lua</A>, so <A HREF="motion.html#it">it</A> is not necessary to explicitly call
                `loop_close()`. Call this function only after the loop has
                finished executing and all open handles and requests have been
                closed, or <A HREF="motion.html#it">it</A> will return `EBUSY`.

                Returns: `0` or `fail`


uv.run([{mode}])                                                      *<A NAME="uv.run()"></A><B>uv.run()</B>*

                Parameters:
                - `mode`: `string` or `nil` (default: `&quot;default&quot;`)

                This function runs the event loop. It will act differently
                depending on the specified mode:

                  - `&quot;default&quot;`: Runs the event loop until there are no more
                    active and referenced handles or requests. Returns `true`
                    if |<A HREF="uv.html">uv.stop()</A>| was called and there are still active
                    handles or requests. Returns `false` in all other cases.

                  - `&quot;once&quot;`: Poll for I/O once. Note that this function
                    blocks if there are no pending callbacks. Returns `false`
                    when done (no active handles or requests left), or `true`
                    if more callbacks are expected (meaning you should run the
                    event loop again sometime in the future).

                  - `&quot;nowait&quot;`: Poll for I/O once but don't block if there are
                    no pending callbacks. Returns `false` if done (no active
                    handles or requests left), or `true` if more callbacks are
                    expected (meaning you should run the event loop again
                    sometime in the future).

                Returns: `boolean` or `fail`

                Note: Luvit will implicitly call `uv.run()` after loading user
                code, but if you use the <A HREF="#luv">luv</A> bindings directly, you need to
                call this after registering your initial set of event
                callbacks to start the event loop.


uv.loop_configure({option}, {...})                         *<A NAME="uv.loop_configure()"></A><B>uv.loop_configure()</B>*

                Parameters:
                - `option`: `string`
                - `...`: depends on `option`, see below

                Set additional loop <A HREF="options.html#options">options</A>. You should normally call this
                before the first call to uv_run() unless mentioned otherwise.

                Supported <A HREF="options.html#options">options</A>:

                  - `&quot;block_signal&quot;`: Block a signal when polling for new
                    <A HREF="autocmd.html#events">events</A>. The second argument to loop_configure() is the
                    signal name (as a <A HREF="change.html#lowercase">lowercase</A> <A HREF="eval.html#string">string</A>) or the signal number.
                    This operation is currently only implemented for
                    `&quot;sigprof&quot;` signals, to suppress unnecessary wakeups when
                    using a sampling profiler. Requesting other signals will
                    fail with `EINVAL`.
                  - `&quot;metrics_idle_time&quot;`: Accumulate the amount of idle time
                    the event loop spends in the event <A HREF="provider.html#provider">provider</A>. This option
                    is necessary to use `metrics_idle_time()`.

                An example of a valid call to this function is:

                   
<B>                    uv.loop_configure("block_signal", "sigprof")</B>
 

                Returns: `0` or `fail`

                Note: Be prepared to handle the `ENOSYS` error; <A HREF="motion.html#it">it</A> means the
                loop option is not supported by the platform.


<A HREF="#uv.loop_mode()">uv.loop_mode()</A>                                                  *<A NAME="uv.loop_mode()"></A><B>uv.loop_mode()</B>*

                If the loop is running, returns a <A HREF="eval.html#string">string</A> indicating the mode
                in use. If the loop is not running, `nil` is returned instead.

                Returns: `string` or `nil`


<A HREF="#uv.loop_alive()">uv.loop_alive()</A>                                                *<A NAME="uv.loop_alive()"></A><B>uv.loop_alive()</B>*

                Returns `true` if there are referenced active handles, active
                requests, or closing handles in the loop; otherwise, `false`.

                Returns: `boolean` or `fail`


<A HREF="#uv.stop()">uv.stop()</A>                                                            *<A NAME="uv.stop()"></A><B>uv.stop()</B>*

                Stop the event loop, causing |<A HREF="uv.html">uv.run()</A>| to end <A HREF="motion.html#as">as</A> soon <A HREF="motion.html#as">as</A>
                possible. This will happen not sooner than the next loop
                iteration. If this function was called before blocking for
                I/O, the loop won't block for I/O on this iteration.

                Returns: Nothing.


<A HREF="#uv.backend_fd()">uv.backend_fd()</A>                                                *<A NAME="uv.backend_fd()"></A><B>uv.backend_fd()</B>*

                Get backend file descriptor. Only kqueue, epoll, and event
                ports are supported.

                This can be used in conjunction with `uv.run(&quot;nowait&quot;)` to
                poll in one thread and run the event loop's callbacks in
                another

                Returns: `integer` or `nil`

                Note: Embedding a kqueue fd in another kqueue pollset doesn't
                work on all platforms. It's not an error to add the fd but <A HREF="motion.html#it">it</A>
                never generates <A HREF="autocmd.html#events">events</A>.


<A HREF="#uv.backend_timeout()">uv.backend_timeout()</A>                                      *<A NAME="uv.backend_timeout()"></A><B>uv.backend_timeout()</B>*

                Get the poll timeout. The return value is in milliseconds, or
                -1 for no timeout.

                Returns: `integer`


<A HREF="#uv.now()">uv.now()</A>                                                              *<A NAME="uv.now()"></A><B>uv.now()</B>*

                Returns the current <A HREF="editing.html#timestamp">timestamp</A> in milliseconds. The <A HREF="editing.html#timestamp">timestamp</A>
                is cached at the start of the event loop tick, see
                |<A HREF="uv.html">uv.update_time()</A>| for details and rationale.

                The <A HREF="editing.html#timestamp">timestamp</A> increases monotonically from some arbitrary
                point in time. Don't make assumptions about the starting
                point, you will only get disappointed.

                Returns: `integer`

                Note: Use |<A HREF="uv.html">uv.hrtime()</A>| if you need sub-millisecond
                granularity.


<A HREF="#uv.update_time()">uv.update_time()</A>                                              *<A NAME="uv.update_time()"></A><B>uv.update_time()</B>*

                Update the event loop's concept of &quot;now&quot;. Libuv caches the
                current time at the start of the event loop tick in order to
                reduce the number of time-related system calls.

                You won't normally need to call this function unless you have
                callbacks that block the event loop for longer periods of
                time, where &quot;longer&quot; is somewhat subjective but probably on
                the order of a millisecond or more.

                Returns: Nothing.


uv.walk({callback})                                                  *<A NAME="uv.walk()"></A><B>uv.walk()</B>*

                Parameters:
                - `callback`: `callable`
                  - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Walk the <A HREF="eval.html#list">list</A> of handles: `callback` will be executed with
                each handle.

                Returns: Nothing.

                   
<B>                    -- Example usage of uv.walk to close all handles that</B>
<B>                    -- aren't already closing.</B>
<B>                    uv.walk(function (handle)</B>
<B>                      if not handle:is_closing() then</B>
<B>                        handle:close()</B>
<B>                      end</B>
<B>                    end)</B>
 

==============================================================================

`uv_req_t` — Base request                              *<A NAME="luv-base-request"></A><B>luv-base-request</B>* *<A NAME="uv_req_t"></A><B>uv_req_t</B>*

`uv_req_t` is the base type for all libuv request types.


uv.cancel({req})                                                   *<A NAME="uv.cancel()"></A><B>uv.cancel()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `req:cancel()`

                Parameters:
                - `req`: `userdata` for sub-type of |<A HREF="#uv_req_t">uv_req_t</A>|

                Cancel a pending request. Fails if the request is executing or
                has finished executing. Only cancellation of |<A HREF="#uv_fs_t">uv_fs_t</A>|,
                `uv_getaddrinfo_t`, `uv_getnameinfo_t` and `uv_work_t`
                requests is currently supported.

                Returns: `0` or `fail`


uv.req_get_type({req})                                       *<A NAME="uv.req_get_type()"></A><B>uv.req_get_type()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `req:get_type()`

                Parameters:
                - `req`: `userdata` for sub-type of |<A HREF="#uv_req_t">uv_req_t</A>|

                Returns the name of the struct for a given request (e.g.
                `&quot;fs&quot;` for |<A HREF="#uv_fs_t">uv_fs_t</A>|) and the libuv enum integer for the
                request's type (`uv_req_type`).

                Returns: `string, integer`

==============================================================================

`uv_handle_t` — Base handle                          *<A NAME="luv-base-handle"></A><B>luv-base-handle</B>* *<A NAME="uv_handle_t"></A><B>uv_handle_t</B>*

`uv_handle_t` is the base type for all libuv handle types. All <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A>
defined here work with any handle type.


uv.is_active({handle})                                          *<A NAME="uv.is_active()"></A><B>uv.is_active()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:is_active()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Returns `true` if the handle is active, `false` if it's
                inactive. What &quot;active” means depends on the type of handle:

                  - A |<A HREF="#uv_async_t">uv_async_t</A>| handle is always active and cannot be
                    deactivated, except by closing <A HREF="motion.html#it">it</A> with |<A HREF="uv.html">uv.close()</A>|.

                  - A |<A HREF="#uv_pipe_t">uv_pipe_t</A>|, |<A HREF="#uv_tcp_t">uv_tcp_t</A>|, |<A HREF="#uv_udp_t">uv_udp_t</A>|, etc.
                    handle - basically any handle that deals with I/O - is
                    active when <A HREF="motion.html#it">it</A> is doing something that involves I/O, like
                    reading, <A HREF="editing.html#writing">writing</A>, connecting, accepting new connections,
                    etc.

                  - A |<A HREF="#uv_check_t">uv_check_t</A>|, |<A HREF="#uv_idle_t">uv_idle_t</A>|, |<A HREF="#uv_timer_t">uv_timer_t</A>|,
                    etc. handle is active when <A HREF="motion.html#it">it</A> has been started with a call
                    to |<A HREF="uv.html">uv.check_start()</A>|, |<A HREF="uv.html">uv.idle_start()</A>|,
                    |<A HREF="uv.html">uv.timer_start()</A>| etc. until <A HREF="motion.html#it">it</A> has been stopped with a
                    call to its respective stop function.

                Returns: `boolean` or `fail`


uv.is_closing({handle})                                        *<A NAME="uv.is_closing()"></A><B>uv.is_closing()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:is_closing()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Returns `true` if the handle is closing or closed, `false`
                otherwise.

                Returns: `boolean` or `fail`

                Note: This function should only be used between the
                <A HREF="starting.html#initialization">initialization</A> of the handle and the arrival of the close
                callback.


uv.close({handle} [, {callback}])                                   *<A NAME="uv.close()"></A><B>uv.close()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:close([callback])`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|
                - `callback`: `callable` or `nil`

                Request handle to be closed. `callback` will be called
                asynchronously after this call. This MUST be called on each
                handle before memory is released.

                Handles that wrap file descriptors are closed immediately but
                `callback` will still be deferred to the next iteration of the
                event loop. It gives you a chance to free up any resources
                associated with the handle.

                In-progress requests, like `uv_connect_t` or `uv_write_t`, are
                cancelled and have their callbacks called asynchronously with
                `ECANCELED`.

                Returns: Nothing.


uv.ref({handle})                                                      *<A NAME="uv.ref()"></A><B>uv.ref()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:ref()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Reference the given handle. References are idempotent, that
                is, if a handle is already referenced calling this function
                again will have no effect.

                Returns: Nothing.

                See |<A HREF="#luv-reference-counting">luv-reference-counting</A>|.


uv.unref({handle})                                                  *<A NAME="uv.unref()"></A><B>uv.unref()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:unref()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Un-reference the given handle. References are idempotent, that
                is, if a handle is not referenced calling this function again
                will have no effect.

                Returns: Nothing.

See |<A HREF="#luv-reference-counting">luv-reference-counting</A>|.


uv.has_ref({handle})                                              *<A NAME="uv.has_ref()"></A><B>uv.has_ref()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:has_ref()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Returns `true` if the handle referenced, `false` if not.

                Returns: `boolean` or `fail`

                See |<A HREF="#luv-reference-counting">luv-reference-counting</A>|.


uv.send_buffer_size({handle} [, {size}])                 *<A NAME="uv.send_buffer_size()"></A><B>uv.send_buffer_size()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:send_buffer_size([size])`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|
                - `size`: `integer` or `nil` (default: `0`)

                Gets or sets the size of the send buffer that the operating
                system uses for the socket.

                If `size` is omitted (or `0`), this will return the current
                send buffer size; otherwise, this will use `size` to set the
                new send buffer size.

                This function works for TCP, pipe and UDP handles on Unix and
                for TCP and UDP handles on Windows.

                Returns:
                - `integer` or `fail` (if `size` is `nil` or `0`)
                - `0` or `fail` (if `size` is not `nil` and not `0`)

                Note: Linux will set double the size and return double the
                size of the original set value.


uv.recv_buffer_size({handle} [, {size}])                 *<A NAME="uv.recv_buffer_size()"></A><B>uv.recv_buffer_size()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:recv_buffer_size([size])`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|
                - `size`: `integer` or `nil` (default: `0`)

                Gets or sets the size of the receive buffer that the operating
                system uses for the socket.

                If `size` is omitted (or `0`), this will return the current
                send buffer size; otherwise, this will use `size` to set the
                new send buffer size.

                This function works for TCP, pipe and UDP handles on Unix and
                for TCP and UDP handles on Windows.

                Returns:
                - `integer` or `fail` (if `size` is `nil` or `0`)
                - `0` or `fail` (if `size` is not `nil` and not `0`)

                Note: Linux will set double the size and return double the
                size of the original set value.


uv.fileno({handle})                                                *<A NAME="uv.fileno()"></A><B>uv.fileno()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:fileno()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Gets the platform dependent file descriptor equivalent.

                The following handles are supported: TCP, pipes, TTY, UDP and
                poll. Passing any other handle type will fail with `EINVAL`.

                If a handle doesn't have an attached file descriptor yet or
                the handle itself has been closed, this function will return
                `EBADF`.

                Returns: `integer` or `fail`

                WARNING: Be very careful when using this function. libuv
                assumes it's in <A HREF="intro.html#control">control</A> of the file descriptor so any change
                to <A HREF="motion.html#it">it</A> may lead to malfunction.


uv.handle_get_type({handle})                              *<A NAME="uv.handle_get_type()"></A><B>uv.handle_get_type()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `handle:get_type()`

                Parameters:
                - `handle`: `userdata` for sub-type of |<A HREF="#uv_handle_t">uv_handle_t</A>|

                Returns the name of the struct for a given handle (e.g.
                `&quot;pipe&quot;` for |<A HREF="#uv_pipe_t">uv_pipe_t</A>|) and the libuv enum integer for the
                handle's type (`uv_handle_type`).

                Returns: `string, integer`

==============================================================================

REFERENCE COUNTING                                      *<A NAME="luv-reference-counting"></A><B>luv-reference-counting</B>*

The libuv event loop (if run in the default mode) will run until there are no
active and referenced handles left. The user can force the loop to exit early
by unreferencing handles which are active, for example by calling |<A HREF="uv.html">uv.unref()</A>|
after calling |<A HREF="uv.html">uv.timer_start()</A>|.

A handle can be referenced or unreferenced, the refcounting scheme doesn't use
a counter, so both operations are idempotent.

All handles are referenced when active by default, see |<A HREF="uv.html">uv.is_active()</A>| for a
more detailed explanation on what being active involves.

==============================================================================

`uv_timer_t` — Timer handle                          *<A NAME="luv-timer-handle"></A><B>luv-timer-handle</B>* *<A NAME="uv_timer_t"></A><B>uv_timer_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Timer handles are used to schedule callbacks to be called in the future.


<A HREF="#uv.new_timer()">uv.new_timer()</A>                                                  *<A NAME="uv.new_timer()"></A><B>uv.new_timer()</B>*

                Creates and initializes a new |<A HREF="#uv_timer_t">uv_timer_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_timer_t userdata` or `fail`

                   
<B>                    -- Creating a simple setTimeout wrapper</B>
<B>                    local function setTimeout(timeout, callback)</B>
<B>                      local timer = uv.new_timer()</B>
<B>                      timer:start(timeout, 0, function ()</B>
<B>                        timer:stop()</B>
<B>                        timer:close()</B>
<B>                        callback()</B>
<B>                      end)</B>
<B>                      return timer</B>
<B>                    end</B>

<B>                    -- Creating a simple setInterval wrapper</B>
<B>                    local function setInterval(interval, callback)</B>
<B>                      local timer = uv.new_timer()</B>
<B>                      timer:start(interval, interval, function ()</B>
<B>                        callback()</B>
<B>                      end)</B>
<B>                      return timer</B>
<B>                    end</B>

<B>                    -- And clearInterval</B>
<B>                    local function clearInterval(timer)</B>
<B>                      timer:stop()</B>
<B>                      timer:close()</B>
<B>                    end</B>
 


uv.timer_start({timer}, {timeout}, {repeat}, {callback})      *<A NAME="uv.timer_start()"></A><B>uv.timer_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `timer:start(timeout, repeat, callback)`

                Parameters:
                - `timer`: `uv_timer_t userdata`
                - `timeout`: `integer`
                - `repeat`: `integer`
                - `callback`: `callable`

                Start the <A HREF="builtin.html#timer">timer</A>. `timeout` and `repeat` are in milliseconds.

                If `timeout` is zero, the callback fires on the next event
                loop iteration. If `repeat` is non-zero, the callback fires
                first after `timeout` milliseconds and then repeatedly after
                `repeat` milliseconds.

                Returns: `0` or `fail`


uv.timer_stop({timer})                                         *<A NAME="uv.timer_stop()"></A><B>uv.timer_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `timer:stop()`

                Parameters:
                - `timer`: `uv_timer_t userdata`

                Stop the <A HREF="builtin.html#timer">timer</A>, the callback will not be called anymore.

                Returns: `0` or `fail`


uv.timer_again({timer})                                       *<A NAME="uv.timer_again()"></A><B>uv.timer_again()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `timer:again()`

                Parameters:
                - `timer`: `uv_timer_t userdata`

                Stop the <A HREF="builtin.html#timer">timer</A>, and if <A HREF="motion.html#it">it</A> is <A HREF="repeat.html#repeating">repeating</A> restart <A HREF="motion.html#it">it</A> using the
                repeat value <A HREF="motion.html#as">as</A> the timeout. If the <A HREF="builtin.html#timer">timer</A> has never been
                started before <A HREF="motion.html#it">it</A> raises `EINVAL`.

                Returns: `0` or `fail`


uv.timer_set_repeat({timer}, {repeat})                   *<A NAME="uv.timer_set_repeat()"></A><B>uv.timer_set_repeat()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `timer:set_repeat(repeat)`

                Parameters:
                - `timer`: `uv_timer_t userdata`
                - `repeat`: `integer`

                Set the repeat interval value in milliseconds. The <A HREF="builtin.html#timer">timer</A> will
                be scheduled to run on the given interval, regardless of the
                callback execution duration, and will follow normal <A HREF="builtin.html#timer">timer</A>
                semantics in the <A HREF="change.html#case">case</A> of a time-slice overrun.

                For example, if a 50 ms <A HREF="repeat.html#repeating">repeating</A> <A HREF="builtin.html#timer">timer</A> first runs for 17 ms,
                <A HREF="motion.html#it">it</A> will be scheduled to run again 33 ms later. If other tasks
                consume more than the 33 ms following the first <A HREF="builtin.html#timer">timer</A>
                callback, then the callback will run <A HREF="motion.html#as">as</A> soon <A HREF="motion.html#as">as</A> possible.

                Returns: Nothing.


uv.timer_get_repeat({timer})                             *<A NAME="uv.timer_get_repeat()"></A><B>uv.timer_get_repeat()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `timer:get_repeat()`

                Parameters:
                - `timer`: `uv_timer_t userdata`

                Get the <A HREF="builtin.html#timer">timer</A> repeat value.

                Returns: `integer`


uv.timer_get_due_in({timer})                             *<A NAME="uv.timer_get_due_in()"></A><B>uv.timer_get_due_in()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `timer:get_due_in()`

                Parameters:
                - `timer`: `uv_timer_t userdata`

                Get the <A HREF="builtin.html#timer">timer</A> due value or 0 if <A HREF="motion.html#it">it</A> has expired. The time is
                relative to |<A HREF="uv.html">uv.now()</A>|.

                Returns: `integer`

                Note: New in libuv version 1.40.0.

==============================================================================

`uv_prepare_t` — Prepare handle                  *<A NAME="luv-prepare-handle"></A><B>luv-prepare-handle</B>* *<A NAME="uv_prepare_t"></A><B>uv_prepare_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Prepare handles will run the given callback once per loop iteration, right
before polling for I/O.

   
<B>    local prepare = uv.new_prepare()</B>
<B>    prepare:start(function()</B>
<B>      print("Before I/O polling")</B>
<B>    end)</B>
 


<A HREF="#uv.new_prepare()">uv.new_prepare()</A>                                              *<A NAME="uv.new_prepare()"></A><B>uv.new_prepare()</B>*

                Creates and initializes a new |<A HREF="#uv_prepare_t">uv_prepare_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_prepare_t userdata` or `fail`


uv.prepare_start({prepare}, {callback})                     *<A NAME="uv.prepare_start()"></A><B>uv.prepare_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `prepare:start(callback)`

                Parameters:
                - `prepare`: `uv_prepare_t userdata`
                - `callback`: `callable`

                Start the handle with the given callback.

                Returns: `0` or `fail`


uv.prepare_stop({prepare})                                   *<A NAME="uv.prepare_stop()"></A><B>uv.prepare_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `prepare:stop()`

                Parameters:
                - `prepare`: `uv_prepare_t userdata`

                Stop the handle, the callback will no longer be called.

                Returns: `0` or `fail`

==============================================================================

`uv_check_t` — Check handle                          *<A NAME="luv-check-handle"></A><B>luv-check-handle</B>* *<A NAME="uv_check_t"></A><B>uv_check_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Check handles will run the given callback once per loop iteration, right after
polling for I/O.

   
<B>    local check = uv.new_check()</B>
<B>    check:start(function()</B>
<B>      print("After I/O polling")</B>
<B>    end)</B>
 


<A HREF="#uv.new_check()">uv.new_check()</A>                                                  *<A NAME="uv.new_check()"></A><B>uv.new_check()</B>*

                Creates and initializes a new |<A HREF="#uv_check_t">uv_check_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_check_t userdata` or `fail`


uv.check_start({check}, {callback})                           *<A NAME="uv.check_start()"></A><B>uv.check_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `check:start(callback)`

                Parameters:
                - `check`: `uv_check_t userdata`
                - `callback`: `callable`

                Start the handle with the given callback.

                Returns: `0` or `fail`


uv.check_stop({check})                                         *<A NAME="uv.check_stop()"></A><B>uv.check_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `check:stop()`

                Parameters:
                - `check`: `uv_check_t userdata`

                Stop the handle, the callback will no longer be called.

                Returns: `0` or `fail`

==============================================================================

`uv_idle_t` — Idle handle                              *<A NAME="luv-idle-handle"></A><B>luv-idle-handle</B>* *<A NAME="uv_idle_t"></A><B>uv_idle_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Idle handles will run the given callback once per loop iteration, right before
the |<A HREF="#uv_prepare_t">uv_prepare_t</A>| handles.

Note: The notable difference with prepare handles is that when there are
active idle handles, the loop will perform a zero timeout poll instead of
blocking for I/O.

WARNING: Despite the name, idle handles will get their callbacks called on
every loop iteration, not when the loop is actually &quot;idle&quot;.

   
<B>    local idle = uv.new_idle()</B>
<B>    idle:start(function()</B>
<B>      print("Before I/O polling, no blocking")</B>
<B>    end)</B>
 


<A HREF="#uv.new_idle()">uv.new_idle()</A>                                                    *<A NAME="uv.new_idle()"></A><B>uv.new_idle()</B>*

                Creates and initializes a new |<A HREF="#uv_idle_t">uv_idle_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_idle_t userdata` or `fail`


uv.idle_start({idle}, {callback})                              *<A NAME="uv.idle_start()"></A><B>uv.idle_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `idle:start(callback)`

                Parameters:
                - `idle`: `uv_idle_t userdata`
                - `callback`: `callable`

                Start the handle with the given callback.

                Returns: `0` or `fail`


uv.idle_stop({check})                                           *<A NAME="uv.idle_stop()"></A><B>uv.idle_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `idle:stop()`

                Parameters:
                - `idle`: `uv_idle_t userdata`

                Stop the handle, the callback will no longer be called.

                Returns: `0` or `fail`

==============================================================================

`uv_async_t` — Async handle                          *<A NAME="luv-async-handle"></A><B>luv-async-handle</B>* *<A NAME="uv_async_t"></A><B>uv_async_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Async handles allow the user to &quot;wakeup&quot; the event loop and get a callback
called from another thread.

   
<B>    local async</B>
<B>    async = uv.new_async(function()</B>
<B>      print("async operation ran")</B>
<B>      async:close()</B>
<B>    end)</B>

<B>    async:send()</B>
 


uv.new_async([{callback}])                                      *<A NAME="uv.new_async()"></A><B>uv.new_async()</B>*

                Parameters:
                - `callback`: `callable` or `nil`
                  - `...`: `threadargs` passed to/from
                    `uv.async_send(async, ...)`

                Creates and initializes a new |<A HREF="#uv_async_t">uv_async_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>. A `nil` callback is allowed.

                Returns: `uv_async_t userdata` or `fail`

                Note: Unlike other handle <A HREF="starting.html#initialization">initialization</A> <A HREF="eval.html#functions">functions</A>, this
                immediately starts the handle.


uv.async_send({async}, {...})                                  *<A NAME="uv.async_send()"></A><B>uv.async_send()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `async:send(...)`

                Parameters:
                - `async`: `uv_async_t userdata`
                - `...`: `threadargs`

                Wakeup the event loop and call the async handle's callback.

                Returns: `0` or `fail`

                Note: It's safe to call this function from any thread. The
                callback will be called on the loop thread.

                WARNING: libuv will coalesce calls to `uv.async_send(async)`,
                that is, not every call to <A HREF="motion.html#it">it</A> will yield an execution of the
                callback. For example: if `uv.async_send()` is called 5 times
                in a row before the callback is called, the callback will only
                be called once. If `uv.async_send()` is called again after the
                callback was called, <A HREF="motion.html#it">it</A> will be called again.

==============================================================================

`uv_poll_t` — Poll handle                              *<A NAME="luv-poll-handle"></A><B>luv-poll-handle</B>* *<A NAME="uv_poll_t"></A><B>uv_poll_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Poll handles are used to watch file descriptors for readability and
writability, similar to the purpose of poll(2)
	<A HREF="http://linux.die.net/man/2/poll">http://linux.die.net/man/2/poll</A>.

The purpose of poll handles is to enable integrating external libraries that
rely on the event loop to signal <A HREF="motion.html#it">it</A> about the socket status changes, like
c-ares or libssh2. Using `uv_poll_t` for any other purpose is not recommended;
|<A HREF="#uv_tcp_t">uv_tcp_t</A>|, |<A HREF="#uv_udp_t">uv_udp_t</A>|, etc. provide an implementation that is faster and more
scalable than what can be achieved with `uv_poll_t`, especially on Windows.

It is possible that poll handles occasionally signal that a file descriptor is
readable or writable even when <A HREF="motion.html#it">it</A> isn't. The user should therefore always be
prepared to handle EAGAIN or equivalent when <A HREF="motion.html#it">it</A> attempts to read from or write
to the fd.

It is not okay to have multiple active poll handles for the same socket, this
can cause libuv to busyloop or otherwise malfunction.

The user should not close a file descriptor while <A HREF="motion.html#it">it</A> is being polled by an
active poll handle. This can cause the handle to report an error, but <A HREF="motion.html#it">it</A> might
also start polling another socket. However the fd can be safely closed
immediately after a call to |<A HREF="uv.html">uv.poll_stop()</A>| or |<A HREF="uv.html">uv.close()</A>|.

Note: On <A HREF="windows.html#windows">windows</A> only sockets can be polled with poll handles. On Unix any
file descriptor that would be accepted by poll(2) can be used.


uv.new_poll({fd})                                                *<A NAME="uv.new_poll()"></A><B>uv.new_poll()</B>*

                Parameters:
                - `fd`: `integer`

                Initialize the handle using a file descriptor.

                The file descriptor is set to non-blocking mode.

                Returns: `uv_poll_t userdata` or `fail`


uv.new_socket_poll({fd})                                  *<A NAME="uv.new_socket_poll()"></A><B>uv.new_socket_poll()</B>*

                Parameters:
                - `fd`: `integer`

                Initialize the handle using a socket descriptor. On Unix this
                is identical to |<A HREF="uv.html">uv.new_poll()</A>|. On <A HREF="windows.html#windows">windows</A> <A HREF="motion.html#it">it</A> takes a SOCKET
                handle.

                The socket is set to non-blocking mode.

                Returns: `uv_poll_t userdata` or `fail`


uv.poll_start({poll}, {events}, {callback})                    *<A NAME="uv.poll_start()"></A><B>uv.poll_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `poll:start(events, callback)`

                Parameters:
                - `poll`: `uv_poll_t userdata`
                - `events`: `string` or `nil` (default: `&quot;rw&quot;`)
                - `callback`: `callable`
                  - `err`: `nil` or `string`
                  - `events`: `string` or `nil`

                Starts polling the file descriptor. `events` are: `&quot;r&quot;`,
                `&quot;w&quot;`, `&quot;rw&quot;`, `&quot;d&quot;`, `&quot;rd&quot;`, `&quot;wd&quot;`, `&quot;rwd&quot;`, `&quot;p&quot;`, `&quot;rp&quot;`,
                `&quot;wp&quot;`, `&quot;rwp&quot;`, `&quot;dp&quot;`, `&quot;rdp&quot;`, `&quot;wdp&quot;`, or `&quot;rwdp&quot;` where
                `r` is `READABLE`, `w` is `WRITABLE`, `d` is `DISCONNECT`, and
                `p` is `PRIORITIZED`. As soon <A HREF="motion.html#as">as</A> an event is detected the
                callback will be called with status set to 0, and the detected
                <A HREF="autocmd.html#events">events</A> set on the <A HREF="autocmd.html#events">events</A> field.

                The user should not close the socket while the handle is
                active. If the user does that anyway, the callback may be
                called reporting an error status, but this is not guaranteed.

                Returns: `0` or `fail`

                Note Calling `uv.poll_start()` on a handle that is already
                active is fine. Doing so will update the <A HREF="autocmd.html#events">events</A> mask that is
                being watched for.


uv.poll_stop({poll})                                            *<A NAME="uv.poll_stop()"></A><B>uv.poll_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `poll:stop()`

                Parameters:
                - `poll`: `uv_poll_t userdata`

                Stop polling the file descriptor, the callback will no longer
                be called.

                Returns: `0` or `fail`

==============================================================================

`uv_signal_t` — <A HREF="autocmd.html#Signal">Signal</A> handle                      *<A NAME="luv-signal-handle"></A><B>luv-signal-handle</B>* *<A NAME="uv_signal_t"></A><B>uv_signal_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

<A HREF="autocmd.html#Signal">Signal</A> handles implement Unix style signal handling on a per-event loop bases.

Windows Notes:

Reception of some signals is emulated on Windows:
  - SIGINT is normally delivered when the user presses CTRL+C. However, like
    on Unix, <A HREF="motion.html#it">it</A> is not generated when <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> raw mode is enabled.
  - SIGBREAK is delivered when the user pressed CTRL + BREAK.
  - SIGHUP is generated when the user closes the console <A HREF="windows.html#window">window</A>. On SIGHUP the
    program is given approximately 10 seconds to perform cleanup. After that
    Windows will unconditionally terminate <A HREF="motion.html#it">it</A>.
  - SIGWINCH is raised whenever libuv detects that the console has been
    resized. SIGWINCH is emulated by libuv when the program uses a <A HREF="#uv_tty_t">uv_tty_t</A>
    handle to write to the console. SIGWINCH may not always be delivered in a
    timely manner; libuv will only detect size changes when the cursor is
    being moved. When a readable |<A HREF="#uv_tty_t">uv_tty_t</A>| handle is used in raw mode,
    resizing the console buffer will also trigger a SIGWINCH signal.
  - Watchers for other signals can be successfully created, but these signals
    are never received. These signals are: SIGILL, SIGABRT, SIGFPE, SIGSEGV,
    SIGTERM and SIGKILL.
  - Calls to raise() or abort() to programmatically raise a signal are not
    detected by libuv; these will not trigger a signal watcher.

Unix Notes:

  - SIGKILL and SIGSTOP are impossible to catch.
  - Handling SIGBUS, SIGFPE, SIGILL or SIGSEGV via libuv results into
    undefined behavior.
  - SIGABRT will not be caught by libuv if generated by abort(), e.g. through
    assert().
  - On Linux SIGRT0 and SIGRT1 (signals 32 and 33) are used by the NPTL
    pthreads library to manage threads. Installing watchers for those signals
    will lead to unpredictable behavior and is strongly discouraged. Future
    versions of libuv may simply reject them.

   
<B>    -- Create a new signal handler</B>
<B>    local signal = uv.new_signal()</B>
<B>    -- Define a handler function</B>
<B>    uv.signal_start(signal, "sigint", function(signal)</B>
<B>      print("got " .. signal .. ", shutting down")</B>
<B>      os.exit(1)</B>
<B>    end)</B>
 


<A HREF="#uv.new_signal()">uv.new_signal()</A>                                                *<A NAME="uv.new_signal()"></A><B>uv.new_signal()</B>*

                Creates and initializes a new |<A HREF="#uv_signal_t">uv_signal_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_signal_t userdata` or `fail`


uv.signal_start({signal}, {signum}, {callback})              *<A NAME="uv.signal_start()"></A><B>uv.signal_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `signal:start(signum, callback)`

                Parameters:
                - `signal`: `uv_signal_t userdata`
                - `signum`: `integer` or `string`
                - `callback`: `callable`
                  - `signum`: `string`

                Start the handle with the given callback, watching for the
                given signal.

                Returns: `0` or `fail`

                                                     *<A NAME="uv.signal_start_oneshot()"></A><B>uv.signal_start_oneshot()</B>*
uv.signal_start_oneshot({signal}, {signum}, {callback})

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `signal:start_oneshot(signum, callback)`

                Parameters:
                - `signal`: `uv_signal_t userdata`
                - `signum`: `integer` or `string`
                - `callback`: `callable`
                  - `signum`: `string`

                Same functionality <A HREF="motion.html#as">as</A> |<A HREF="uv.html">uv.signal_start()</A>| but the signal
                handler is reset the moment the signal is received.

                Returns: `0` or `fail`


uv.signal_stop({signal})                                      *<A NAME="uv.signal_stop()"></A><B>uv.signal_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `signal:stop()`

                Parameters:
                - `signal`: `uv_signal_t userdata`

                Stop the handle, the callback will no longer be called.

                Returns: `0` or `fail`

==============================================================================

`uv_process_t` — Process handle                  *<A NAME="luv-process-handle"></A><B>luv-process-handle</B>* *<A NAME="uv_process_t"></A><B>uv_process_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Process handles will spawn a new process and allow the user to <A HREF="intro.html#control">control</A> <A HREF="motion.html#it">it</A> and
establish communication channels with <A HREF="motion.html#it">it</A> using streams.


<A HREF="#uv.disable_stdio_inheritance()">uv.disable_stdio_inheritance()</A>                  *<A NAME="uv.disable_stdio_inheritance()"></A><B>uv.disable_stdio_inheritance()</B>*

                Disables inheritance for file descriptors / handles that this
                process inherited from its parent. The effect is that child
                processes spawned by this process don't accidentally inherit
                these handles.

                It is recommended to call this function <A HREF="motion.html#as">as</A> early in your
                program <A HREF="motion.html#as">as</A> possible, before the inherited file descriptors can
                be closed or duplicated.

                Returns: Nothing.

                Note: This function works on a best-effort basis: there is no
                guarantee that libuv can discover all file descriptors that
                were inherited. In general <A HREF="motion.html#it">it</A> does a better <A HREF="job_control.html#job">job</A> on Windows
                than <A HREF="motion.html#it">it</A> does on Unix.


uv.spawn({path}, {options}, {on_exit})                              *<A NAME="uv.spawn()"></A><B>uv.spawn()</B>*

                Parameters:
                - `path`: `string`
                - `options`: `table` (see below)
                - `on_exit`: `callable`
                  - `code`: `integer`
                  - `signal`: `integer`

                Initializes the process handle and starts the process. If the
                process is successfully spawned, this function will return the
                handle and pid of the child process.

                Possible reasons for failing to spawn would include (but not
                be limited to) the file to execute not existing, not having
                permissions to use the <A HREF="change.html#setuid">setuid</A> or setgid specified, or not
                having enough memory to allocate for the new process.

                   
<B>                    local stdin = uv.new_pipe()</B>
<B>                    local stdout = uv.new_pipe()</B>
<B>                    local stderr = uv.new_pipe()</B>

<B>                    print("stdin", stdin)</B>
<B>                    print("stdout", stdout)</B>
<B>                    print("stderr", stderr)</B>

<B>                    local handle, pid = uv.spawn("cat", {</B>
<B>                      stdio = {stdin, stdout, stderr}</B>
<B>                    }, function(code, signal) -- on exit</B>
<B>                      print("exit code", code)</B>
<B>                      print("exit signal", signal)</B>
<B>                    end)</B>

<B>                    print("process opened", handle, pid)</B>

<B>                    uv.read_start(stdout, function(err, data)</B>
<B>                      assert(not err, err)</B>
<B>                      if data then</B>
<B>                        print("stdout chunk", stdout, data)</B>
<B>                      else</B>
<B>                        print("stdout end", stdout)</B>
<B>                      end</B>
<B>                    end)</B>

<B>                    uv.read_start(stderr, function(err, data)</B>
<B>                      assert(not err, err)</B>
<B>                      if data then</B>
<B>                        print("stderr chunk", stderr, data)</B>
<B>                      else</B>
<B>                        print("stderr end", stderr)</B>
<B>                      end</B>
<B>                    end)</B>

<B>                    uv.write(stdin, "Hello World")</B>

<B>                    uv.shutdown(stdin, function()</B>
<B>                      print("stdin shutdown", stdin)</B>
<B>                      uv.close(handle, function()</B>
<B>                        print("process closed", handle, pid)</B>
<B>                      end)</B>
<B>                    end)</B>
 

                                                              *<A NAME="uv.spawn-options"></A><B>uv.spawn-options</B>*
                The `options` table accepts the following fields:

                  - `options.args` - Command line arguments <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A> of
                    <A HREF="eval.html#string">string</A>. The first <A HREF="eval.html#string">string</A> should be the path to the
                    program. On Windows, this uses CreateProcess which
                    concatenates the arguments into a <A HREF="eval.html#string">string</A>. This can cause
                    some strange <A HREF="message.html#errors">errors</A>. (See `options.verbatim` below for
                    Windows.)
                  - `options.stdio` - Set the file descriptors that will be
                    made available to the child process. The convention is
                    that the first entries are stdin, stdout, and stderr.
                    (Note: On Windows, file descriptors after the third are
                    available to the child process only if the child processes
                    uses the MSVCRT runtime.)
                  - `options.env` - Set environment <A HREF="eval.html#variables">variables</A> for the new
                    process.
                  - `options.cwd` - Set the current working directory for the
                    sub-process.
                  - `options.uid` - Set the child process' user id.
                  - `options.gid` - Set the child process' group id.
                  - `options.verbatim` - If true, <A HREF="diff.html#do">do</A> not wrap any arguments in
                    quotes, or perform any other escaping, when converting the
                    argument <A HREF="eval.html#list">list</A> into a command line <A HREF="eval.html#string">string</A>. This option is
                    only meaningful on Windows systems. On Unix <A HREF="motion.html#it">it</A> is silently
                    ignored.
                  - `options.detached` - If true, spawn the child process in a
                    detached state - this will make <A HREF="motion.html#it">it</A> a process group leader,
                    and will effectively enable the child to keep running
                    after the parent exits. Note that the child process will
                    still keep the parent's event loop alive unless the parent
                    process calls |<A HREF="uv.html">uv.unref()</A>| on the child's process handle.
                  - `options.hide` - If true, hide the subprocess console
                    <A HREF="windows.html#window">window</A> that would normally be created. This option is only
                    meaningful on Windows systems. On Unix <A HREF="motion.html#it">it</A> is silently
                    ignored.

                The `options.stdio` entries can take many shapes.

                  - If they are numbers, then the child process inherits that
                    same zero-indexed fd from the parent process.
                  - If |<A HREF="#uv_stream_t">uv_stream_t</A>| handles are passed in, those are used <A HREF="motion.html#as">as</A>
                    a read-write pipe or inherited stream depending if the
                    stream has a valid fd.
                  - Including `nil` placeholders means to ignore that fd in
                    the child process.

                When the child process exits, `on_exit` is called with an exit
                code and signal.

                Returns: `uv_process_t userdata`, `integer`


uv.process_kill({process}, {signum})                         *<A NAME="uv.process_kill()"></A><B>uv.process_kill()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `process:kill(signum)`

                Parameters:
                - `process`: `uv_process_t userdata`
                - `signum`: `integer` or `string`

                Sends the specified signal to the given process handle. Check
                the documentation on |<A HREF="#uv_signal_t">uv_signal_t</A>| for signal support,
                specially on Windows.

                Returns: `0` or `fail`


uv.kill({pid}, {signum})                                             *<A NAME="uv.kill()"></A><B>uv.kill()</B>*

                Parameters:
                - `pid`: `integer`
                - `signum`: `integer` or `string`

                Sends the specified signal to the given PID. Check the
                documentation on |<A HREF="#uv_signal_t">uv_signal_t</A>| for signal support, specially
                on Windows.

                Returns: `0` or `fail`


uv.process_get_pid({process})                             *<A NAME="uv.process_get_pid()"></A><B>uv.process_get_pid()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `process:get_pid()`

                Parameters:
                - `process`: `uv_process_t userdata`

                Returns the handle's pid.

                Returns: `integer`

==============================================================================

`uv_stream_t` — Stream handle                      *<A NAME="luv-stream-handle"></A><B>luv-stream-handle</B>* *<A NAME="uv_stream_t"></A><B>uv_stream_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Stream handles provide an abstraction of a duplex communication <A HREF="channel.html#channel">channel</A>.
`uv_stream_t` is an abstract type, libuv provides 3 stream implementations
in the form of |<A HREF="#uv_tcp_t">uv_tcp_t</A>|, |<A HREF="#uv_pipe_t">uv_pipe_t</A>| and |<A HREF="#uv_tty_t">uv_tty_t</A>|.


uv.shutdown({stream} [, {callback}])                             *<A NAME="uv.shutdown()"></A><B>uv.shutdown()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:shutdown([callback])`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `callback`: `callable` or `nil`
                  - `err`: `nil` or `string`

                Shutdown the outgoing (write) side of a duplex stream. It
                waits for pending write requests to complete. The callback is
                called after shutdown is complete.

                Returns: `uv_shutdown_t userdata` or `fail`


uv.listen({stream}, {backlog}, {callback})                         *<A NAME="uv.listen()"></A><B>uv.listen()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:listen(backlog, callback)`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `backlog`: `integer`
                - `callback`: `callable`
                  - `err`: `nil` or `string`

                Start listening for incoming connections. `backlog` indicates
                the number of connections the kernel might queue, same <A HREF="motion.html#as">as</A>
                `listen(2)`. When a new incoming connection is received the
                callback is called.

                Returns: `0` or `fail`


uv.accept({stream}, {client_stream})                               *<A NAME="uv.accept()"></A><B>uv.accept()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:accept(client_stream)`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `client_stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|

                This call is used in conjunction with |<A HREF="uv.html">uv.listen()</A>| to accept
                incoming connections. Call this function after receiving a
                callback to accept the connection.

                When the connection callback is called <A HREF="motion.html#it">it</A> is guaranteed that
                this function will complete successfully the first time. If
                you attempt to use <A HREF="motion.html#it">it</A> more than once, <A HREF="motion.html#it">it</A> may fail. It is
                suggested to only call this function once per connection call.

                Returns: `0` or `fail`

                   
<B>                    server:listen(128, function (err)</B>
<B>                      local client = uv.new_tcp()</B>
<B>                      server:accept(client)</B>
<B>                    end)</B>
 


uv.read_start({stream}, {callback})                            *<A NAME="uv.read_start()"></A><B>uv.read_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:read_start(callback)`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `callback`: `callable`
                  - `err`: `nil` or `string`
                  - `data`: `string` or `nil`

                Read data from an incoming stream. The callback will be made
                several times until there is no more data to read or
                |<A HREF="uv.html">uv.read_stop()</A>| is called. When we've reached EOF, `data`
                will be `nil`.

                Returns: `0` or `fail`

                   
<B>                    stream:read_start(function (err, chunk)</B>
<B>                      if err then</B>
<B>                        -- handle read error</B>
<B>                      elseif chunk then</B>
<B>                        -- handle data</B>
<B>                      else</B>
<B>                        -- handle disconnect</B>
<B>                      end</B>
<B>                    end)</B>
 


uv.read_stop({stream})                                          *<A NAME="uv.read_stop()"></A><B>uv.read_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:read_stop()`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|

                Stop reading data from the stream. The read callback will no
                longer be called.

                This function is idempotent and may be safely called on a
                stopped stream.

                Returns: `0` or `fail`


uv.write({stream}, {data} [, {callback}])                           *<A NAME="uv.write()"></A><B>uv.write()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:write(data, [callback])`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `data`: `buffer`
                - `callback`: `callable` or `nil`
                  - `err`: `nil` or `string`

                Write data to stream.

                `data` can either be a <A HREF="lua.html#Lua">Lua</A> <A HREF="eval.html#string">string</A> or a table of strings. If a
                table is passed in, the C backend will use writev to send all
                strings in a single system call.

                The optional `callback` is for knowing when the write is
                complete.

                Returns: `uv_write_t userdata` or `fail`


uv.write2({stream}, {data}, {send_handle} [, {callback}])          *<A NAME="uv.write2()"></A><B>uv.write2()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:write2(data, send_handle, [callback])`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `data`: `buffer`
                - `send_handle`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `callback`: `callable` or `nil`
                  - `err`: `nil` or `string`

                Extended write function for sending handles over a pipe. The
                pipe must be initialized with `ipc` option `true`.

                Returns: `uv_write_t userdata` or `fail`

                Note: `send_handle` must be a TCP socket or pipe, which is a
                server or a connection (listening or connected state). Bound
                sockets or pipes will be assumed to be servers.


uv.try_write({stream}, {data})                                  *<A NAME="uv.try_write()"></A><B>uv.try_write()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:try_write(data)`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `data`: `buffer`

                Same <A HREF="motion.html#as">as</A> |<A HREF="uv.html">uv.write()</A>|, but won't queue a write request if it
                can't be completed immediately.

                Will return number of bytes written (can be <A HREF="various.html#less">less</A> than the
                supplied buffer size).

                Returns: `integer` or `fail`


uv.try_write2({stream}, {data}, {send_handle})                 *<A NAME="uv.try_write2()"></A><B>uv.try_write2()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:try_write2(data, send_handle)`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `data`: `buffer`
                - `send_handle`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|

                Like |<A HREF="uv.html">uv.write2()</A>|, but with the properties of
                |<A HREF="uv.html">uv.try_write()</A>|. Not supported on Windows, where it returns
                `UV_EAGAIN`.

                Will return number of bytes written (can be <A HREF="various.html#less">less</A> than the
                supplied buffer size).

                Returns: `integer` or `fail`


uv.is_readable({stream})                                      *<A NAME="uv.is_readable()"></A><B>uv.is_readable()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:is_readable()`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|

                Returns `true` if the stream is readable, `false` otherwise.

                Returns: `boolean`


uv.is_writable({stream})                                      *<A NAME="uv.is_writable()"></A><B>uv.is_writable()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:is_writable()`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|

                Returns `true` if the stream is writable, `false` otherwise.

                Returns: `boolean`


uv.stream_set_blocking({stream}, {blocking})          *<A NAME="uv.stream_set_blocking()"></A><B>uv.stream_set_blocking()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:set_blocking(blocking)`

                Parameters:
                - `stream`: `userdata` for sub-type of |<A HREF="#uv_stream_t">uv_stream_t</A>|
                - `blocking`: `boolean`

                Enable or disable blocking mode for a stream.

                When blocking mode is enabled all writes complete
                synchronously. The interface remains unchanged otherwise, e.g.
                completion or failure of the operation will still be reported
                through a callback which is made asynchronously.

                Returns: `0` or `fail`

                WARNING: Relying too much on this <A HREF="api.html#API">API</A> is not recommended. It
                is likely to change significantly in the future. Currently
                this only works on Windows and only for |<A HREF="#uv_pipe_t">uv_pipe_t</A>| handles.
                Also libuv currently makes no ordering guarantee when the
                blocking mode is changed after write requests have already
                been submitted. Therefore <A HREF="motion.html#it">it</A> is recommended to set the
                blocking mode immediately after opening or creating the
                stream.


<A HREF="#uv.stream_get_write_queue_size()">uv.stream_get_write_queue_size()</A>              *<A NAME="uv.stream_get_write_queue_size()"></A><B>uv.stream_get_write_queue_size()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `stream:get_write_queue_size()`

                Returns the stream's write queue size.

                Returns: `integer`

==============================================================================

`uv_tcp_t` — TCP handle                                  *<A NAME="luv-tcp-handle"></A><B>luv-tcp-handle</B>* *<A NAME="uv_tcp_t"></A><B>uv_tcp_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| and |<A HREF="#uv_stream_t">uv_stream_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

TCP handles are used to represent both TCP streams and servers.


uv.new_tcp([{flags}])                                             *<A NAME="uv.new_tcp()"></A><B>uv.new_tcp()</B>*

                Parameters:
                - `flags`: `string` or `nil`

                Creates and initializes a new |<A HREF="#uv_tcp_t">uv_tcp_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>. Flags may be a family <A HREF="eval.html#string">string</A>: `&quot;unix&quot;`,
                `&quot;inet&quot;`, `&quot;inet6&quot;`, `&quot;ipx&quot;`, `&quot;netlink&quot;`, `&quot;x25&quot;`, `&quot;ax25&quot;`,
                `&quot;atmpvc&quot;`, `&quot;appletalk&quot;`, or `&quot;packet&quot;`.

                Returns: `uv_tcp_t userdata` or `fail`


uv.tcp_open({tcp}, {sock})                                       *<A NAME="uv.tcp_open()"></A><B>uv.tcp_open()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:open(sock)`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `sock`: `integer`

                Open an existing file descriptor or SOCKET <A HREF="motion.html#as">as</A> a TCP handle.

                Returns: `0` or `fail`

                Note: The passed file descriptor or SOCKET is not checked for
                its type, but it's required that <A HREF="motion.html#it">it</A> represents a valid stream
                socket.


uv.tcp_nodelay({tcp}, {enable})                               *<A NAME="uv.tcp_nodelay()"></A><B>uv.tcp_nodelay()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:nodelay(enable)`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `enable`: `boolean`

                Enable / disable Nagle's algorithm.

                Returns: `0` or `fail`


uv.tcp_keepalive({tcp}, {enable} [, {delay}])               *<A NAME="uv.tcp_keepalive()"></A><B>uv.tcp_keepalive()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:keepalive(enable, [delay])`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `enable`: `boolean`
                - `delay`: `integer` or `nil`

                Enable / disable TCP keep-alive. `delay` is the initial delay
                in seconds, ignored when enable is `false`.

                Returns: `0` or `fail`


uv.tcp_simultaneous_accepts({tcp}, {enable})     *<A NAME="uv.tcp_simultaneous_accepts()"></A><B>uv.tcp_simultaneous_accepts()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:simultaneous_accepts(enable)`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `enable`: `boolean`

                Enable / disable simultaneous asynchronous accept requests
                that are queued by the operating system when listening for new
                TCP connections.

                This setting is used to tune a TCP server for the desired
                performance. Having simultaneous accepts can significantly
                improve the rate of accepting connections (which is why <A HREF="motion.html#it">it</A> is
                enabled by default) but may lead to uneven load <A HREF="intro.html#distribution">distribution</A>
                in multi-process setups.

                Returns: `0` or `fail`


uv.tcp_bind({tcp}, {host}, {port} [, {flags}])                   *<A NAME="uv.tcp_bind()"></A><B>uv.tcp_bind()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:bind(host, port, [flags])`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `host`: `string`
                - `port`: `integer`
                - `flags`: `table` or `nil`
                  - `ipv6only`: `boolean`

                Bind the handle to an host and port. `host` should be an IP
                address and not a domain name. Any `flags` are set with a
                table with field `ipv6only` equal to `true` or `false`.

                When the port is already taken, you can expect to see an
                `EADDRINUSE` error from either `uv.tcp_bind()`, |<A HREF="uv.html">uv.listen()</A>|
                or |<A HREF="uv.html">uv.tcp_connect()</A>|. That is, a successful call to this
                function does not guarantee that the call to |<A HREF="uv.html">uv.listen()</A>| or
                |<A HREF="uv.html">uv.tcp_connect()</A>| will succeed <A HREF="motion.html#as">as</A> well.

                Use a port of `0` to let the OS assign an ephemeral port.  You
                can look <A HREF="motion.html#it">it</A> up later using |<A HREF="uv.html">uv.tcp_getsockname()</A>|.

                Returns: `0` or `fail`


uv.tcp_getpeername({tcp})                                 *<A NAME="uv.tcp_getpeername()"></A><B>uv.tcp_getpeername()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:getpeername()`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`

                Get the address of the peer connected to the handle.

                Returns: `table` or `fail`
                - `ip` : `string`
                - `family` : `string`
                - `port` : `integer`


uv.tcp_getsockname({tcp})                                 *<A NAME="uv.tcp_getsockname()"></A><B>uv.tcp_getsockname()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:getsockname()`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`

                Get the current address to which the handle is bound.

                Returns: `table` or `fail`
                - `ip` : `string`
                - `family` : `string`
                - `port` : `integer`


uv.tcp_connect({tcp}, {host}, {port}, {callback})             *<A NAME="uv.tcp_connect()"></A><B>uv.tcp_connect()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:connect(host, port, callback)`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `host`: `string`
                - `port`: `integer`
                - `callback`: `callable`
                   - `err`: `nil` or `string`

                Establish an IPv4 or IPv6 TCP connection.

                Returns: `uv_connect_t userdata` or `fail`

                   
<B>                    local client = uv.new_tcp()</B>
<B>                    client:connect("127.0.0.1", 8080, function (err)</B>
<B>                      -- check error and carry on.</B>
<B>                    end)</B>
 


uv.tcp_write_queue_size({tcp})                       *<A NAME="uv.tcp_write_queue_size()"></A><B>uv.tcp_write_queue_size()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:write_queue_size()`

                DEPRECATED: Please use |<A HREF="uv.html">uv.stream_get_write_queue_size()</A>|
                instead.


uv.tcp_close_reset([{callback}])                          *<A NAME="uv.tcp_close_reset()"></A><B>uv.tcp_close_reset()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tcp:close_reset([callback])`

                Parameters:
                - `tcp`: `uv_tcp_t userdata`
                - `callback`: `callable` or `nil`

                Resets a TCP connection by sending a RST packet. This is
                accomplished by setting the SO_LINGER socket option with a
                linger interval of zero and then calling |<A HREF="uv.html">uv.close()</A>|. Due to
                some platform inconsistencies, mixing of |<A HREF="uv.html">uv.shutdown()</A>| and
                `uv.tcp_close_reset()` calls is not allowed.

                Returns: `0` or `fail`

                                                               *<A NAME="uv.socketpair()"></A><B>uv.socketpair()</B>*
uv.socketpair([{socktype}, [{protocol}, [{flags1}, [{flags2}]]]])

                Parameters:
                - `socktype`: `string`, `integer` or `nil` (default: `stream`)
                - `protocol`: `string`, `integer` or `nil` (default: 0)
                - `flags1`: `table` or `nil`
                  - `nonblock`: `boolean` (default: `false`)
                - `flags2`: `table` or `nil`
                  - `nonblock`: `boolean` (default: `false`)

                Create a pair of connected sockets with the specified
                properties. The resulting handles can be passed to
                |<A HREF="uv.html">uv.tcp_open()</A>|, used with |<A HREF="uv.html">uv.spawn()</A>|, or for any other
                purpose.

                When specified <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>, `socktype` must be one of
                `&quot;stream&quot;`, `&quot;dgram&quot;`, `&quot;raw&quot;`, `&quot;rdm&quot;`, or `&quot;seqpacket&quot;`.

                When `protocol` is set to 0 or nil, <A HREF="motion.html#it">it</A> will be automatically
                chosen based on the socket's domain and type. When `protocol`
                is specified <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>, <A HREF="motion.html#it">it</A> will be looked up using the
                `getprotobyname(3)` function (examples: `&quot;ip&quot;`, `&quot;icmp&quot;`,
                `&quot;tcp&quot;`, `&quot;udp&quot;`, etc).

                Flags:
                 - `nonblock`: Opens the specified socket handle for
                   `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is
                   recommended for handles that will be used by libuv, and not
                   usually recommended otherwise.

                Equivalent to `socketpair(2)` with a domain of `AF_UNIX`.

                Returns: `table` or `fail`
                - `[1, 2]` : `integer` (file descriptor)

                   
<B>                    -- Simple read/write with tcp</B>
<B>                    local fds = uv.socketpair(nil, nil, {nonblock=true}, {nonblock=true})</B>

<B>                    local sock1 = uv.new_tcp()</B>
<B>                    sock1:open(fds[1])</B>

<B>                    local sock2 = uv.new_tcp()</B>
<B>                    sock2:open(fds[2])</B>

<B>                    sock1:write("hello")</B>
<B>                    sock2:read_start(function(err, chunk)</B>
<B>                      assert(not err, err)</B>
<B>                      print(chunk)</B>
<B>                    end)</B>
 

==============================================================================

`uv_pipe_t` — Pipe handle                              *<A NAME="luv-pipe-handle"></A><B>luv-pipe-handle</B>* *<A NAME="uv_pipe_t"></A><B>uv_pipe_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| and |<A HREF="#uv_stream_t">uv_stream_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

Pipe handles provide an abstraction over local domain sockets on Unix and
named pipes on Windows.

   
<B>    local pipe = uv.new_pipe(false)</B>

<B>    pipe:bind('/tmp/sock.test')</B>

<B>    pipe:listen(128, function()</B>
<B>      local client = uv.new_pipe(false)</B>
<B>      pipe:accept(client)</B>
<B>      client:write("hello!\n")</B>
<B>      client:close()</B>
<B>    end)</B>
 


uv.new_pipe([{ipc}])                                             *<A NAME="uv.new_pipe()"></A><B>uv.new_pipe()</B>*

                Parameters:
                - `ipc`: `boolean` or `nil` (default: `false`)

                Creates and initializes a new |<A HREF="#uv_pipe_t">uv_pipe_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>. The `ipc` argument is a <A HREF="options.html#boolean">boolean</A> to
                indicate if this pipe will be used for handle passing between
                processes.

                Returns: `uv_pipe_t userdata` or `fail`


uv.pipe_open({pipe}, {fd})                                      *<A NAME="uv.pipe_open()"></A><B>uv.pipe_open()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:open(fd)`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`
                - `fd`: `integer`

                Open an existing file descriptor or |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="motion.html#as">as</A> a
                pipe.

                Returns: `0` or `fail`

                Note: The file descriptor is set to non-blocking mode.


uv.pipe_bind({pipe}, {name})                                    *<A NAME="uv.pipe_bind()"></A><B>uv.pipe_bind()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:bind(name)`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`
                - `name`: `string`

                Bind the pipe to a file path (Unix) or a name (Windows).

                Returns: `0` or `fail`

                Note: Paths on Unix get truncated to
                sizeof(sockaddr_un.sun_path) bytes, typically between 92 and
                108 bytes.


uv.pipe_connect({pipe}, {name} [, {callback}])               *<A NAME="uv.pipe_connect()"></A><B>uv.pipe_connect()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:connect(name, [callback])`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`
                - `name`: `string`
                - `callback`: `callable` or `nil`
                  - `err`: `nil` or `string`

                Connect to the Unix domain socket or the named pipe.

                Returns: `uv_connect_t userdata` or `fail`

                Note: Paths on Unix get truncated to
                sizeof(sockaddr_un.sun_path) bytes, typically between 92 and
                108 bytes.


uv.pipe_getsockname({pipe})                              *<A NAME="uv.pipe_getsockname()"></A><B>uv.pipe_getsockname()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:getsockname()`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`

                Get the name of the Unix domain socket or the named pipe.

                Returns: `string` or `fail`


uv.pipe_getpeername({pipe})                              *<A NAME="uv.pipe_getpeername()"></A><B>uv.pipe_getpeername()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:getpeername()`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`

                Get the name of the Unix domain socket or the named pipe to
                which the handle is connected.

                Returns: `string` or `fail`


uv.pipe_pending_instances({pipe}, {count})         *<A NAME="uv.pipe_pending_instances()"></A><B>uv.pipe_pending_instances()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:pending_instances(count)`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`
                - `count`: `integer`

                Set the number of pending pipe instance handles when the pipe
                server is waiting for connections.

                Returns: Nothing.

                Note: This setting applies to Windows only.


uv.pipe_pending_count({pipe})                          *<A NAME="uv.pipe_pending_count()"></A><B>uv.pipe_pending_count()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:pending_count()`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`

                Returns the pending pipe <A HREF="intro.html#count">count</A> for the named pipe.

                Returns: `integer`


uv.pipe_pending_type({pipe})                            *<A NAME="uv.pipe_pending_type()"></A><B>uv.pipe_pending_type()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:pending_type()`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`

                Used to receive handles over IPC pipes.

                First - call |<A HREF="uv.html">uv.pipe_pending_count()</A>|, if it's <A HREF="change.html#&gt;">&gt;</A> 0 then
                initialize a handle of the given type, returned by
                `uv.pipe_pending_type()` and call `uv.accept(pipe, handle)` .

                Returns: `string`


uv.pipe_chmod({pipe}, {flags})                                 *<A NAME="uv.pipe_chmod()"></A><B>uv.pipe_chmod()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `pipe:chmod(flags)`

                Parameters:
                - `pipe`: `uv_pipe_t userdata`
                - `flags`: `string`

                Alters pipe permissions, allowing <A HREF="motion.html#it">it</A> to be accessed from
                processes run by different users. Makes the pipe writable or
                readable by all users. `flags` are: `&quot;r&quot;`, `&quot;w&quot;`, `&quot;rw&quot;`, or
                `&quot;wr&quot;` where `r` is `READABLE` and `w` is `WRITABLE`. This
                function is blocking.

                Returns: `0` or `fail`


uv.pipe({read_flags}, {write_flags})                                 *<A NAME="uv.pipe()"></A><B>uv.pipe()</B>*

                Parameters:
                - `read_flags`: `table` or `nil`
                  - `nonblock`: `boolean` (default: `false`)
                - `write_flags`: `table` or `nil`
                  - `nonblock`: `boolean` (default: `false`)

                Create a pair of connected pipe handles. Data may be written
                to the `write` fd and read from the `read` fd. The resulting
                handles can be passed to `pipe_open`, used with `spawn`, or
                for any other purpose.

                Flags:
                 - `nonblock`: Opens the specified socket handle for
                   `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is
                   recommended for handles that will be used by libuv, and not
                   usually recommended otherwise.

                Equivalent to `pipe(2)` with the `O_CLOEXEC` flag set.

                Returns: `table` or `fail`
                - `read` : `integer` (file descriptor)
                - `write` : `integer` (file descriptor)

                   
<B>                    -- Simple read/write with pipe_open</B>
<B>                    local fds = uv.pipe({nonblock=true}, {nonblock=true})</B>

<B>                    local read_pipe = uv.new_pipe()</B>
<B>                    read_pipe:open(fds.read)</B>

<B>                    local write_pipe = uv.new_pipe()</B>
<B>                    write_pipe:open(fds.write)</B>

<B>                    write_pipe:write("hello")</B>
<B>                    read_pipe:read_start(function(err, chunk)</B>
<B>                      assert(not err, err)</B>
<B>                      print(chunk)</B>
<B>                    end)</B>
 

==============================================================================

`uv_tty_t` — TTY handle                                  *<A NAME="luv-tty-handle"></A><B>luv-tty-handle</B>* *<A NAME="uv_tty_t"></A><B>uv_tty_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| and |<A HREF="#uv_stream_t">uv_stream_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

TTY handles represent a stream for the console.

   
<B>    -- Simple echo program</B>
<B>    local stdin = uv.new_tty(0, true)</B>
<B>    local stdout = uv.new_tty(1, false)</B>

<B>    stdin:read_start(function (err, data)</B>
<B>      assert(not err, err)</B>
<B>      if data then</B>
<B>        stdout:write(data)</B>
<B>      else</B>
<B>        stdin:close()</B>
<B>        stdout:close()</B>
<B>      end</B>
<B>    end)</B>
 


uv.new_tty({fd}, {readable})                                      *<A NAME="uv.new_tty()"></A><B>uv.new_tty()</B>*

                Parameters:
                - `fd`: `integer`
                - `readable`: `boolean`

                Initialize a new TTY stream with the given file descriptor.
                Usually the file descriptor will be:

                 - 0 - stdin
                 - 1 - stdout
                 - 2 - stderr

                On Unix this function will determine the path of the fd of the
                <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> using ttyname_r(3), open <A HREF="motion.html#it">it</A>, and use <A HREF="motion.html#it">it</A> if the passed
                file descriptor refers to a TTY. This lets libuv put the tty
                in non-blocking mode without affecting other processes that
                share the tty.

                This function is not thread safe on systems that don’t support
                ioctl TIOCGPTN or TIOCPTYGNAME, for instance OpenBSD and
                Solaris.

                Returns: `uv_tty_t userdata` or `fail`

                Note: If reopening the TTY fails, libuv falls back to blocking
                writes.


uv.tty_set_mode({tty}, {mode})                               *<A NAME="uv.tty_set_mode()"></A><B>uv.tty_set_mode()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tty:set_mode(mode)`

                Parameters:
                - `tty`: `uv_tty_t userdata`
                - `mode`: `integer`

                Set the TTY using the specified <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> mode.

                Parameter `mode` is a C enum with the following values:

                  - 0 - UV_TTY_MODE_NORMAL: Initial/normal <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> mode
                  - 1 - UV_TTY_MODE_RAW: Raw input mode (On Windows,
                    ENABLE_WINDOW_INPUT is also enabled)
                  - 2 - UV_TTY_MODE_IO: Binary-safe I/O mode for IPC
                    (Unix-only)

                Returns: `0` or `fail`


<A HREF="#uv.tty_reset_mode()">uv.tty_reset_mode()</A>                                        *<A NAME="uv.tty_reset_mode()"></A><B>uv.tty_reset_mode()</B>*

                To be called when the program exits. Resets TTY settings to
                default values for the next process to take over.

                This function is async signal-safe on Unix platforms but can
                fail with error code `EBUSY` if you call <A HREF="motion.html#it">it</A> when execution is
                inside |<A HREF="uv.html">uv.tty_set_mode()</A>|.

                Returns: `0` or `fail`


uv.tty_get_winsize({tty})                                 *<A NAME="uv.tty_get_winsize()"></A><B>uv.tty_get_winsize()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `tty:get_winsize()`

                Parameters:
                - `tty`: `uv_tty_t userdata`

                Gets the current Window width and height.

                Returns: `integer, integer` or `fail`


uv.tty_set_vterm_state({state})                       *<A NAME="uv.tty_set_vterm_state()"></A><B>uv.tty_set_vterm_state()</B>*

                Parameters:
                - `state`: `string`

                Controls whether console virtual <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> sequences are
                processed by libuv or console. Useful in particular for
                enabling ConEmu support of ANSI X3.64 and Xterm 256 colors.
                Otherwise Windows10 consoles are usually detected
                automatically. State should be one of: `&quot;supported&quot;` or
                `&quot;unsupported&quot;`.

                This function is only meaningful on Windows systems. On Unix
                <A HREF="motion.html#it">it</A> is silently ignored.

                Returns: none


<A HREF="#uv.tty_get_vterm_state()">uv.tty_get_vterm_state()</A>                              *<A NAME="uv.tty_get_vterm_state()"></A><B>uv.tty_get_vterm_state()</B>*

                Get the current state of whether console virtual <A HREF="nvim_terminal_emulator.html#terminal">terminal</A>
                sequences are handled by libuv or the console. The return
                value is `&quot;supported&quot;` or `&quot;unsupported&quot;`.

                This function is not implemented on Unix, where <A HREF="motion.html#it">it</A> returns
                `ENOTSUP`.

                Returns: `string` or `fail`

==============================================================================

`uv_udp_t` — UDP handle                                  *<A NAME="luv-udp-handle"></A><B>luv-udp-handle</B>* *<A NAME="uv_udp_t"></A><B>uv_udp_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

UDP handles encapsulate UDP communication for both clients and servers.


uv.new_udp([{flags}])                                             *<A NAME="uv.new_udp()"></A><B>uv.new_udp()</B>*

                Parameters:
                - `flags`: `table` or `nil`
                  - `family`: `string` or `nil`
                  - `mmsgs`: `integer` or `nil` (default: `1`)

                Creates and initializes a new |<A HREF="#uv_udp_t">uv_udp_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>. The actual socket is created lazily.

                When specified, `family` must be one of `&quot;unix&quot;`, `&quot;inet&quot;`,
                `&quot;inet6&quot;`, `&quot;ipx&quot;`, `&quot;netlink&quot;`, `&quot;x25&quot;`, `&quot;ax25&quot;`,
                `&quot;atmpvc&quot;`, `&quot;appletalk&quot;`, or `&quot;packet&quot;`.

                When specified, `mmsgs` determines the number of <A HREF="message.html#messages">messages</A> able
                to be received at one time via `recvmmsg(2)` (the allocated
                buffer will be sized to be able to fit the specified number of
                max size dgrams). Only has an effect on platforms that support
                `recvmmsg(2)`.

                Note: For backwards compatibility reasons, `flags` can also be
                a <A HREF="eval.html#string">string</A> or integer. When <A HREF="motion.html#it">it</A> is a <A HREF="eval.html#string">string</A>, <A HREF="motion.html#it">it</A> will be treated
                like the `family` key above. When <A HREF="motion.html#it">it</A> is an integer, <A HREF="motion.html#it">it</A> will be
                used directly <A HREF="motion.html#as">as</A> the `flags` parameter when calling
                `uv_udp_init_ex`.

                Returns: `uv_udp_t userdata` or `fail`


<A HREF="#uv.udp_get_send_queue_size()">uv.udp_get_send_queue_size()</A>                      *<A NAME="uv.udp_get_send_queue_size()"></A><B>uv.udp_get_send_queue_size()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:get_send_queue_size()`

                Returns the handle's send queue size.

                Returns: `integer`


<A HREF="#uv.udp_get_send_queue_count()">uv.udp_get_send_queue_count()</A>                    *<A NAME="uv.udp_get_send_queue_count()"></A><B>uv.udp_get_send_queue_count()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:get_send_queue_count()`

                Returns the handle's send queue <A HREF="intro.html#count">count</A>.

                Returns: `integer`


uv.udp_open({udp}, {fd})                                         *<A NAME="uv.udp_open()"></A><B>uv.udp_open()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:open(fd)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `fd`: `integer`

                Opens an existing file descriptor or Windows SOCKET <A HREF="motion.html#as">as</A> a UDP
                handle.

                Unix only: The only requirement of the sock argument is that
                <A HREF="motion.html#it">it</A> follows the datagram contract (works in unconnected mode,
                supports sendmsg()/recvmsg(), etc). In other words, other
                datagram-type sockets like raw sockets or netlink sockets can
                also be passed to this function.

                The file descriptor is set to non-blocking mode.

                Note: The passed file descriptor or SOCKET is not checked for
                its type, but it's required that <A HREF="motion.html#it">it</A> represents a valid
                datagram socket.

                Returns: `0` or `fail`


uv.udp_bind({udp}, {host}, {port} [, {flags}])                   *<A NAME="uv.udp_bind()"></A><B>uv.udp_bind()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:bind(host, port, [flags])`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `host`: `string`
                - `port`: `number`
                - `flags`: `table` or `nil`
                  - `ipv6only`: `boolean`
                  - `reuseaddr`: `boolean`

                Bind the UDP handle to an IP address and port. Any `flags` are
                set with a table with fields `reuseaddr` or `ipv6only` equal
                to `true` or `false`.

                Returns: `0` or `fail`


uv.udp_getsockname({udp})                                 *<A NAME="uv.udp_getsockname()"></A><B>uv.udp_getsockname()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:getsockname()`

                Parameters:
                - `udp`: `uv_udp_t userdata`

                Get the local IP and port of the UDP handle.

                Returns: `table` or `fail`
                - `ip` : `string`
                - `family` : `string`
                - `port` : `integer`


uv.udp_getpeername({udp})                                 *<A NAME="uv.udp_getpeername()"></A><B>uv.udp_getpeername()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:getpeername()`

                Parameters:
                - `udp`: `uv_udp_t userdata`

                Get the remote IP and port of the UDP handle on connected UDP
                handles.

                Returns: `table` or `fail`
                - `ip` : `string`
                - `family` : `string`
                - `port` : `integer`


                                                       *<A NAME="uv.udp_set_membership()"></A><B>uv.udp_set_membership()</B>*
uv.udp_set_membership({udp}, {multicast_addr}, {interface_addr}, {membership})

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form
                <A HREF="change.html#&gt;">&gt;</A> `udp:set_membership(multicast_addr, interface_addr, membership)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `multicast_addr`: `string`
                - `interface_addr`: `string` or `nil`
                - `membership`: `string`

                Set membership for a multicast address. `multicast_addr` is
                multicast address to set membership for. `interface_addr` is
                interface address. `membership` can be the <A HREF="eval.html#string">string</A> `&quot;leave&quot;` or
                `&quot;join&quot;`.

                Returns: `0` or `fail`


                                                *<A NAME="uv.udp_set_source_membership()"></A><B>uv.udp_set_source_membership()</B>*
uv.udp_set_source_membership({udp}, {multicast_addr}, {interface_addr}, {source_addr}, {membership})

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form
                <A HREF="change.html#&gt;">&gt;</A> `udp:set_source_membership(multicast_addr, interface_addr, source_addr, membership)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `multicast_addr`: `string`
                - `interface_addr`: `string` or `nil`
                - `source_addr`: `string`
                - `membership`: `string`

                Set membership for a source-specific multicast group.
                `multicast_addr` is multicast address to set membership for.
                `interface_addr` is interface address. `source_addr` is source
                address. `membership` can be the <A HREF="eval.html#string">string</A> `&quot;leave&quot;` or `&quot;join&quot;`.

                Returns: `0` or `fail`


uv.udp_set_multicast_loop({udp}, {on})             *<A NAME="uv.udp_set_multicast_loop()"></A><B>uv.udp_set_multicast_loop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:set_multicast_loop(on)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `on`: `boolean`

                Set IP multicast loop flag. Makes multicast packets loop back
                to local sockets.

                Returns: `0` or `fail`


uv.udp_set_multicast_ttl({udp}, {ttl})              *<A NAME="uv.udp_set_multicast_ttl()"></A><B>uv.udp_set_multicast_ttl()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:set_multicast_ttl(ttl)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `ttl`: `integer`

                Set the multicast ttl.

                `ttl` is an integer 1 through 255.

                Returns: `0` or `fail`


                                              *<A NAME="uv.udp_set_multicast_interface()"></A><B>uv.udp_set_multicast_interface()</B>*
uv.udp_set_multicast_interface({udp}, {interface_addr})

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:set_multicast_interface(interface_addr)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `interface_addr`: `string`

                Set the multicast interface to send or receive data on.

                Returns: `0` or `fail`


uv.udp_set_broadcast({udp}, {on})                       *<A NAME="uv.udp_set_broadcast()"></A><B>uv.udp_set_broadcast()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:set_broadcast(on)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `on`: `boolean`

                Set broadcast on or off.

                Returns: `0` or `fail`


uv.udp_set_ttl({udp}, {ttl})                                  *<A NAME="uv.udp_set_ttl()"></A><B>uv.udp_set_ttl()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:set_ttl(ttl)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `ttl`: `integer`

                Set the time to live.

                `ttl` is an integer 1 through 255.

                Returns: `0` or `fail`


uv.udp_send({udp}, {data}, {host}, {port}, {callback})           *<A NAME="uv.udp_send()"></A><B>uv.udp_send()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:send(data, host, port, callback)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `data`: `buffer`
                - `host`: `string`
                - `port`: `integer`
                - `callback`: `callable`
                  - `err`: `nil` or `string`

                Send data over the UDP socket. If the socket has not
                previously been bound with |<A HREF="uv.html">uv.udp_bind()</A>| <A HREF="motion.html#it">it</A> will be bound to
                `0.0.0.0` (the &quot;all interfaces&quot; IPv4 address) and a random
                port number.

                Returns: `uv_udp_send_t userdata` or `fail`


uv.udp_try_send({udp}, {data}, {host}, {port})               *<A NAME="uv.udp_try_send()"></A><B>uv.udp_try_send()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:try_send(data, host, port)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `data`: `buffer`
                - `host`: `string`
                - `port`: `integer`

                Same <A HREF="motion.html#as">as</A> |<A HREF="uv.html">uv.udp_send()</A>|, but won't queue a send request if <A HREF="motion.html#it">it</A>
                can't be completed immediately.

                Returns: `integer` or `fail`


uv.udp_recv_start({udp}, {callback})                       *<A NAME="uv.udp_recv_start()"></A><B>uv.udp_recv_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:recv_start(callback)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `callback`: `callable`
                  - `err`: `nil` or `string`
                  - `data`: `string` or `nil`
                  - `addr`: `table` or `nil`
                    - `ip`: `string`
                    - `port`: `integer`
                    - `family`: `string`
                  - `flags`: `table`
                    - `partial`: `boolean` or `nil`
                    - `mmsg_chunk`: `boolean` or `nil`

                Prepare for receiving data. If the socket has not previously
                been bound with |<A HREF="uv.html">uv.udp_bind()</A>| <A HREF="motion.html#it">it</A> is bound to `0.0.0.0` (the
                &quot;all interfaces&quot; IPv4 address) and a random port number.

                Returns: `0` or `fail`


uv.udp_recv_stop({udp})                                     *<A NAME="uv.udp_recv_stop()"></A><B>uv.udp_recv_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:recv_stop()`

                Parameters:
                - `udp`: `uv_udp_t userdata`

                Stop listening for incoming datagrams.

                Returns: `0` or `fail`


uv.udp_connect({udp}, {host}, {port})                         *<A NAME="uv.udp_connect()"></A><B>uv.udp_connect()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `udp:connect(host, port)`

                Parameters:
                - `udp`: `uv_udp_t userdata`
                - `host`: `string`
                - `port`: `integer`

                Associate the UDP handle to a remote address and port, so
                every message sent by this handle is automatically sent to
                that destination. Calling this function with a NULL addr
                disconnects the handle. Trying to call `uv.udp_connect()` on
                an already connected handle will result in an `EISCONN` error.
                Trying to disconnect a handle that is not connected will
                return an `ENOTCONN` error.

                Returns: `0` or `fail`

==============================================================================

`uv_fs_event_t` — FS Event handle              *<A NAME="luv-fs-event-handle"></A><B>luv-fs-event-handle</B>* *<A NAME="uv_fs_event_t"></A><B>uv_fs_event_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

FS Event handles allow the user to monitor a given path for changes, for
example, if the file was renamed or there was a generic change in <A HREF="motion.html#it">it</A>. This
handle uses the best backend for the <A HREF="job_control.html#job">job</A> on each platform.


<A HREF="#uv.new_fs_event()">uv.new_fs_event()</A>                                            *<A NAME="uv.new_fs_event()"></A><B>uv.new_fs_event()</B>*

                Creates and initializes a new |<A HREF="#uv_fs_event_t">uv_fs_event_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_fs_event_t userdata` or `fail`


uv.fs_event_start({fs_event}, {path}, {flags}, {callback}) *<A NAME="uv.fs_event_start()"></A><B>uv.fs_event_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `fs_event:start(path, flags, callback)`

                Parameters:
                - `fs_event`: `uv_fs_event_t userdata`
                - `path`: `string`
                - `flags`: `table`
                  - `watch_entry`: `boolean` or `nil` (default: `false`)
                  - `stat`: `boolean` or `nil` (default: `false`)
                  - `recursive`: `boolean` or `nil` (default: `false`)
                - `callback`: `callable`
                  - `err`: `nil` or `string`
                  - `filename`: `string`
                  - `events`: `table`
                    - `change`: `boolean` or `nil`
                    - `rename`: `boolean` or `nil`

                Start the handle with the given callback, which will watch the
                specified path for changes.

                Returns: `0` or `fail`


<A HREF="#uv.fs_event_stop()">uv.fs_event_stop()</A>                                          *<A NAME="uv.fs_event_stop()"></A><B>uv.fs_event_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `fs_event:stop()`

                Stop the handle, the callback will no longer be called.

                Returns: `0` or `fail`


<A HREF="#uv.fs_event_getpath()">uv.fs_event_getpath()</A>                                    *<A NAME="uv.fs_event_getpath()"></A><B>uv.fs_event_getpath()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `fs_event:getpath()`

                Get the path being monitored by the handle.

                Returns: `string` or `fail`

==============================================================================

`uv_fs_poll_t` — FS Poll handle                  *<A NAME="luv-fs-poll-handle"></A><B>luv-fs-poll-handle</B>* *<A NAME="uv_fs_poll_t"></A><B>uv_fs_poll_t</B>*

<A HREF="change.html#&gt;">&gt;</A> |<A HREF="#uv_handle_t">uv_handle_t</A>| <A HREF="eval.html#functions">functions</A> also apply.

FS Poll handles allow the user to monitor a given path for changes. Unlike
|<A HREF="#uv_fs_event_t">uv_fs_event_t</A>|, fs poll handles use `stat` to detect when a file has changed
so they can work on file systems where fs event handles can't.


<A HREF="#uv.new_fs_poll()">uv.new_fs_poll()</A>                                              *<A NAME="uv.new_fs_poll()"></A><B>uv.new_fs_poll()</B>*

                Creates and initializes a new |<A HREF="#uv_fs_poll_t">uv_fs_poll_t</A>|. Returns the <A HREF="lua.html#Lua">Lua</A>
                userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `uv_fs_poll_t userdata` or `fail`


uv.fs_poll_start({fs_poll}, {path}, {interval}, {callback}) *<A NAME="uv.fs_poll_start()"></A><B>uv.fs_poll_start()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `fs_poll:start(path, interval, callback)`

                Parameters:
                - `fs_event`: `uv_fs_event_t userdata`
                - `path`: `string`
                - `interval`: `integer`
                - `callback`: `callable`
                  - `err`: `nil` or `string`
                  - `prev`: `table` or `nil` (see `uv.fs_stat`)
                  - `curr`: `table` or `nil` (see `uv.fs_stat`)

                Check the file at `path` for changes every `interval`
                milliseconds.

                Note: For maximum portability, use multi-second intervals.
                Sub-second intervals will not detect all changes on many file
                systems.

                Returns: `0` or `fail`


<A HREF="#uv.fs_poll_stop()">uv.fs_poll_stop()</A>                                            *<A NAME="uv.fs_poll_stop()"></A><B>uv.fs_poll_stop()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `fs_poll:stop()`

                Stop the handle, the callback will no longer be called.

                Returns: `0` or `fail`


<A HREF="#uv.fs_poll_getpath()">uv.fs_poll_getpath()</A>                                      *<A NAME="uv.fs_poll_getpath()"></A><B>uv.fs_poll_getpath()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `fs_poll:getpath()`

                Get the path being monitored by the handle.

                Returns: `string` or `fail`

==============================================================================

FILE SYSTEM OPERATIONS                      *<A NAME="luv-file-system-operations"></A><B>luv-file-system-operations</B>* *<A NAME="uv_fs_t"></A><B>uv_fs_t</B>*

Most file system <A HREF="eval.html#functions">functions</A> can operate synchronously or asynchronously. When a
synchronous version is called (by omitting a callback), the function will
immediately return the results of the FS call. When an asynchronous version is
called (by providing a callback), the function will immediately return a
`uv_fs_t userdata` and asynchronously execute its callback; if an error is
encountered, the first and only argument passed to the callback will be the
`err` error <A HREF="eval.html#string">string</A>; if the operation completes successfully, the first
argument will be `nil` and the remaining arguments will be the results of the
FS call.

Synchronous and asynchronous versions of `readFile` (with naive error
handling) are implemented below <A HREF="motion.html#as">as</A> an example:

   
<B>    local function readFileSync(path)</B>
<B>      local fd = assert(uv.fs_open(path, "r", 438))</B>
<B>      local stat = assert(uv.fs_fstat(fd))</B>
<B>      local data = assert(uv.fs_read(fd, stat.size, 0))</B>
<B>      assert(uv.fs_close(fd))</B>
<B>      return data</B>
<B>    end</B>

<B>    local data = readFileSync("main.lua")</B>
<B>    print("synchronous read", data)</B>
 

   
<B>    local function readFile(path, callback)</B>
<B>      uv.fs_open(path, "r", 438, function(err, fd)</B>
<B>        assert(not err, err)</B>
<B>        uv.fs_fstat(fd, function(err, stat)</B>
<B>          assert(not err, err)</B>
<B>          uv.fs_read(fd, stat.size, 0, function(err, data)</B>
<B>            assert(not err, err)</B>
<B>            uv.fs_close(fd, function(err)</B>
<B>              assert(not err, err)</B>
<B>              return callback(data)</B>
<B>            end)</B>
<B>          end)</B>
<B>        end)</B>
<B>      end)</B>
<B>    end</B>

<B>    readFile("main.lua", function(data)</B>
<B>      print("asynchronous read", data)</B>
<B>    end)</B>
 


uv.fs_close({fd} [, {callback}])                                 *<A NAME="uv.fs_close()"></A><B>uv.fs_close()</B>*

                Parameters:
                - `fd`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `close(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_open({path}, {flags}, {mode} [, {callback}])                *<A NAME="uv.fs_open()"></A><B>uv.fs_open()</B>*

                Parameters:
                - `path`: `string`
                - `flags`: `string` or `integer`
                - `mode`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `fd`: `integer` or `nil`

                Equivalent to `open(2)`. Access `flags` may be an integer or
                one of: `&quot;r&quot;`, `&quot;rs&quot;`, `&quot;sr&quot;`, `&quot;r+&quot;`, `&quot;rs+&quot;`, `&quot;sr+&quot;`,
                `&quot;w&quot;`, `&quot;wx&quot;`, `&quot;xw&quot;`, `&quot;w+&quot;`, `&quot;wx+&quot;`, `&quot;xw+&quot;`, `&quot;a&quot;`,
                `&quot;ax&quot;`, `&quot;xa&quot;`, `&quot;a+&quot;`, `&quot;ax+&quot;`, or &quot;`xa+`&quot;.

                Returns (sync version): `integer` or `fail`

                Returns (async version): `uv_fs_t userdata`

                Note: On Windows, libuv uses `CreateFileW` and thus the file
                is always opened in binary mode. Because of this, the
                `O_BINARY` and `O_TEXT` flags are not supported.


uv.fs_read({fd}, {size} [, <A HREF="pattern.html#{offset}">{offset}</A> [, {callback}]])              *<A NAME="uv.fs_read()"></A><B>uv.fs_read()</B>*

                Parameters:
                - `fd`: `integer`
                - `size`: `integer`
                - `offset`: `integer` or `nil`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `data`: `string` or `nil`

                Equivalent to `preadv(2)`. Returns any data. An empty <A HREF="eval.html#string">string</A>
                indicates EOF.

                If `offset` is nil or omitted, <A HREF="motion.html#it">it</A> will default to `-1`, which
                indicates 'use and update the current file offset.'

                Note: When `offset` is &gt;= 0, the current file offset will not
                be updated by the read.

                Returns (sync version): `string` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_unlink({path} [, {callback}])                             *<A NAME="uv.fs_unlink()"></A><B>uv.fs_unlink()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `unlink(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_write({fd}, {data} [, <A HREF="pattern.html#{offset}">{offset}</A> [, {callback}]])            *<A NAME="uv.fs_write()"></A><B>uv.fs_write()</B>*

                Parameters:
                - `fd`: `integer`
                - `data`: `buffer`
                - `offset`: `integer` or `nil`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `bytes`: `integer` or `nil`

                Equivalent to `pwritev(2)`. Returns the number of bytes
                written.

                If `offset` is nil or omitted, <A HREF="motion.html#it">it</A> will default to `-1`, which
                indicates 'use and update the current file offset.'

                Note: When `offset` is &gt;= 0, the current file offset will not
                be updated by the write.

                Returns (sync version): `integer` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_mkdir({path}, {mode} [, {callback}])                       *<A NAME="uv.fs_mkdir()"></A><B>uv.fs_mkdir()</B>*

                Parameters:
                - `path`: `string`
                - `mode`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `mkdir(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_mkdtemp({template} [, {callback}])                       *<A NAME="uv.fs_mkdtemp()"></A><B>uv.fs_mkdtemp()</B>*

                Parameters:
                - `template`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `path`: `string` or `nil`

                Equivalent to `mkdtemp(3)`.

                Returns (sync version): `string` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_mkstemp({template} [, {callback}])                       *<A NAME="uv.fs_mkstemp()"></A><B>uv.fs_mkstemp()</B>*

                Parameters:
                - `template`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `fd`: `integer` or `nil`
                  - `path`: `string` or `nil`

                Equivalent to `mkstemp(3)`. Returns a temporary file handle
                and filename.

                Returns (sync version): `integer, string` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_rmdir({path} [, {callback}])                               *<A NAME="uv.fs_rmdir()"></A><B>uv.fs_rmdir()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `rmdir(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_scandir({path} [, {callback}])                           *<A NAME="uv.fs_scandir()"></A><B>uv.fs_scandir()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable`
                  - `err`: `nil` or `string`
                  - `success`: `uv_fs_t userdata` or `nil`

                Equivalent to `scandir(3)`, with a slightly different <A HREF="api.html#API">API</A>.
                Returns a handle that the user can pass to
                |<A HREF="uv.html">uv.fs_scandir_next()</A>|.

                Note: This function can be used synchronously or
                asynchronously. The request userdata is always synchronously
                returned regardless of whether a callback is provided and the
                same userdata is passed to the callback if <A HREF="motion.html#it">it</A> is provided.

                Returns: `uv_fs_t userdata` or `fail`


uv.fs_scandir_next({fs})                                  *<A NAME="uv.fs_scandir_next()"></A><B>uv.fs_scandir_next()</B>*

                Parameters:
                - `fs`: `uv_fs_t userdata`

                Called on a |<A HREF="#uv_fs_t">uv_fs_t</A>| returned by |<A HREF="uv.html">uv.fs_scandir()</A>| to get the
                next directory entry data <A HREF="motion.html#as">as</A> a `name, type` pair. When there
                are no more entries, `nil` is returned.

                Note: This function only has a synchronous version. See
                |<A HREF="uv.html">uv.fs_opendir()</A>| and its related <A HREF="eval.html#functions">functions</A> for an
                asynchronous version.

                Returns: `string, string` or `nil` or `fail`


uv.fs_stat({path} [, {callback}])                                 *<A NAME="uv.fs_stat()"></A><B>uv.fs_stat()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `stat`: `table` or `nil` (see below)

                Equivalent to `stat(2)`.

                Returns (sync version): `table` or `fail`
                - `dev` : `integer`
                - `mode` : `integer`
                - `nlink` : `integer`
                - `uid` : `integer`
                - `gid` : `integer`
                - `rdev` : `integer`
                - `ino` : `integer`
                - `size` : `integer`
                - `blksize` : `integer`
                - `blocks` : `integer`
                - `flags` : `integer`
                - `gen` : `integer`
                - `atime` : `table`
                  - `sec` : `integer`
                  - `nsec` : `integer`
                - `mtime` : `table`
                  - `sec` : `integer`
                  - `nsec` : `integer`
                - `ctime` : `table`
                  - `sec` : `integer`
                  - `nsec` : `integer`
                - `birthtime` : `table`
                  - `sec` : `integer`
                  - `nsec` : `integer`
                - `type` : `string`

                Returns (async version): `uv_fs_t userdata`


uv.fs_fstat({fd} [, {callback}])                                 *<A NAME="uv.fs_fstat()"></A><B>uv.fs_fstat()</B>*

                Parameters:
                - `fd`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `stat`: `table` or `nil` (see `uv.fs_stat`)

                Equivalent to `fstat(2)`.

                Returns (sync version): `table` or `fail` (see `uv.fs_stat`)

                Returns (async version): `uv_fs_t userdata`


uv.fs_lstat({path} [, {callback}])                               *<A NAME="uv.fs_lstat()"></A><B>uv.fs_lstat()</B>*

                Parameters:
                - `fd`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `stat`: `table` or `nil` (see `uv.fs_stat`)

                Equivalent to `lstat(2)`.

                Returns (sync version): `table` or `fail` (see |<A HREF="uv.html">uv.fs_stat()</A>|)

                Returns (async version): `uv_fs_t userdata`


uv.fs_rename({path}, {new_path} [, {callback}])                 *<A NAME="uv.fs_rename()"></A><B>uv.fs_rename()</B>*

                Parameters:
                - `path`: `string`
                - `new_path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `rename(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_fsync({fd} [, {callback}])                                 *<A NAME="uv.fs_fsync()"></A><B>uv.fs_fsync()</B>*

                Parameters:
                - `fd`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `fsync(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_fdatasync({fd} [, {callback}])                         *<A NAME="uv.fs_fdatasync()"></A><B>uv.fs_fdatasync()</B>*

                Parameters:
                - `fd`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `fdatasync(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_ftruncate({fd}, <A HREF="pattern.html#{offset}">{offset}</A> [, {callback}])               *<A NAME="uv.fs_ftruncate()"></A><B>uv.fs_ftruncate()</B>*

                Parameters:
                - `fd`: `integer`
                - `offset`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `ftruncate(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


                                                              *<A NAME="uv.fs_sendfile()"></A><B>uv.fs_sendfile()</B>*
uv.fs_sendfile({out_fd}, {in_fd}, {in_offset}, {size} [, {callback}])

                Parameters:
                - `out_fd`: `integer`
                - `in_fd`: `integer`
                - `in_offset`: `integer`
                - `size`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `bytes`: `integer` or `nil`

                Limited equivalent to `sendfile(2)`. Returns the number of
                bytes written.

                Returns (sync version): `integer` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_access({path}, {mode} [, {callback}])                     *<A NAME="uv.fs_access()"></A><B>uv.fs_access()</B>*

                Parameters:
                - `path`: `string`
                - `mode`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `permission`: `boolean` or `nil`

                Equivalent to `access(2)` on Unix. Windows uses
                `GetFileAttributesW()`. Access `mode` can be an integer or a
                <A HREF="eval.html#string">string</A> containing `&quot;R&quot;` or `&quot;W&quot;` or `&quot;X&quot;`. Returns `true` or
                `false` indicating access permission.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_chmod({path}, {mode} [, {callback}])                       *<A NAME="uv.fs_chmod()"></A><B>uv.fs_chmod()</B>*

                Parameters:
                - `path`: `string`
                - `mode`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `chmod(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_fchmod({fd}, {mode} [, {callback}])                       *<A NAME="uv.fs_fchmod()"></A><B>uv.fs_fchmod()</B>*

                Parameters:
                - `fd`: `integer`
                - `mode`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `fchmod(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_utime({path}, {atime}, {mtime} [, {callback}])             *<A NAME="uv.fs_utime()"></A><B>uv.fs_utime()</B>*

                Parameters:
                - `path`: `string`
                - `atime`: `number`
                - `mtime`: `number`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `utime(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_futime({fd}, {atime}, {mtime} [, {callback}])             *<A NAME="uv.fs_futime()"></A><B>uv.fs_futime()</B>*

                Parameters:
                - `fd`: `integer`
                - `atime`: `number`
                - `mtime`: `number`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `futime(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_lutime({path}, {atime}, {mtime} [, {callback}])           *<A NAME="uv.fs_lutime()"></A><B>uv.fs_lutime()</B>*

                Parameters:
                - `path`: `string`
                - `atime`: `number`
                - `mtime`: `number`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `lutime(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_link({path}, {new_path} [, {callback}])                     *<A NAME="uv.fs_link()"></A><B>uv.fs_link()</B>*

                Parameters:
                - `path`: `string`
                - `new_path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `link(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_symlink({path}, {new_path} [, {flags} [, {callback}]])   *<A NAME="uv.fs_symlink()"></A><B>uv.fs_symlink()</B>*

                Parameters:
                - `path`: `string`
                - `new_path`: `string`
                - `flags`: `table`, `integer`, or `nil`
                  - `dir`: `boolean`
                  - `junction`: `boolean`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `symlink(2)`. If the `flags` parameter is
                omitted, then the 3rd parameter will be treated <A HREF="motion.html#as">as</A> the
                `callback`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_readlink({path} [, {callback}])                         *<A NAME="uv.fs_readlink()"></A><B>uv.fs_readlink()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `path`: `string` or `nil`

                Equivalent to `readlink(2)`.

                Returns (sync version): `string` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_realpath({path} [, {callback}])                         *<A NAME="uv.fs_realpath()"></A><B>uv.fs_realpath()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `path`: `string` or `nil`

                Equivalent to `realpath(3)`.

                Returns (sync version): `string` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_chown({path}, {uid}, {gid} [, {callback}])                 *<A NAME="uv.fs_chown()"></A><B>uv.fs_chown()</B>*

                Parameters:
                - `path`: `string`
                - `uid`: `integer`
                - `gid`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `chown(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_fchown({fd}, {uid}, {gid} [, {callback}])                 *<A NAME="uv.fs_fchown()"></A><B>uv.fs_fchown()</B>*

                Parameters:
                - `fd`: `integer`
                - `uid`: `integer`
                - `gid`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `fchown(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_lchown({fd}, {uid}, {gid} [, {callback}])                 *<A NAME="uv.fs_lchown()"></A><B>uv.fs_lchown()</B>*

                Parameters:
                - `fd`: `integer`
                - `uid`: `integer`
                - `gid`: `integer`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Equivalent to `lchown(2)`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_copyfile({path}, {new_path} [, {flags} [, {callback}]]) *<A NAME="uv.fs_copyfile()"></A><B>uv.fs_copyfile()</B>*

                Parameters:
                - `path`: `string`
                - `new_path`: `string`
                - `flags`: `table`, `integer`, or `nil`
                  - `excl`: `boolean`
                  - `ficlone`: `boolean`
                  - `ficlone_force`: `boolean`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Copies a file from path to new_path. If the `flags` parameter
                is omitted, then the 3rd parameter will be treated <A HREF="motion.html#as">as</A> the
                `callback`.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_opendir({path} [, {callback} [, {entries}]])             *<A NAME="uv.fs_opendir()"></A><B>uv.fs_opendir()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `dir`: `luv_dir_t userdata` or `nil`
                - `entries`: `integer` or `nil`

                Opens path <A HREF="motion.html#as">as</A> a directory stream. Returns a handle that the
                user can pass to |<A HREF="uv.html">uv.fs_readdir()</A>|. The `entries` parameter
                defines the maximum number of entries that should be returned
                by each call to |<A HREF="uv.html">uv.fs_readdir()</A>|.

                Returns (sync version): `luv_dir_t userdata` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_readdir({dir} [, {callback}])                            *<A NAME="uv.fs_readdir()"></A><B>uv.fs_readdir()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `dir:readdir([callback])`

                Parameters:
                - `dir`: `luv_dir_t userdata`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `entries`: `table` or `nil` (see below)

                Iterates over the directory stream `luv_dir_t` returned by a
                successful |<A HREF="uv.html">uv.fs_opendir()</A>| call. A table of data tables is
                returned where the number of entries `n` is equal to or <A HREF="various.html#less">less</A>
                than the `entries` parameter used in the associated
                |<A HREF="uv.html">uv.fs_opendir()</A>| call.

                Returns (sync version): `table` or `fail`
                - `[1, 2, 3, <A HREF="userfunc.html#...">...</A>, n]` : `table`
                  - `name` : `string`
                  - `type` : `string`

                Returns (async version): `uv_fs_t userdata`


uv.fs_closedir({dir} [, {callback}])                          *<A NAME="uv.fs_closedir()"></A><B>uv.fs_closedir()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `dir:closedir([callback])`

                Parameters:
                - `dir`: `luv_dir_t userdata`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `success`: `boolean` or `nil`

                Closes a directory stream returned by a successful
                |<A HREF="uv.html">uv.fs_opendir()</A>| call.

                Returns (sync version): `boolean` or `fail`

                Returns (async version): `uv_fs_t userdata`


uv.fs_statfs({path} [, {callback}])                             *<A NAME="uv.fs_statfs()"></A><B>uv.fs_statfs()</B>*

                Parameters:
                - `path`: `string`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `table` or `nil` (see below)

                Equivalent to `statfs(2)`.

                Returns `table` or `nil`
                - `type` : `integer`
                - `bsize` : `integer`
                - `blocks` : `integer`
                - `bfree` : `integer`
                - `bavail` : `integer`
                - `files` : `integer`
                - `ffree` : `integer`

==============================================================================

THREAD POOL WORK SCHEDULING                    *<A NAME="luv-thread-pool-work-scheduling"></A><B>luv-thread-pool-work-scheduling</B>*

Libuv provides a threadpool which can be used to run user code and get
notified in the loop thread. This threadpool is internally used to run all
file system operations, <A HREF="motion.html#as">as</A> well <A HREF="motion.html#as">as</A> `getaddrinfo` and `getnameinfo` requests.

   
<B>    local function work_callback(a, b)</B>
<B>      return a + b</B>
<B>    end</B>

<B>    local function after_work_callback(c)</B>
<B>      print("The result is: " .. c)</B>
<B>    end</B>

<B>    local work = uv.new_work(work_callback, after_work_callback)</B>

<B>    work:queue(1, 2)</B>

<B>    -- output: "The result is: 3"</B>
 


uv.new_work({work_callback}, {after_work_callback})              *<A NAME="uv.new_work()"></A><B>uv.new_work()</B>*

                Parameters:
                - `work_callback`: `function`
                  - `...`: `threadargs` passed to/from
                    `uv.queue_work(work_ctx, ...)`
                - `after_work_callback`: `function`
                  - `...`: `threadargs` returned from `work_callback`

                Creates and initializes a new `luv_work_ctx_t` (not
                `uv_work_t`). Returns the <A HREF="lua.html#Lua">Lua</A> userdata wrapping <A HREF="motion.html#it">it</A>.

                Returns: `luv_work_ctx_t userdata`


uv.queue_work({work_ctx}, {...})                               *<A NAME="uv.queue_work()"></A><B>uv.queue_work()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `work_ctx:queue(...)`

                Parameters:
                - `work_ctx`: `luv_work_ctx_t userdata`
                - `...`: `threadargs`

                Queues a work request which will run `work_callback` in a new
                <A HREF="lua.html#Lua">Lua</A> state in a thread from the threadpool with any additional
                arguments from `...`. Values returned from `work_callback` are
                passed to `after_work_callback`, which is called in the main
                loop thread.

                Returns: `boolean` or `fail`

==============================================================================

DNS UTILITY FUNCTIONS                                *<A NAME="luv-dns-utility-functions"></A><B>luv-dns-utility-functions</B>*


uv.getaddrinfo({host}, {service} [, {hints} [, {callback}]])  *<A NAME="uv.getaddrinfo()"></A><B>uv.getaddrinfo()</B>*

                Parameters:
                - `host`: `string` or `nil`
                - `service`: `string` or `nil`
                - `hints`: `table` or `nil`
                  - `family`: `string` or `integer` or `nil`
                  - `socktype`: `string` or `integer` or `nil`
                  - `protocol`: `string` or `integer` or `nil`
                  - `addrconfig`: `boolean` or `nil`
                  - `v4mapped`: `boolean` or `nil`
                  - `all`: `boolean` or `nil`
                  - `numerichost`: `boolean` or `nil`
                  - `passive`: `boolean` or `nil`
                  - `numericserv`: `boolean` or `nil`
                  - `canonname`: `boolean` or `nil`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `addresses`: `table` or `nil` (see below)

                Equivalent to `getaddrinfo(3)`. Either `node` or `service` may
                be `nil` but not both.

                Valid hint strings for the keys that take a <A HREF="eval.html#string">string</A>:
                - `family`: `&quot;unix&quot;`, `&quot;inet&quot;`, `&quot;inet6&quot;`, `&quot;ipx&quot;`,
                  `&quot;netlink&quot;`, `&quot;x25&quot;`, `&quot;ax25&quot;`, `&quot;atmpvc&quot;`, `&quot;appletalk&quot;`,
                  or `&quot;packet&quot;`
                - `socktype`: `&quot;stream&quot;`, `&quot;dgram&quot;`, `&quot;raw&quot;`, `&quot;rdm&quot;`, or
                  `&quot;seqpacket&quot;`
                - `protocol`: will be looked up using the `getprotobyname(3)`
                  function (examples: `&quot;ip&quot;`, `&quot;icmp&quot;`, `&quot;tcp&quot;`, `&quot;udp&quot;`, etc)

                Returns (sync version): `table` or `fail`
                - `[1, 2, 3, <A HREF="userfunc.html#...">...</A>, n]` : `table`
                  - `addr` : `string`
                  - `family` : `string`
                  - `port` : `integer` or `nil`
                  - `socktype` : `string`
                  - `protocol` : `string`
                  - `canonname` : `string` or `nil`

                Returns (async version): `uv_getaddrinfo_t userdata` or `fail`


uv.getnameinfo({address} [, {callback}])                      *<A NAME="uv.getnameinfo()"></A><B>uv.getnameinfo()</B>*

                Parameters:
                - `address`: `table`
                  - `ip`: `string` or `nil`
                  - `port`: `integer` or `nil`
                  - `family`: `string` or `integer` or `nil`
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `host`: `string` or `nil`
                  - `service`: `string` or `nil`

                Equivalent to `getnameinfo(3)`.

                When specified, `family` must be one of `&quot;unix&quot;`, `&quot;inet&quot;`,
                `&quot;inet6&quot;`, `&quot;ipx&quot;`, `&quot;netlink&quot;`, `&quot;x25&quot;`, `&quot;ax25&quot;`,
                `&quot;atmpvc&quot;`, `&quot;appletalk&quot;`, or `&quot;packet&quot;`.

                Returns (sync version): `string, string` or `fail`

                Returns (async version): `uv_getnameinfo_t userdata` or `fail`

==============================================================================

THREADING AND SYNCHRONIZATION UTILITIES *<A NAME="luv-threading-and-synchronization-utilities"></A><B>luv-threading-and-synchronization-utilities</B>*

Libuv provides cross-platform implementations for multiple threading an
synchronization primitives. The <A HREF="api.html#API">API</A> largely follows the pthreads <A HREF="api.html#API">API</A>.


uv.new_thread([{options}, ] {entry}, {...})                    *<A NAME="uv.new_thread()"></A><B>uv.new_thread()</B>*

                Parameters:
                - `options`: `table` or `nil`
                  - `stack_size`: `integer` or `nil`
                - `entry`: `function`
                - `...`: `threadargs` passed to `entry`

                Creates and initializes a `luv_thread_t` (not `uv_thread_t`).
                Returns the <A HREF="lua.html#Lua">Lua</A> userdata wrapping <A HREF="motion.html#it">it</A> and asynchronously
                executes `entry`, which can be either a <A HREF="lua.html#Lua">Lua</A> function or a <A HREF="lua.html#Lua">Lua</A>
                function dumped to a <A HREF="eval.html#string">string</A>. Additional arguments `...` are
                passed to the `entry` function and an optional `options` table
                may be provided. Currently accepted `option` fields are
                `stack_size`.

                Returns: `luv_thread_t userdata` or `fail`


uv.thread_equal({thread}, {other_thread})                    *<A NAME="uv.thread_equal()"></A><B>uv.thread_equal()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `thread:equal(other_thread)`

                Parameters:
                - `thread`: `luv_thread_t userdata`
                - `other_thread`: `luv_thread_t userdata`

                Returns a <A HREF="options.html#boolean">boolean</A> indicating whether two threads are the same.
                This function is equivalent to the `__eq` metamethod.

                Returns: `boolean`


<A HREF="#uv.thread_self()">uv.thread_self()</A>                                              *<A NAME="uv.thread_self()"></A><B>uv.thread_self()</B>*

                Returns the handle for the thread in which this is called.

                Returns: `luv_thread_t`


uv.thread_join({thread})                                      *<A NAME="uv.thread_join()"></A><B>uv.thread_join()</B>*

                <A HREF="change.html#&gt;">&gt;</A> <A HREF="eval.html#method">method</A> form `thread:join()`

                Parameters:
                - `thread`: `luv_thread_t userdata`

                Waits for the `thread` to finish executing its entry function.

                Returns: `boolean` or `fail`


uv.sleep({msec})                                                    *<A NAME="uv.sleep()"></A><B>uv.sleep()</B>*

                Parameters:
                - `msec`: `integer`

                Pauses the thread in which this is called for a number of
                milliseconds.

                Returns: Nothing.

==============================================================================

MISCELLANEOUS UTILITIES                            *<A NAME="luv-miscellaneous-utilities"></A><B>luv-miscellaneous-utilities</B>*


<A HREF="#uv.exepath()">uv.exepath()</A>                                                      *<A NAME="uv.exepath()"></A><B>uv.exepath()</B>*

                Returns the executable path.

                Returns: `string` or `fail`


<A HREF="#uv.cwd()">uv.cwd()</A>                                                              *<A NAME="uv.cwd()"></A><B>uv.cwd()</B>*

                Returns the current working directory.

                Returns: `string` or `fail`


uv.chdir({cwd})                                                     *<A NAME="uv.chdir()"></A><B>uv.chdir()</B>*

                Parameters:
                - `cwd`: `string`

                Sets the current working directory with the <A HREF="eval.html#string">string</A> `cwd`.

                Returns: `0` or `fail`


<A HREF="#uv.get_process_title()">uv.get_process_title()</A>                                  *<A NAME="uv.get_process_title()"></A><B>uv.get_process_title()</B>*

                Returns the title of the current process.

                Returns: `string` or `fail`


uv.set_process_title({title})                           *<A NAME="uv.set_process_title()"></A><B>uv.set_process_title()</B>*

                Parameters:
                - `title`: `string`

                Sets the title of the current process with the <A HREF="eval.html#string">string</A> `title`.

                Returns: `0` or `fail`


<A HREF="#uv.get_total_memory()">uv.get_total_memory()</A>                                    *<A NAME="uv.get_total_memory()"></A><B>uv.get_total_memory()</B>*

                Returns the current total system memory in bytes.

                Returns: `number`


<A HREF="#uv.get_free_memory()">uv.get_free_memory()</A>                                      *<A NAME="uv.get_free_memory()"></A><B>uv.get_free_memory()</B>*

                Returns the current free system memory in bytes.

                Returns: `number`


<A HREF="#uv.get_constrained_memory()">uv.get_constrained_memory()</A>                        *<A NAME="uv.get_constrained_memory()"></A><B>uv.get_constrained_memory()</B>*

                Gets the amount of memory available to the process in bytes
                based on <A HREF="vi_diff.html#limits">limits</A> imposed by the OS. If there is no such
                constraint, or the constraint is unknown, 0 is returned. Note
                that <A HREF="motion.html#it">it</A> is not unusual for this value to be <A HREF="various.html#less">less</A> than or
                greater than the total system memory.

                Returns: `number`


<A HREF="#uv.resident_set_memory()">uv.resident_set_memory()</A>                              *<A NAME="uv.resident_set_memory()"></A><B>uv.resident_set_memory()</B>*

                Returns the resident set size (RSS) for the current process.

                Returns: `integer` or `fail`


<A HREF="#uv.getrusage()">uv.getrusage()</A>                                                  *<A NAME="uv.getrusage()"></A><B>uv.getrusage()</B>*

                Returns the resource usage.

                Returns: `table` or `fail`
                - `utime` : `table` (user CPU time used)
                  - `sec` : `integer`
                  - `usec` : `integer`
                - `stime` : `table` (system CPU time used)
                  - `sec` : `integer`
                  - `usec` : `integer`
                - `maxrss` : `integer` (maximum resident set size)
                - `ixrss` : `integer` (integral shared memory size)
                - `idrss` : `integer` (integral unshared data size)
                - `isrss` : `integer` (integral unshared stack size)
                - `minflt` : `integer` (page reclaims (soft page faults))
                - `majflt` : `integer` (page faults (hard page faults))
                - `nswap` : `integer` (swaps)
                - `inblock` : `integer` (block input operations)
                - `oublock` : `integer` (block output operations)
                - `msgsnd` : `integer` (IPC <A HREF="message.html#messages">messages</A> sent)
                - `msgrcv` : `integer` (IPC <A HREF="message.html#messages">messages</A> received)
                - `nsignals` : `integer` (signals received)
                - `nvcsw` : `integer` (voluntary <A HREF="repeat.html#context">context</A> switches)
                - `nivcsw` : `integer` (involuntary <A HREF="repeat.html#context">context</A> switches)


<A HREF="#uv.available_parallelism()">uv.available_parallelism()</A>                          *<A NAME="uv.available_parallelism()"></A><B>uv.available_parallelism()</B>*

                Returns an estimate of the default amount of parallelism a
                program should use. Always returns a non-zero value.

                On Linux, inspects the calling thread’s CPU affinity mask to
                determine if <A HREF="motion.html#it">it</A> has been pinned to specific CPUs.

                On Windows, the available parallelism may be underreported on
                systems with more than 64 logical CPUs.

                On other platforms, reports the number of CPUs that the
                operating system considers to be online.

                Returns: `integer`


<A HREF="#uv.cpu_info()">uv.cpu_info()</A>                                                    *<A NAME="uv.cpu_info()"></A><B>uv.cpu_info()</B>*

                Returns information about the CPU(s) on the system <A HREF="motion.html#as">as</A> a table
                of tables for each CPU found.

                Returns: `table` or `fail`
                - `[1, 2, 3, <A HREF="userfunc.html#...">...</A>, n]` : `table`
                  - `model` : `string`
                  - `speed` : `number`
                  - `times` : `table`
                    - `user` : `number`
                    - `nice` : `number`
                    - `sys` : `number`
                    - `idle` : `number`
                    - `irq` : `number`


<A HREF="#uv.getpid()">uv.getpid()</A>                                                        *<A NAME="uv.getpid()"></A><B>uv.getpid()</B>*

                DEPRECATED: Please use |<A HREF="uv.html">uv.os_getpid()</A>| instead.


<A HREF="#uv.getuid()">uv.getuid()</A>                                                        *<A NAME="uv.getuid()"></A><B>uv.getuid()</B>*

                Returns the user ID of the process.

                Returns: `integer`

                Note: This is not a libuv function and is not supported on
                Windows.


<A HREF="#uv.getgid()">uv.getgid()</A>                                                        *<A NAME="uv.getgid()"></A><B>uv.getgid()</B>*

                Returns the group ID of the process.

                Returns: `integer`

                Note: This is not a libuv function and is not supported on
                Windows.


uv.setuid({id})                                                    *<A NAME="uv.setuid()"></A><B>uv.setuid()</B>*

                Parameters:
                - `id`: `integer`

                Sets the user ID of the process with the integer `id`.

                Returns: Nothing.

                Note: This is not a libuv function and is not supported on
                Windows.


uv.setgid({id})                                                    *<A NAME="uv.setgid()"></A><B>uv.setgid()</B>*

                Parameters:
                - `id`: `integer`

                Sets the group ID of the process with the integer `id`.

                Returns: Nothing.

                Note: This is not a libuv function and is not supported on
                Windows.


<A HREF="#uv.hrtime()">uv.hrtime()</A>                                                        *<A NAME="uv.hrtime()"></A><B>uv.hrtime()</B>*

                Returns a current high-resolution time in nanoseconds <A HREF="motion.html#as">as</A> a
                number. This is relative to an arbitrary time in the past. It
                is not related to the time of day and therefore not subject to
                clock drift. The primary use is for measuring time between
                intervals.

                Returns: `number`


<A HREF="#uv.uptime()">uv.uptime()</A>                                                        *<A NAME="uv.uptime()"></A><B>uv.uptime()</B>*

                Returns the current system uptime in seconds.

                Returns: `number` or `fail`


<A HREF="#uv.print_all_handles()">uv.print_all_handles()</A>                                  *<A NAME="uv.print_all_handles()"></A><B>uv.print_all_handles()</B>*

                Prints all handles associated with the main loop to stderr.
                The format is `[flags] handle-type handle-address` . Flags are
                `R` for referenced, `A` for active and `I` for internal.

                Returns: Nothing.

                Note: This is not available on Windows.

                WARNING: This function is meant for ad hoc debugging, there
                are no API/ABI stability guarantees.


<A HREF="#uv.print_active_handles()">uv.print_active_handles()</A>                            *<A NAME="uv.print_active_handles()"></A><B>uv.print_active_handles()</B>*

                The same <A HREF="motion.html#as">as</A> |<A HREF="uv.html">uv.print_all_handles()</A>| except only active
                handles are printed.

                Returns: Nothing.

                Note: This is not available on Windows.

                WARNING: This function is meant for ad hoc debugging, there
                are no API/ABI stability guarantees.


uv.guess_handle({fd})                                        *<A NAME="uv.guess_handle()"></A><B>uv.guess_handle()</B>*

                Parameters:
                - `fd`: `integer`

                Used to detect what type of stream should be used with a given
                file descriptor `fd`. Usually this will be used during
                <A HREF="starting.html#initialization">initialization</A> to guess the type of the stdio streams.

                Returns: `string`


<A HREF="#uv.gettimeofday()">uv.gettimeofday()</A>                                            *<A NAME="uv.gettimeofday()"></A><B>uv.gettimeofday()</B>*

                Cross-platform implementation of `gettimeofday(2)`. Returns
                the seconds and microseconds of a unix time <A HREF="motion.html#as">as</A> a pair.

                Returns: `integer, integer` or `fail`


<A HREF="#uv.interface_addresses()">uv.interface_addresses()</A>                              *<A NAME="uv.interface_addresses()"></A><B>uv.interface_addresses()</B>*

                Returns address information about the <A HREF="pi_netrw.html#network">network</A> interfaces on
                the system in a table. Each table key is the name of the
                interface while each associated value is an array of address
                information where fields are `ip`, `family`, `netmask`,
                `internal`, and `mac`.

                Returns: `table`
                - `[name(s)]` : `table`
                  - `ip` : `string`
                  - `family` : `string`
                  - `netmask` : `string`
                  - `internal` : `boolean`
                  - `mac` : `string`


uv.if_indextoname({ifindex})                               *<A NAME="uv.if_indextoname()"></A><B>uv.if_indextoname()</B>*

                Parameters:
                - `ifindex`: `integer`

                IPv6-capable implementation of `if_indextoname(3)`.

                Returns: `string` or `fail`


uv.if_indextoiid({ifindex})                                 *<A NAME="uv.if_indextoiid()"></A><B>uv.if_indextoiid()</B>*

                Parameters:
                - `ifindex`: `integer`

                Retrieves a <A HREF="pi_netrw.html#network">network</A> interface identifier suitable for use in
                an IPv6 scoped address. On Windows, returns the numeric
                `ifindex` <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>. On all other platforms,
                |<A HREF="uv.html">uv.if_indextoname()</A>| is used.

                Returns: `string` or `fail`


<A HREF="#uv.loadavg()">uv.loadavg()</A>                                                      *<A NAME="uv.loadavg()"></A><B>uv.loadavg()</B>*

                Returns the load average <A HREF="motion.html#as">as</A> a triad. Not supported on Windows.

                Returns: `number, number, number`


<A HREF="#uv.os_uname()">uv.os_uname()</A>                                                    *<A NAME="uv.os_uname()"></A><B>uv.os_uname()</B>*

                Returns system information.

                Returns: `table`
                - `sysname` : `string`
                - `release` : `string`
                - `version` : `string`
                - `machine` : `string`


<A HREF="#uv.os_gethostname()">uv.os_gethostname()</A>                                        *<A NAME="uv.os_gethostname()"></A><B>uv.os_gethostname()</B>*

                Returns the hostname.

                Returns: `string`


uv.os_getenv({name} [, {size}])                                 *<A NAME="uv.os_getenv()"></A><B>uv.os_getenv()</B>*

                Parameters:
                - `name`: `string`
                - `size`: `integer` (default = `LUAL_BUFFERSIZE`)

                Returns the environment variable specified by `name` <A HREF="motion.html#as">as</A>
                <A HREF="eval.html#string">string</A>. The internal buffer size can be set by defining
                `size`. If omitted, `LUAL_BUFFERSIZE` is used. If the
                environment variable exceeds the storage available in the
                internal buffer, `ENOBUFS` is returned. If no matching
                environment variable exists, `ENOENT` is returned.

                Returns: `string` or `fail`

                WARNING: This function is not thread safe.


uv.os_setenv({name}, {value})                                   *<A NAME="uv.os_setenv()"></A><B>uv.os_setenv()</B>*

                Parameters:
                - `name`: `string`
                - `value`: `string`

                Sets the environmental variable specified by `name` with the
                <A HREF="eval.html#string">string</A> `value`.

                Returns: `boolean` or `fail`

                WARNING: This function is not thread safe.


<A HREF="#uv.os_unsetenv()">uv.os_unsetenv()</A>                                              *<A NAME="uv.os_unsetenv()"></A><B>uv.os_unsetenv()</B>*

                Returns: `boolean` or `fail`

                WARNING: This function is not thread safe.


<A HREF="#uv.os_environ()">uv.os_environ()</A>                                                *<A NAME="uv.os_environ()"></A><B>uv.os_environ()</B>*

                Returns all environmental <A HREF="eval.html#variables">variables</A> <A HREF="motion.html#as">as</A> a dynamic table of
                names associated with their corresponding values.

                Returns: `table`

                WARNING: This function is not thread safe.


<A HREF="#uv.os_homedir()">uv.os_homedir()</A>                                                *<A NAME="uv.os_homedir()"></A><B>uv.os_homedir()</B>*

                Returns: `string` or `fail`

                WARNING: This function is not thread safe.


<A HREF="#uv.os_tmpdir()">uv.os_tmpdir()</A>                                                  *<A NAME="uv.os_tmpdir()"></A><B>uv.os_tmpdir()</B>*

                Returns: `string` or `fail`

                WARNING: This function is not thread safe.


<A HREF="#uv.os_get_passwd()">uv.os_get_passwd()</A>                                          *<A NAME="uv.os_get_passwd()"></A><B>uv.os_get_passwd()</B>*

                Returns password file information.

                Returns: `table`
                - `username` : `string`
                - `uid` : `integer`
                - `gid` : `integer`
                - `shell` : `string`
                - `homedir` : `string`


<A HREF="#uv.os_getpid()">uv.os_getpid()</A>                                                  *<A NAME="uv.os_getpid()"></A><B>uv.os_getpid()</B>*

                Returns the current process ID.

                Returns: `number`


<A HREF="#uv.os_getppid()">uv.os_getppid()</A>                                                *<A NAME="uv.os_getppid()"></A><B>uv.os_getppid()</B>*

                Returns the parent process ID.

                Returns: `number`


uv.os_getpriority({pid})                                   *<A NAME="uv.os_getpriority()"></A><B>uv.os_getpriority()</B>*

                Parameters:
                - `pid`: `integer`

                Returns the scheduling priority of the process specified by
                `pid`.

                Returns: `number` or `fail`


uv.os_setpriority({pid}, {priority})                       *<A NAME="uv.os_setpriority()"></A><B>uv.os_setpriority()</B>*

                Parameters:
                - `pid`: `integer`
                - `priority`: `integer`

                Sets the scheduling priority of the process specified by
                `pid`. The `priority` range is between -20 (high priority) and
                19 (low priority).

                Returns: `boolean` or `fail`


uv.random({len}, {flags} [, {callback}])                           *<A NAME="uv.random()"></A><B>uv.random()</B>*

                Parameters:
                - `len`: `integer`
                - `flags`: `nil` (see below)
                - `callback`: `callable` (async version) or `nil` (sync
                  version)
                  - `err`: `nil` or `string`
                  - `bytes`: `string` or `nil`

                Fills a <A HREF="eval.html#string">string</A> of length `len` with cryptographically strong
                random bytes acquired from the system CSPRNG. `flags` is
                reserved for future extension and must currently be `nil` or
                `0` or `{}`.

                Short reads are not possible. When <A HREF="various.html#less">less</A> than `len` random
                bytes are available, a non-zero error value is returned or
                passed to the callback. If the callback is omitted, this
                function is completed synchronously.

                The synchronous version may block indefinitely when not enough
                entropy is available. The asynchronous version may not ever
                finish when the system is low on entropy.

                Returns (sync version): `string` or `fail`

                Returns (async version): `0` or `fail`


uv.translate_sys_error({errcode})                     *<A NAME="uv.translate_sys_error()"></A><B>uv.translate_sys_error()</B>*

                Parameters:
                - `errcode`: `integer`

                Returns the libuv error message and error name (both in <A HREF="eval.html#string">string</A>
                form, see `err` and `name` in |<A HREF="#luv-error-handling">luv-error-handling</A>|) equivalent
                to the given platform dependent error code: POSIX error codes
                on Unix (the ones stored in errno), and Win32 error codes on
                Windows (those returned by GetLastError() or
                WSAGetLastError()).

                Returns: `string, string` or `nil`

==============================================================================

METRICS OPERATIONS                                      *<A NAME="luv-metrics-operations"></A><B>luv-metrics-operations</B>*


<A HREF="#uv.metrics_idle_time()">uv.metrics_idle_time()</A>                                  *<A NAME="uv.metrics_idle_time()"></A><B>uv.metrics_idle_time()</B>*

                Retrieve the amount of time the event loop has been idle in
                the kernel’s event <A HREF="provider.html#provider">provider</A> (e.g. `epoll_wait`). The call is
                thread safe.

                The return value is the accumulated time spent idle in the
                kernel’s event <A HREF="provider.html#provider">provider</A> starting from when the |<A HREF="#uv_loop_t">uv_loop_t</A>| was
                configured to collect the idle time.

                Note: The event loop will not begin accumulating the event
                provider’s idle time until calling `loop_configure` with
                `&quot;metrics_idle_time&quot;`.

                Returns: `number`

==============================================================================

CREDITS                                                            *<A NAME="luv-credits"></A><B>luv-credits</B>*

This document is a reformatted version of the LUV documentation, based on
commit c51e705 (5 May 2022) of the <A HREF="#luv">luv</A> repository
https://github.com/luvit/luv/commit/c51e7052ec4f0a25058f70c1b4ee99dd36180e59.

Included from https://github.com/nanotee/luv-vimdocs with kind permission.


<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
