


<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>pytest fixtures: explicit, modular, scalable &#8212; pytest documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/pygments_pytest.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.png"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Marking test functions with attributes" href="mark.html" />
    <link rel="prev" title="The writing and reporting of assertions in tests" href="assert.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = './';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mark.html" title="Marking test functions with attributes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="assert.html" title="The writing and reporting of assertions in tests"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">pytest-6.2</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pytest fixtures: explicit, modular, scalable</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="pytest-fixtures-explicit-modular-scalable">
<span id="fixture-functions"></span><span id="fixtures"></span><span id="fixture"></span><h1>pytest fixtures: explicit, modular, scalable<a class="headerlink" href="#pytest-fixtures-explicit-modular-scalable" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Test_fixture#Software">Software test fixtures</a> initialize test functions.  They provide a
fixed baseline so that tests execute reliably and produce consistent,
repeatable, results.  Initialization may setup services, state, or
other operating environments.  These are accessed by test functions
through arguments; for each fixture used by a test function there is
typically a parameter (named after the fixture) in the test function’s
definition.</p>
<p>pytest fixtures offer dramatic improvements over the classic xUnit
style of setup/teardown functions:</p>
<ul class="simple">
<li><p>fixtures have explicit names and are activated by declaring their use
from test functions, modules, classes or whole projects.</p></li>
<li><p>fixtures are implemented in a modular manner, as each fixture name
triggers a <em>fixture function</em> which can itself use other fixtures.</p></li>
<li><p>fixture management scales from simple unit to complex
functional testing, allowing to parametrize fixtures and tests according
to configuration and component options, or to re-use fixtures
across function, class, module or whole test session scopes.</p></li>
<li><p>teardown logic can be easily, and safely managed, no matter how many fixtures
are used, without the need to carefully handle errors by hand or micromanage
the order that cleanup steps are added.</p></li>
</ul>
<p>In addition, pytest continues to support <a class="reference internal" href="xunit_setup.html#xunitsetup"><span class="std std-ref">classic xunit-style setup</span></a>.  You can mix
both styles, moving incrementally from classic to new style, as you
prefer.  You can also start out from existing <a class="reference internal" href="unittest.html#unittest-testcase"><span class="std std-ref">unittest.TestCase
style</span></a> or <a class="reference internal" href="nose.html#nosestyle"><span class="std std-ref">nose based</span></a> projects.</p>
<p><a class="reference internal" href="reference.html#fixtures-api"><span class="std std-ref">Fixtures</span></a> are defined using the
<a class="reference internal" href="reference.html#pytest-fixture-api"><span class="std std-ref">&#64;pytest.fixture</span></a> decorator, <a class="reference internal" href="#funcargs"><span class="std std-ref">described
below</span></a>. Pytest has useful built-in fixtures, listed here
for reference:</p>
<blockquote>
<div><dl class="simple">
<dt><a class="reference internal" href="reference.html#std-fixture-capfd"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">capfd</span></code></a></dt><dd><p>Capture, as text, output to file descriptors <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-capfdbinary"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">capfdbinary</span></code></a></dt><dd><p>Capture, as bytes, output to file descriptors <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-caplog"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">caplog</span></code></a></dt><dd><p>Control logging and access log entries.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-capsys"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">capsys</span></code></a></dt><dd><p>Capture, as text, output to <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-capsysbinary"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">capsysbinary</span></code></a></dt><dd><p>Capture, as bytes, output to <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-cache"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">cache</span></code></a></dt><dd><p>Store and retrieve values across pytest runs.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-doctest_namespace"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">doctest_namespace</span></code></a></dt><dd><p>Provide a dict injected into the docstests namespace.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-monkeypatch"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">monkeypatch</span></code></a></dt><dd><p>Temporarily modify classes, functions, dictionaries,
<code class="docutils literal notranslate"><span class="pre">os.environ</span></code>, and other objects.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-pytestconfig"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">pytestconfig</span></code></a></dt><dd><p>Access to configuration values, pluginmanager and plugin hooks.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-record_property"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">record_property</span></code></a></dt><dd><p>Add extra properties to the test.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-record_testsuite_property"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">record_testsuite_property</span></code></a></dt><dd><p>Add extra properties to the test suite.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-recwarn"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">recwarn</span></code></a></dt><dd><p>Record warnings emitted by test functions.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-request"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">request</span></code></a></dt><dd><p>Provide information on the executing test function.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-testdir"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">testdir</span></code></a></dt><dd><p>Provide a temporary test directory to aid in running, and
testing, pytest plugins.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-tmp_path"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">tmp_path</span></code></a></dt><dd><p>Provide a <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> object to a temporary directory
which is unique to each test function.</p>
</dd>
<dt><code class="xref std std-fixture docutils literal notranslate"><span class="pre">tmp_path_factory</span></code></dt><dd><p>Make session-scoped temporary directories and return
<a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> objects.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-tmpdir"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">tmpdir</span></code></a></dt><dd><p>Provide a <code class="xref py py-class docutils literal notranslate"><span class="pre">py.path.local</span></code> object to a temporary
directory which is unique to each test function;
replaced by <a class="reference internal" href="reference.html#std-fixture-tmp_path"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">tmp_path</span></code></a>.</p>
</dd>
<dt><a class="reference internal" href="reference.html#std-fixture-tmpdir_factory"><code class="xref std std-fixture docutils literal notranslate"><span class="pre">tmpdir_factory</span></code></a></dt><dd><p>Make session-scoped temporary directories and return
<code class="xref py py-class docutils literal notranslate"><span class="pre">py.path.local</span></code> objects;
replaced by <code class="xref std std-fixture docutils literal notranslate"><span class="pre">tmp_path_factory</span></code>.</p>
</dd>
</dl>
</div></blockquote>
<div class="section" id="what-fixtures-are">
<span id="id1"></span><span id="pytest-fixture"></span><span id="fixture-function"></span><span id="funcarg-mechanism"></span><span id="funcargs"></span><h2>What fixtures are<a class="headerlink" href="#what-fixtures-are" title="Permalink to this headline">¶</a></h2>
<p>Before we dive into what fixtures are, let’s first look at what a test is.</p>
<p>In the simplest terms, a test is meant to look at the result of a particular
behavior, and make sure that result aligns with what you would expect.
Behavior is not something that can be empirically measured, which is why writing
tests can be challenging.</p>
<p>“Behavior” is the way in which some system <strong>acts in response</strong> to a particular
situation and/or stimuli. But exactly <em>how</em> or <em>why</em> something is done is not
quite as important as <em>what</em> was done.</p>
<p>You can think of a test as being broken down into four steps:</p>
<ol class="arabic simple">
<li><p><strong>Arrange</strong></p></li>
<li><p><strong>Act</strong></p></li>
<li><p><strong>Assert</strong></p></li>
<li><p><strong>Cleanup</strong></p></li>
</ol>
<p><strong>Arrange</strong> is where we prepare everything for our test. This means pretty
much everything except for the “<strong>act</strong>”. It’s lining up the dominoes so that
the <strong>act</strong> can do its thing in one, state-changing step. This can mean
preparing objects, starting/killing services, entering records into a database,
or even things like defining a URL to query, generating some credentials for a
user that doesn’t exist yet, or just waiting for some process to finish.</p>
<p><strong>Act</strong> is the singular, state-changing action that kicks off the <strong>behavior</strong>
we want to test. This behavior is what carries out the changing of the state of
the system under test (SUT), and it’s the resulting changed state that we can
look at to make a judgement about the behavior. This typically takes the form of
a function/method call.</p>
<p><strong>Assert</strong> is where we look at that resulting state and check if it looks how
we’d expect after the dust has settled. It’s where we gather evidence to say the
behavior does or does not align with what we expect. The <code class="docutils literal notranslate"><span class="pre">assert</span></code> in our test
is where we take that measurement/observation and apply our judgement to it. If
something should be green, we’d say <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">thing</span> <span class="pre">==</span> <span class="pre">&quot;green&quot;</span></code>.</p>
<p><strong>Cleanup</strong> is where the test picks up after itself, so other tests aren’t being
accidentally influenced by it.</p>
<p>At it’s core, the test is ultimately the <strong>act</strong> and <strong>assert</strong> steps, with the
<strong>arrange</strong> step only providing the context. <strong>Behavior</strong> exists between <strong>act</strong>
and <strong>assert</strong>.</p>
<div class="section" id="back-to-fixtures">
<h3>Back to fixtures<a class="headerlink" href="#back-to-fixtures" title="Permalink to this headline">¶</a></h3>
<p>“Fixtures”, in the literal sense, are each of the <strong>arrange</strong> steps and data. They’re
everything that test needs to do its thing.</p>
<p>At a basic level, test functions request fixtures by declaring them as
arguments, as in the <code class="docutils literal notranslate"><span class="pre">test_ehlo(smtp_connection):</span></code> in the previous example.</p>
<p>In pytest, “fixtures” are functions you define that serve this purpose. But they
don’t have to be limited to just the <strong>arrange</strong> steps. They can provide the
<strong>act</strong> step, as well, and this can be a powerful technique for designing more
complex tests, especially given how pytest’s fixture system works. But we’ll get
into that further down.</p>
<p>We can tell pytest that a particular function is a fixture by decorating it with
<a class="reference internal" href="reference.html#pytest.fixture" title="pytest.fixture"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;pytest.fixture</span></code></a>. Here’s a simple example of
what a fixture in pytest might look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="k">class</span> <span class="nc">Fruit</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">my_fruit</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Fruit</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">fruit_basket</span><span class="p">(</span><span class="n">my_fruit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Fruit</span><span class="p">(</span><span class="s2">&quot;banana&quot;</span><span class="p">),</span> <span class="n">my_fruit</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_my_fruit_in_basket</span><span class="p">(</span><span class="n">my_fruit</span><span class="p">,</span> <span class="n">fruit_basket</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">my_fruit</span> <span class="ow">in</span> <span class="n">fruit_basket</span>
</pre></div>
</div>
<p>Tests don’t have to be limited to a single fixture, either. They can depend on
as many fixtures as you want, and fixtures can use other fixtures, as well. This
is where pytest’s fixture system really shines.</p>
<p>Don’t be afraid to break things up if it makes things cleaner.</p>
</div>
</div>
<div class="section" id="requesting-fixtures">
<h2>“Requesting” fixtures<a class="headerlink" href="#requesting-fixtures" title="Permalink to this headline">¶</a></h2>
<p>So fixtures are how we <em>prepare</em> for a test, but how do we tell pytest what
tests and fixtures need which fixtures?</p>
<p>At a basic level, test functions request fixtures by declaring them as
arguments, as in the <code class="docutils literal notranslate"><span class="pre">test_my_fruit_in_basket(my_fruit,</span> <span class="pre">fruit_basket):</span></code> in the
previous example.</p>
<p>At a basic level, pytest depends on a test to tell it what fixtures it needs, so
we have to build that information into the test itself. We have to make the test
“<strong>request</strong>” the fixtures it depends on, and to do this, we have to
list those fixtures as parameters in the test function’s “signature” (which is
the <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">test_something(blah,</span> <span class="pre">stuff,</span> <span class="pre">more):</span></code> line).</p>
<p>When pytest goes to run a test, it looks at the parameters in that test
function’s signature, and then searches for fixtures that have the same names as
those parameters. Once pytest finds them, it runs those fixtures, captures what
they returned (if anything), and passes those objects into the test function as
arguments.</p>
<div class="section" id="quick-example">
<h3>Quick example<a class="headerlink" href="#quick-example" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="k">class</span> <span class="nc">Fruit</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cubed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">cube</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cubed</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">FruitSalad</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fruit_bowl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fruit</span> <span class="o">=</span> <span class="n">fruit_bowl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cube_fruit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_cube_fruit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fruit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fruit</span><span class="p">:</span>
            <span class="n">fruit</span><span class="o">.</span><span class="n">cube</span><span class="p">()</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">fruit_bowl</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Fruit</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">),</span> <span class="n">Fruit</span><span class="p">(</span><span class="s2">&quot;banana&quot;</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test_fruit_salad</span><span class="p">(</span><span class="n">fruit_bowl</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">fruit_salad</span> <span class="o">=</span> <span class="n">FruitSalad</span><span class="p">(</span><span class="o">*</span><span class="n">fruit_bowl</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">fruit</span><span class="o">.</span><span class="n">cubed</span> <span class="k">for</span> <span class="n">fruit</span> <span class="ow">in</span> <span class="n">fruit_salad</span><span class="o">.</span><span class="n">fruit</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">test_fruit_salad</span></code> “<strong>requests</strong>” <code class="docutils literal notranslate"><span class="pre">fruit_bowl</span></code> (i.e.
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">test_fruit_salad(fruit_bowl):</span></code>), and when pytest sees this, it will
execute the <code class="docutils literal notranslate"><span class="pre">fruit_bowl</span></code> fixture function and pass the object it returns into
<code class="docutils literal notranslate"><span class="pre">test_fruit_salad</span></code> as the <code class="docutils literal notranslate"><span class="pre">fruit_bowl</span></code> argument.</p>
<p>Here’s roughly
what’s happening if we were to do it by hand:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fruit_bowl</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Fruit</span><span class="p">(</span><span class="s2">&quot;apple&quot;</span><span class="p">),</span> <span class="n">Fruit</span><span class="p">(</span><span class="s2">&quot;banana&quot;</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test_fruit_salad</span><span class="p">(</span><span class="n">fruit_bowl</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">fruit_salad</span> <span class="o">=</span> <span class="n">FruitSalad</span><span class="p">(</span><span class="o">*</span><span class="n">fruit_bowl</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">fruit</span><span class="o">.</span><span class="n">cubed</span> <span class="k">for</span> <span class="n">fruit</span> <span class="ow">in</span> <span class="n">fruit_salad</span><span class="o">.</span><span class="n">fruit</span><span class="p">)</span>


<span class="c1"># Arrange</span>
<span class="n">bowl</span> <span class="o">=</span> <span class="n">fruit_bowl</span><span class="p">()</span>
<span class="n">test_fruit_salad</span><span class="p">(</span><span class="n">fruit_bowl</span><span class="o">=</span><span class="n">bowl</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fixtures-can-request-other-fixtures">
<h3>Fixtures can <strong>request</strong> other fixtures<a class="headerlink" href="#fixtures-can-request-other-fixtures" title="Permalink to this headline">¶</a></h3>
<p>One of pytest’s greatest strengths is its extremely flexible fixture system. It
allows us to boil down complex requirements for tests into more simple and
organized functions, where we only need to have each one describe the things
they are dependent on. We’ll get more into this further down, but for now,
here’s a quick example to demonstrate how fixtures can use other fixtures:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># contents of test_append.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_string</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Notice that this is the same example from above, but very little changed. The
fixtures in pytest <strong>request</strong> fixtures just like tests. All the same
<strong>requesting</strong> rules apply to fixtures that do for tests. Here’s how this
example would work if we did it by hand:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_string</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span>


<span class="n">entry</span> <span class="o">=</span> <span class="n">first_entry</span><span class="p">()</span>
<span class="n">the_list</span> <span class="o">=</span> <span class="n">order</span><span class="p">(</span><span class="n">first_entry</span><span class="o">=</span><span class="n">entry</span><span class="p">)</span>
<span class="n">test_string</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">the_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fixtures-are-reusable">
<h3>Fixtures are reusable<a class="headerlink" href="#fixtures-are-reusable" title="Permalink to this headline">¶</a></h3>
<p>One of the things that makes pytest’s fixture system so powerful, is that it
gives us the abilty to define a generic setup step that can reused over and
over, just like a normal function would be used. Two different tests can request
the same fixture and have pytest give each test their own result from that
fixture.</p>
<p>This is extremely useful for making sure tests aren’t affected by each other. We
can use this system to make sure each test gets its own fresh batch of data and
is starting from a clean state so it can provide consistent, repeatable results.</p>
<p>Here’s an example of how this can come in handy:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># contents of test_append.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_string</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_int</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Each test here is being given its own copy of that <code class="docutils literal notranslate"><span class="pre">list</span></code> object,
which means the <code class="docutils literal notranslate"><span class="pre">order</span></code> fixture is getting executed twice (the same
is true for the <code class="docutils literal notranslate"><span class="pre">first_entry</span></code> fixture). If we were to do this by hand as
well, it would look something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_string</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_int</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>


<span class="n">entry</span> <span class="o">=</span> <span class="n">first_entry</span><span class="p">()</span>
<span class="n">the_list</span> <span class="o">=</span> <span class="n">order</span><span class="p">(</span><span class="n">first_entry</span><span class="o">=</span><span class="n">entry</span><span class="p">)</span>
<span class="n">test_string</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">the_list</span><span class="p">)</span>

<span class="n">entry</span> <span class="o">=</span> <span class="n">first_entry</span><span class="p">()</span>
<span class="n">the_list</span> <span class="o">=</span> <span class="n">order</span><span class="p">(</span><span class="n">first_entry</span><span class="o">=</span><span class="n">entry</span><span class="p">)</span>
<span class="n">test_int</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">the_list</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="a-test-fixture-can-request-more-than-one-fixture-at-a-time">
<h3>A test/fixture can <strong>request</strong> more than one fixture at a time<a class="headerlink" href="#a-test-fixture-can-request-more-than-one-fixture-at-a-time" title="Permalink to this headline">¶</a></h3>
<p>Tests and fixtures aren’t limited to <strong>requesting</strong> a single fixture at a time.
They can request as many as they like. Here’s another quick example to
demonstrate:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># contents of test_append.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">second_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">2</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="n">first_entry</span><span class="p">,</span> <span class="n">second_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">,</span> <span class="n">second_entry</span><span class="p">]</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">expected_list</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_string</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">expected_list</span><span class="p">):</span>
    <span class="c1"># Act</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>

    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="n">expected_list</span>
</pre></div>
</div>
</div>
<div class="section" id="fixtures-can-be-requested-more-than-once-per-test-return-values-are-cached">
<h3>Fixtures can be <strong>requested</strong> more than once per test (return values are cached)<a class="headerlink" href="#fixtures-can-be-requested-more-than-once-per-test-return-values-are-cached" title="Permalink to this headline">¶</a></h3>
<p>Fixtures can also be <strong>requested</strong> more than once during the same test, and
pytest won’t execute them again for that test. This means we can <strong>request</strong>
fixtures in multiple fixtures that are dependent on them (and even again in the
test itself) without those fixtures being executed more than once.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># contents of test_append.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="c1"># Arrange</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="c1"># Act</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">append_first</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_entry</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_string_only</span><span class="p">(</span><span class="n">append_first</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">first_entry</span><span class="p">):</span>
    <span class="c1"># Assert</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">]</span>
</pre></div>
</div>
<p>If a <strong>requested</strong> fixture was executed once for every time it was <strong>requested</strong>
during a test, then this test would fail because both <code class="docutils literal notranslate"><span class="pre">append_first</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_string_only</span></code> would see <code class="docutils literal notranslate"><span class="pre">order</span></code> as an empty list (i.e. <code class="docutils literal notranslate"><span class="pre">[]</span></code>), but
since the return value of <code class="docutils literal notranslate"><span class="pre">order</span></code> was cached (along with any side effects
executing it may have had) after the first time it was called, both the test and
<code class="docutils literal notranslate"><span class="pre">append_first</span></code> were referencing the same object, and the test saw the effect
<code class="docutils literal notranslate"><span class="pre">append_first</span></code> had on that object.</p>
</div>
</div>
<div class="section" id="autouse-fixtures-fixtures-you-don-t-have-to-request">
<span id="autouse-fixtures"></span><span id="autouse"></span><h2>Autouse fixtures (fixtures you don’t have to request)<a class="headerlink" href="#autouse-fixtures-fixtures-you-don-t-have-to-request" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you may want to have a fixture (or even several) that you know all
your tests will depend on. “Autouse” fixtures are a convenient way to make all
tests automatically <strong>request</strong> them. This can cut out a
lot of redundant <strong>requests</strong>, and can even provide more advanced fixture usage
(more on that further down).</p>
<p>We can make a fixture an autouse fixture by passing in <code class="docutils literal notranslate"><span class="pre">autouse=True</span></code> to the
fixture’s decorator. Here’s a simple example for how they can be used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># contents of test_append.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">first_entry</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;a&quot;</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">append_first</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">first_entry</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_entry</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_string_only</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">first_entry</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_string_and_int</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">first_entry</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="n">first_entry</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">append_first</span></code> fixture is an autouse fixture. Because it
happens automatically, both tests are affected by it, even though neither test
<strong>requested</strong> it. That doesn’t mean they <em>can’t</em> be <strong>requested</strong> though; just
that it isn’t <em>necessary</em>.</p>
</div>
<div class="section" id="scope-sharing-fixtures-across-classes-modules-packages-or-session">
<span id="smtpshared"></span><h2>Scope: sharing fixtures across classes, modules, packages or session<a class="headerlink" href="#scope-sharing-fixtures-across-classes-modules-packages-or-session" title="Permalink to this headline">¶</a></h2>
<p>Fixtures requiring network access depend on connectivity and are
usually time-expensive to create.  Extending the previous example, we
can add a <code class="docutils literal notranslate"><span class="pre">scope=&quot;module&quot;</span></code> parameter to the
<a class="reference internal" href="reference.html#pytest.fixture" title="pytest.fixture"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;pytest.fixture</span></code></a> invocation
to cause a <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture function, responsible to create a connection to a preexisting SMTP server, to only be invoked
once per test <em>module</em> (the default is to invoke once per test <em>function</em>).
Multiple test functions in a test module will thus
each receive the same <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture instance, thus saving time.
Possible values for <code class="docutils literal notranslate"><span class="pre">scope</span></code> are: <code class="docutils literal notranslate"><span class="pre">function</span></code>, <code class="docutils literal notranslate"><span class="pre">class</span></code>, <code class="docutils literal notranslate"><span class="pre">module</span></code>, <code class="docutils literal notranslate"><span class="pre">package</span></code> or <code class="docutils literal notranslate"><span class="pre">session</span></code>.</p>
<p>The next example puts the fixture function into a separate <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> file
so that tests from multiple test modules in the directory can
access the fixture function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of conftest.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">import</span> <span class="nn">smtplib</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">smtp_connection</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="s2">&quot;smtp.gmail.com&quot;</span><span class="p">,</span> <span class="mi">587</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_module.py</span>


<span class="k">def</span> <span class="nf">test_ehlo</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">):</span>
    <span class="n">response</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">smtp_connection</span><span class="o">.</span><span class="n">ehlo</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">response</span> <span class="o">==</span> <span class="mi">250</span>
    <span class="k">assert</span> <span class="sa">b</span><span class="s2">&quot;smtp.gmail.com&quot;</span> <span class="ow">in</span> <span class="n">msg</span>
    <span class="k">assert</span> <span class="mi">0</span>  <span class="c1"># for demo purposes</span>


<span class="k">def</span> <span class="nf">test_noop</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">):</span>
    <span class="n">response</span><span class="p">,</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">smtp_connection</span><span class="o">.</span><span class="n">noop</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">response</span> <span class="o">==</span> <span class="mi">250</span>
    <span class="k">assert</span> <span class="mi">0</span>  <span class="c1"># for demo purposes</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal notranslate"><span class="pre">test_ehlo</span></code> needs the <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture value.  pytest
will discover and call the <a class="reference internal" href="reference.html#pytest.fixture" title="pytest.fixture"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;pytest.fixture</span></code></a>
marked <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture function.  Running the test looks like this:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest test_module.py
<span class=" -Color -Color-Bold">=========================== test session starts ============================</span>
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR
collected 2 items

test_module.py <span class=" -Color -Color-Red">FF</span>                                                    <span class=" -Color -Color-Red">[100%]</span>

================================= FAILURES =================================
<span class=" -Color -Color-Bold -Color-Bold-Red">________________________________ test_ehlo _________________________________</span>

smtp_connection = &lt;smtplib.SMTP object at 0xdeadbeef&gt;

    def test_ehlo(smtp_connection):
        response, msg = smtp_connection.ehlo()
        assert response == 250
        assert b&quot;smtp.gmail.com&quot; in msg
&gt;       assert 0  # for demo purposes
<span class=" -Color -Color-Bold -Color-Bold-Red">E       assert 0</span>

<span class=" -Color -Color-Bold -Color-Bold-Red">test_module.py</span>:7: AssertionError
<span class=" -Color -Color-Bold -Color-Bold-Red">________________________________ test_noop _________________________________</span>

smtp_connection = &lt;smtplib.SMTP object at 0xdeadbeef&gt;

    def test_noop(smtp_connection):
        response, msg = smtp_connection.noop()
        assert response == 250
&gt;       assert 0  # for demo purposes
<span class=" -Color -Color-Bold -Color-Bold-Red">E       assert 0</span>

<span class=" -Color -Color-Bold -Color-Bold-Red">test_module.py</span>:13: AssertionError
========================= short test summary info ==========================
FAILED test_module.py::test_ehlo - assert 0
FAILED test_module.py::test_noop - assert 0
<span class=" -Color -Color-Red">============================ </span><span class=" -Color -Color-Bold -Color-Bold-Red">2 failed</span><span class=" -Color -Color-Red"> in 0.12s =============================</span>
</pre></div>
</div>
<p>You see the two <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">0</span></code> failing and more importantly you can also see
that the <strong>exactly same</strong> <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> object was passed into the
two test functions because pytest shows the incoming argument values in the
traceback.  As a result, the two test functions using <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> run
as quick as a single one because they reuse the same instance.</p>
<p>If you decide that you rather want to have a session-scoped <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code>
instance, you can simply declare it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">smtp_connection</span><span class="p">():</span>
    <span class="c1"># the returned fixture value will be shared for</span>
    <span class="c1"># all tests requesting it</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="section" id="fixture-scopes">
<h3>Fixture scopes<a class="headerlink" href="#fixture-scopes" title="Permalink to this headline">¶</a></h3>
<p>Fixtures are created when first requested by a test, and are destroyed based on their <code class="docutils literal notranslate"><span class="pre">scope</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code>: the default scope, the fixture is destroyed at the end of the test.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">class</span></code>: the fixture is destroyed during teardown of the last test in the class.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">module</span></code>: the fixture is destroyed during teardown of the last test in the module.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">package</span></code>: the fixture is destroyed during teardown of the last test in the package.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">session</span></code>: the fixture is destroyed at the end of the test session.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Pytest only caches one instance of a fixture at a time, which
means that when using a parametrized fixture, pytest may invoke a fixture more than once in
the given scope.</p>
</div>
</div>
<div class="section" id="dynamic-scope">
<span id="id2"></span><h3>Dynamic scope<a class="headerlink" href="#dynamic-scope" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.2.</span></p>
</div>
<p>In some cases, you might want to change the scope of the fixture without changing the code.
To do that, pass a callable to <code class="docutils literal notranslate"><span class="pre">scope</span></code>. The callable must return a string with a valid scope
and will be executed only once - during the fixture definition. It will be called with two
keyword arguments - <code class="docutils literal notranslate"><span class="pre">fixture_name</span></code> as a string and <code class="docutils literal notranslate"><span class="pre">config</span></code> with a configuration object.</p>
<p>This can be especially useful when dealing with fixtures that need time for setup, like spawning
a docker container. You can use the command-line argument to control the scope of the spawned
containers for different environments. See the example below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">determine_scope</span><span class="p">(</span><span class="n">fixture_name</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">getoption</span><span class="p">(</span><span class="s2">&quot;--keep-containers&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;session&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;function&quot;</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="n">determine_scope</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">docker_container</span><span class="p">():</span>
    <span class="k">yield</span> <span class="n">spawn_container</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="fixture-errors">
<h2>Fixture errors<a class="headerlink" href="#fixture-errors" title="Permalink to this headline">¶</a></h2>
<p>pytest does its best to put all the fixtures for a given test in a linear order
so that it can see which fixture happens first, second, third, and so on. If an
earlier fixture has a problem, though, and raises an exception, pytest will stop
executing fixtures for that test and mark the test as having an error.</p>
<p>When a test is marked as having an error, it doesn’t mean the test failed,
though. It just means the test couldn’t even be attempted because one of the
things it depends on had a problem.</p>
<p>This is one reason why it’s a good idea to cut out as many unnecessary
dependencies as possible for a given test. That way a problem in something
unrelated isn’t causing us to have an incomplete picture of what may or may not
have issues.</p>
<p>Here’s a quick example to help explain:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">append_first</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">append_second</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">append_first</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">append_third</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">append_second</span><span class="p">):</span>
    <span class="n">order</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>If, for whatever reason, <code class="docutils literal notranslate"><span class="pre">order.append(1)</span></code> had a bug and it raises an exception,
we wouldn’t be able to know if <code class="docutils literal notranslate"><span class="pre">order.extend([2])</span></code> or <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+=</span> <span class="pre">[3]</span></code> would
also have problems. After <code class="docutils literal notranslate"><span class="pre">append_first</span></code> throws an exception, pytest won’t run
any more fixtures for <code class="docutils literal notranslate"><span class="pre">test_order</span></code>, and it won’t even try to run
<code class="docutils literal notranslate"><span class="pre">test_order</span></code> itself. The only things that would’ve run would be <code class="docutils literal notranslate"><span class="pre">order</span></code> and
<code class="docutils literal notranslate"><span class="pre">append_first</span></code>.</p>
</div>
<div class="section" id="teardown-cleanup-aka-fixture-finalization">
<span id="finalization"></span><h2>Teardown/Cleanup (AKA Fixture finalization)<a class="headerlink" href="#teardown-cleanup-aka-fixture-finalization" title="Permalink to this headline">¶</a></h2>
<p>When we run our tests, we’ll want to make sure they clean up after themselves so
they don’t mess with any other tests (and also so that we don’t leave behind a
mountain of test data to bloat the system). Fixtures in pytest offer a very
useful teardown system, which allows us to define the specific steps necessary
for each fixture to clean up after itself.</p>
<p>This system can be leveraged in two ways.</p>
<div class="section" id="yield-fixtures-recommended">
<span id="yield-fixtures"></span><h3>1. <code class="docutils literal notranslate"><span class="pre">yield</span></code> fixtures (recommended)<a class="headerlink" href="#yield-fixtures-recommended" title="Permalink to this headline">¶</a></h3>
<p>“Yield” fixtures <code class="docutils literal notranslate"><span class="pre">yield</span></code> instead of <code class="docutils literal notranslate"><span class="pre">return</span></code>. With these
fixtures, we can run some code and pass an object back to the requesting
fixture/test, just like with the other fixtures. The only differences are:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">return</span></code> is swapped out for <code class="docutils literal notranslate"><span class="pre">yield</span></code>.</p></li>
<li><p>Any teardown code for that fixture is placed <em>after</em> the <code class="docutils literal notranslate"><span class="pre">yield</span></code>.</p></li>
</ol>
<p>Once pytest figures out a linear order for the fixtures, it will run each one up
until it returns or yields, and then move on to the next fixture in the list to
do the same thing.</p>
<p>Once the test is finished, pytest will go back down the list of fixtures, but in
the <em>reverse order</em>, taking each one that yielded, and running the code inside
it that was <em>after</em> the <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement.</p>
<p>As a simple example, let’s say we want to test sending email from one user to
another. We’ll have to first make each user, then send the email from one user
to the other, and finally assert that the other user received that message in
their inbox. If we want to clean up after the test runs, we’ll likely have to
make sure the other user’s mailbox is emptied before deleting that user,
otherwise the system may complain.</p>
<p>Here’s what that might look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">emaillib</span> <span class="kn">import</span> <span class="n">Email</span><span class="p">,</span> <span class="n">MailAdminClient</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">mail_admin</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">MailAdminClient</span><span class="p">()</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">sending_user</span><span class="p">(</span><span class="n">mail_admin</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">mail_admin</span><span class="o">.</span><span class="n">create_user</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">user</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">receiving_user</span><span class="p">(</span><span class="n">mail_admin</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">mail_admin</span><span class="o">.</span><span class="n">create_user</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">user</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_email_received</span><span class="p">(</span><span class="n">receiving_user</span><span class="p">,</span> <span class="n">email</span><span class="p">):</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Email</span><span class="p">(</span><span class="n">subject</span><span class="o">=</span><span class="s2">&quot;Hey!&quot;</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="s2">&quot;How&#39;s it going?&quot;</span><span class="p">)</span>
    <span class="n">sending_user</span><span class="o">.</span><span class="n">send_email</span><span class="p">(</span><span class="n">_email</span><span class="p">,</span> <span class="n">receiving_user</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">receiving_user</span><span class="o">.</span><span class="n">inbox</span>
</pre></div>
</div>
<p>Because <code class="docutils literal notranslate"><span class="pre">receiving_user</span></code> is the last fixture to run during setup, it’s the first to run
during teardown.</p>
<p>There is a risk that even having the order right on the teardown side of things
doesn’t guarantee a safe cleanup. That’s covered in a bit more detail in
<a class="reference internal" href="#safe-teardowns"><span class="std std-ref">Safe teardowns</span></a>.</p>
<div class="section" id="handling-errors-for-yield-fixture">
<h4>Handling errors for yield fixture<a class="headerlink" href="#handling-errors-for-yield-fixture" title="Permalink to this headline">¶</a></h4>
<p>If a yield fixture raises an exception before yielding, pytest won’t try to run
the teardown code after that yield fixture’s <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement. But, for every
fixture that has already run successfully for that test, pytest will still
attempt to tear them down as it normally would.</p>
</div>
</div>
<div class="section" id="adding-finalizers-directly">
<h3>2. Adding finalizers directly<a class="headerlink" href="#adding-finalizers-directly" title="Permalink to this headline">¶</a></h3>
<p>While yield fixtures are considered to be the cleaner and more straighforward
option, there is another choice, and that is to add “finalizer” functions
directly to the test’s <a class="reference internal" href="#request-context">request-context</a> object. It brings a similar result as
yield fixtures, but requires a bit more verbosity.</p>
<p>In order to use this approach, we have to request the <a class="reference internal" href="#request-context">request-context</a> object
(just like we would request another fixture) in the fixture we need to add
teardown code for, and then pass a callable, containing that teardown code, to
its <code class="docutils literal notranslate"><span class="pre">addfinalizer</span></code> method.</p>
<p>We have to be careful though, because pytest will run that finalizer once it’s
been added, even if that fixture raises an exception after adding the finalizer.
So to make sure we don’t run the finalizer code when we wouldn’t need to, we
would only add the finalizer once the fixture would have done something that
we’d need to teardown.</p>
<p>Here’s how the previous example would look using the <code class="docutils literal notranslate"><span class="pre">addfinalizer</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">emaillib</span> <span class="kn">import</span> <span class="n">Email</span><span class="p">,</span> <span class="n">MailAdminClient</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">mail_admin</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">MailAdminClient</span><span class="p">()</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">sending_user</span><span class="p">(</span><span class="n">mail_admin</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">mail_admin</span><span class="o">.</span><span class="n">create_user</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">user</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">receiving_user</span><span class="p">(</span><span class="n">mail_admin</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">mail_admin</span><span class="o">.</span><span class="n">create_user</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">delete_user</span><span class="p">():</span>
        <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

    <span class="n">request</span><span class="o">.</span><span class="n">addfinalizer</span><span class="p">(</span><span class="n">delete_user</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">user</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">email</span><span class="p">(</span><span class="n">sending_user</span><span class="p">,</span> <span class="n">receiving_user</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
    <span class="n">_email</span> <span class="o">=</span> <span class="n">Email</span><span class="p">(</span><span class="n">subject</span><span class="o">=</span><span class="s2">&quot;Hey!&quot;</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="s2">&quot;How&#39;s it going?&quot;</span><span class="p">)</span>
    <span class="n">sending_user</span><span class="o">.</span><span class="n">send_email</span><span class="p">(</span><span class="n">_email</span><span class="p">,</span> <span class="n">receiving_user</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">empty_mailbox</span><span class="p">():</span>
        <span class="n">receiving_user</span><span class="o">.</span><span class="n">delete_email</span><span class="p">(</span><span class="n">_email</span><span class="p">)</span>

    <span class="n">request</span><span class="o">.</span><span class="n">addfinalizer</span><span class="p">(</span><span class="n">empty_mailbox</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_email</span>


<span class="k">def</span> <span class="nf">test_email_received</span><span class="p">(</span><span class="n">receiving_user</span><span class="p">,</span> <span class="n">email</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">receiving_user</span><span class="o">.</span><span class="n">inbox</span>
</pre></div>
</div>
<p>It’s a bit longer than yield fixtures and a bit more complex, but it
does offer some nuances for when you’re in a pinch.</p>
</div>
</div>
<div class="section" id="safe-teardowns">
<span id="id3"></span><h2>Safe teardowns<a class="headerlink" href="#safe-teardowns" title="Permalink to this headline">¶</a></h2>
<p>The fixture system of pytest is <em>very</em> powerful, but it’s still being run by a
computer, so it isn’t able to figure out how to safely teardown everything we
throw at it. If we aren’t careful, an error in the wrong spot might leave stuff
from our tests behind, and that can cause further issues pretty quickly.</p>
<p>For example, consider the following tests (based off of the mail example from
above):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">emaillib</span> <span class="kn">import</span> <span class="n">Email</span><span class="p">,</span> <span class="n">MailAdminClient</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">setup</span><span class="p">():</span>
    <span class="n">mail_admin</span> <span class="o">=</span> <span class="n">MailAdminClient</span><span class="p">()</span>
    <span class="n">sending_user</span> <span class="o">=</span> <span class="n">mail_admin</span><span class="o">.</span><span class="n">create_user</span><span class="p">()</span>
    <span class="n">receiving_user</span> <span class="o">=</span> <span class="n">mail_admin</span><span class="o">.</span><span class="n">create_user</span><span class="p">()</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Email</span><span class="p">(</span><span class="n">subject</span><span class="o">=</span><span class="s2">&quot;Hey!&quot;</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="s2">&quot;How&#39;s it going?&quot;</span><span class="p">)</span>
    <span class="n">sending_user</span><span class="o">.</span><span class="n">send_emai</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">receiving_user</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">receiving_user</span><span class="p">,</span> <span class="n">email</span>
    <span class="n">receiving_user</span><span class="o">.</span><span class="n">delete_email</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">sending_user</span><span class="p">)</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">receiving_user</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_email_received</span><span class="p">(</span><span class="n">setup</span><span class="p">):</span>
    <span class="n">receiving_user</span><span class="p">,</span> <span class="n">email</span> <span class="o">=</span> <span class="n">setup</span>
    <span class="k">assert</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">receiving_user</span><span class="o">.</span><span class="n">inbox</span>
</pre></div>
</div>
<p>This version is a lot more compact, but it’s also harder to read, doesn’t have a
very descriptive fixture name, and none of the fixtures can be reused easily.</p>
<p>There’s also a more serious issue, which is that if any of those steps in the
setup raise an exception, none of the teardown code will run.</p>
<p>One option might be to go with the <code class="docutils literal notranslate"><span class="pre">addfinalizer</span></code> method instead of yield
fixtures, but that might get pretty complex and difficult to maintain (and it
wouldn’t be compact anymore).</p>
<div class="section" id="safe-fixture-structure">
<span id="id4"></span><h3>Safe fixture structure<a class="headerlink" href="#safe-fixture-structure" title="Permalink to this headline">¶</a></h3>
<p>The safest and simplest fixture structure requires limiting fixtures to only
making one state-changing action each, and then bundling them together with
their teardown code, as <a class="reference internal" href="#yield-fixtures"><span class="std std-ref">the email examples above</span></a> showed.</p>
<p>The chance that a state-changing operation can fail but still modify state is
neglibible, as most of these operations tend to be <a class="reference external" href="https://en.wikipedia.org/wiki/Transaction_processing">transaction</a>-based (at
least at the level of testing where state could be left behind). So if we make
sure that any successful state-changing action gets torn down by moving it to a
separate fixture function and separating it from other, potentially failing
state-changing actions, then our tests will stand the best chance at leaving the
test environment the way they found it.</p>
<p>For an example, let’s say we have a website with a login page, and we have
access to an admin API where we can generate users. For our test, we want to:</p>
<ol class="arabic simple">
<li><p>Create a user through that admin API</p></li>
<li><p>Launch a browser using Selenium</p></li>
<li><p>Go to the login page of our site</p></li>
<li><p>Log in as the user we created</p></li>
<li><p>Assert that their name is in the header of the landing page</p></li>
</ol>
<p>We wouldn’t want to leave that user in the system, nor would we want to leave
that browser session running, so we’ll want to make sure the fixtures that
create those things clean up after themselves.</p>
<p>Here’s what that might look like:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For this example, certain fixtures (i.e. <code class="docutils literal notranslate"><span class="pre">base_url</span></code> and
<code class="docutils literal notranslate"><span class="pre">admin_credentials</span></code>) are implied to exist elsewhere. So for now, let’s
assume they exist, and we’re just not looking at them.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>

<span class="kn">from</span> <span class="nn">selenium.webdriver</span> <span class="kn">import</span> <span class="n">Chrome</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">src.utils.pages</span> <span class="kn">import</span> <span class="n">LoginPage</span><span class="p">,</span> <span class="n">LandingPage</span>
<span class="kn">from</span> <span class="nn">src.utils</span> <span class="kn">import</span> <span class="n">AdminApiClient</span>
<span class="kn">from</span> <span class="nn">src.utils.data_types</span> <span class="kn">import</span> <span class="n">User</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">admin_client</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="n">admin_credentials</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AdminApiClient</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="o">**</span><span class="n">admin_credentials</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="n">admin_client</span><span class="p">):</span>
    <span class="n">_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Susan&quot;</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;testuser-</span><span class="si">{</span><span class="n">uuid4</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s2">&quot;P4$$word&quot;</span><span class="p">)</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">create_user</span><span class="p">(</span><span class="n">_user</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">_user</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">_user</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">driver</span><span class="p">():</span>
    <span class="n">_driver</span> <span class="o">=</span> <span class="n">Chrome</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">_driver</span>
    <span class="n">_driver</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">base_url</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
    <span class="n">driver</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="s2">&quot;/login&quot;</span><span class="p">))</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">LoginPage</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>
    <span class="n">page</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">landing_page</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">login</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">LandingPage</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_name_on_landing_page_after_login</span><span class="p">(</span><span class="n">landing_page</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">landing_page</span><span class="o">.</span><span class="n">header</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;Welcome, </span><span class="si">{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">!&quot;</span>
</pre></div>
</div>
<p>The way the dependencies are laid out means it’s unclear if the <code class="docutils literal notranslate"><span class="pre">user</span></code> fixture
would execute before the <code class="docutils literal notranslate"><span class="pre">driver</span></code> fixture. But that’s ok, because those are
atomic operations, and so it doesn’t matter which one runs first because the
sequence of events for the test is still <a class="reference external" href="https://en.wikipedia.org/wiki/Linearizability">linearizable</a>. But what <em>does</em> matter
is that, no matter which one runs first, if the one raises an exception while
the other would not have, neither will have left anything behind. If <code class="docutils literal notranslate"><span class="pre">driver</span></code>
executes before <code class="docutils literal notranslate"><span class="pre">user</span></code>, and <code class="docutils literal notranslate"><span class="pre">user</span></code> raises an exception, the driver will
still quit, and the user was never made. And if <code class="docutils literal notranslate"><span class="pre">driver</span></code> was the one to raise
the exception, then the driver would never have been started and the user would
never have been made.</p>
</div>
</div>
<div class="section" id="fixture-availability">
<span id="conftest"></span><span id="conftest-py"></span><h2>Fixture availability<a class="headerlink" href="#fixture-availability" title="Permalink to this headline">¶</a></h2>
<p>Fixture availability is determined from the perspective of the test. A fixture
is only available for tests to request if they are in the scope that fixture is
defined in. If a fixture is defined inside a class, it can only be requested by
tests inside that class. But if a fixture is defined inside the global scope of
the module, than every test in that module, even if it’s defined inside a class,
can request it.</p>
<p>Similarly, a test can also only be affected by an autouse fixture if that test
is in the same scope that autouse fixture is defined in (see
<a class="reference internal" href="#autouse-order"><span class="std std-ref">Autouse fixtures are executed first within their scope</span></a>).</p>
<p>A fixture can also request any other fixture, no matter where it’s defined, so
long as the test requesting them can see all fixtures involved.</p>
<p>For example, here’s a test file with a fixture (<code class="docutils literal notranslate"><span class="pre">outer</span></code>) that requests a
fixture (<code class="docutils literal notranslate"><span class="pre">inner</span></code>) from a scope it wasn’t defined in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">inner</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TestOne</span><span class="p">:</span>
    <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">outer</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TestTwo</span><span class="p">:</span>
    <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;two&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">outer</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>From the tests’ perspectives, they have no problem seeing each of the fixtures
they’re dependent on:</p>
<img alt="_images/test_fixtures_request_different_scope.svg" class="align-center" src="_images/test_fixtures_request_different_scope.svg" /><p>So when they run, <code class="docutils literal notranslate"><span class="pre">outer</span></code> will have no problem finding <code class="docutils literal notranslate"><span class="pre">inner</span></code>, because
pytest searched from the tests’ perspectives.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The scope a fixture is defined in has no bearing on the order it will be
instantiated in: the order is mandated by the logic described
<a class="reference internal" href="#fixture-order"><span class="std std-ref">here</span></a>.</p>
</div>
<div class="section" id="conftest-py-sharing-fixtures-across-multiple-files">
<h3><code class="docutils literal notranslate"><span class="pre">conftest.py</span></code>: sharing fixtures across multiple files<a class="headerlink" href="#conftest-py-sharing-fixtures-across-multiple-files" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> file serves as a means of providing fixtures for an entire
directory. Fixtures defined in a <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> can be used by any test
in that package without needing to import them (pytest will automatically
discover them).</p>
<p>You can have multiple nested directories/packages containing your tests, and
each directory can have its own <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> with its own fixtures, adding on
to the ones provided by the <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> files in parent directories.</p>
<p>For example, given a test file structure like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

    <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/conftest.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">innermost</span><span class="p">):</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>

    <span class="n">test_top</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_top.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">innermost</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;innermost top&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">top</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;innermost top&quot;</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">]</span>

    <span class="n">subpackage</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

        <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
            <span class="c1"># content of tests/subpackage/conftest.py</span>
            <span class="kn">import</span> <span class="nn">pytest</span>

            <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
            <span class="k">def</span> <span class="nf">mid</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mid subpackage&quot;</span><span class="p">)</span>

        <span class="n">test_subpackage</span><span class="o">.</span><span class="n">py</span>
            <span class="c1"># content of tests/subpackage/test_subpackage.py</span>
            <span class="kn">import</span> <span class="nn">pytest</span>

            <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
            <span class="k">def</span> <span class="nf">innermost</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">mid</span><span class="p">):</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;innermost subpackage&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">top</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;mid subpackage&quot;</span><span class="p">,</span> <span class="s2">&quot;innermost subpackage&quot;</span><span class="p">,</span> <span class="s2">&quot;top&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The boundaries of the scopes can be visualized like this:</p>
<img alt="_images/fixture_availability.svg" class="align-center" src="_images/fixture_availability.svg" /><p>The directories become their own sort of scope where fixtures that are defined
in a <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> file in that directory become available for that whole
scope.</p>
<p>Tests are allowed to search upward (stepping outside a circle) for fixtures, but
can never go down (stepping inside a circle) to continue their search. So
<code class="docutils literal notranslate"><span class="pre">tests/subpackage/test_subpackage.py::test_order</span></code> would be able to find the
<code class="docutils literal notranslate"><span class="pre">innermost</span></code> fixture defined in <code class="docutils literal notranslate"><span class="pre">tests/subpackage/test_subpackage.py</span></code>, but
the one defined in <code class="docutils literal notranslate"><span class="pre">tests/test_top.py</span></code> would be unavailable to it because it
would have to step down a level (step inside a circle) to find it.</p>
<p>The first fixture the test finds is the one that will be used, so
<a class="reference internal" href="#override-fixtures"><span class="std std-ref">fixtures can be overriden</span></a> if you need to change or
extend what one does for a particular scope.</p>
<p>You can also use the <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> file to implement
<a class="reference internal" href="writing_plugins.html#conftest-py-plugins"><span class="std std-ref">local per-directory plugins</span></a>.</p>
</div>
<div class="section" id="fixtures-from-third-party-plugins">
<h3>Fixtures from third-party plugins<a class="headerlink" href="#fixtures-from-third-party-plugins" title="Permalink to this headline">¶</a></h3>
<p>Fixtures don’t have to be defined in this structure to be available for tests,
though. They can also be provided by third-party plugins that are installed, and
this is how many pytest plugins operate. As long as those plugins are installed,
the fixtures they provide can be requested from anywhere in your test suite.</p>
<p>Because they’re provided from outside the structure of your test suite,
third-party plugins don’t really provide a scope like <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> files and
the directories in your test suite do. As a result, pytest will search for
fixtures stepping out through scopes as explained previously, only reaching
fixtures defined in plugins <em>last</em>.</p>
<p>For example, given the following file structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

    <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/conftest.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="n">subpackage</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

        <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
            <span class="c1"># content of tests/subpackage/conftest.py</span>
            <span class="kn">import</span> <span class="nn">pytest</span>

            <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">mid</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">b_fix</span><span class="p">):</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;mid subpackage&quot;</span><span class="p">)</span>

        <span class="n">test_subpackage</span><span class="o">.</span><span class="n">py</span>
            <span class="c1"># content of tests/subpackage/test_subpackage.py</span>
            <span class="kn">import</span> <span class="nn">pytest</span>

            <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
            <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">a_fix</span><span class="p">):</span>
                <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;inner subpackage&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">inner</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;b_fix&quot;</span><span class="p">,</span> <span class="s2">&quot;mid subpackage&quot;</span><span class="p">,</span> <span class="s2">&quot;a_fix&quot;</span><span class="p">,</span> <span class="s2">&quot;inner subpackage&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">plugin_a</span></code> is installed and provides the fixture <code class="docutils literal notranslate"><span class="pre">a_fix</span></code>, and
<code class="docutils literal notranslate"><span class="pre">plugin_b</span></code> is installed and provides the fixture <code class="docutils literal notranslate"><span class="pre">b_fix</span></code>, then this is what
the test’s search for fixtures would look like:</p>
<img alt="_images/fixture_availability_plugins.svg" class="align-center" src="_images/fixture_availability_plugins.svg" /><p>pytest will only search for <code class="docutils literal notranslate"><span class="pre">a_fix</span></code> and <code class="docutils literal notranslate"><span class="pre">b_fix</span></code> in the plugins after
searching for them first in the scopes inside <code class="docutils literal notranslate"><span class="pre">tests/</span></code>.</p>
</div>
</div>
<div class="section" id="sharing-test-data">
<h2>Sharing test data<a class="headerlink" href="#sharing-test-data" title="Permalink to this headline">¶</a></h2>
<p>If you want to make test data from files available to your tests, a good way
to do this is by loading these data in a fixture for use by your tests.
This makes use of the automatic caching mechanisms of pytest.</p>
<p>Another good approach is by adding the data files in the <code class="docutils literal notranslate"><span class="pre">tests</span></code> folder.
There are also community plugins available to help managing this aspect of
testing, e.g. <a class="reference external" href="https://pypi.org/project/pytest-datadir/">pytest-datadir</a>
and <a class="reference external" href="https://pypi.org/project/pytest-datafiles/">pytest-datafiles</a>.</p>
</div>
<div class="section" id="fixture-instantiation-order">
<span id="fixture-order"></span><h2>Fixture instantiation order<a class="headerlink" href="#fixture-instantiation-order" title="Permalink to this headline">¶</a></h2>
<p>When pytest wants to execute a test, once it knows what fixtures will be
executed, it has to figure out the order they’ll be executed in. To do this, it
considers 3 factors:</p>
<ol class="arabic simple">
<li><p>scope</p></li>
<li><p>dependencies</p></li>
<li><p>autouse</p></li>
</ol>
<p>Names of fixtures or tests, where they’re defined, the order they’re defined in,
and the order fixtures are requested in have no bearing on execution order
beyond coincidence. While pytest will try to make sure coincidences like these
stay consistent from run to run, it’s not something that should be depended on.
If you want to control the order, it’s safest to rely on these 3 things and make
sure dependencies are clearly established.</p>
<div class="section" id="higher-scoped-fixtures-are-executed-first">
<h3>Higher-scoped fixtures are executed first<a class="headerlink" href="#higher-scoped-fixtures-are-executed-first" title="Permalink to this headline">¶</a></h3>
<p>Within a function request for fixtures, those of higher-scopes (such as
<code class="docutils literal notranslate"><span class="pre">session</span></code>) are executed before lower-scoped fixtures (such as <code class="docutils literal notranslate"><span class="pre">function</span></code> or
<code class="docutils literal notranslate"><span class="pre">class</span></code>).</p>
<p>Here’s an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cls</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mod</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;package&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;package&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sess</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;session&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TestClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">pack</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;session&quot;</span><span class="p">,</span> <span class="s2">&quot;package&quot;</span><span class="p">,</span> <span class="s2">&quot;module&quot;</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>The test will pass because the larger scoped fixtures are executing first.</p>
<p>The order breaks down to this:</p>
<img alt="_images/test_fixtures_order_scope.svg" class="align-center" src="_images/test_fixtures_order_scope.svg" /></div>
<div class="section" id="fixtures-of-the-same-order-execute-based-on-dependencies">
<h3>Fixtures of the same order execute based on dependencies<a class="headerlink" href="#fixtures-of-the-same-order-execute-based-on-dependencies" title="Permalink to this headline">¶</a></h3>
<p>When a fixture requests another fixture, the other fixture is executed first.
So if fixture <code class="docutils literal notranslate"><span class="pre">a</span></code> requests fixture <code class="docutils literal notranslate"><span class="pre">b</span></code>, fixture <code class="docutils literal notranslate"><span class="pre">b</span></code> will execute first,
because <code class="docutils literal notranslate"><span class="pre">a</span></code> depends on <code class="docutils literal notranslate"><span class="pre">b</span></code> and can’t operate without it. Even if <code class="docutils literal notranslate"><span class="pre">a</span></code>
doesn’t need the result of <code class="docutils literal notranslate"><span class="pre">b</span></code>, it can still request <code class="docutils literal notranslate"><span class="pre">b</span></code> if it needs to make
sure it is executed after <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">e</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>If we map out what depends on what, we get something that look like this:</p>
<img alt="_images/test_fixtures_order_dependencies.svg" class="align-center" src="_images/test_fixtures_order_dependencies.svg" /><p>The rules provided by each fixture (as to what fixture(s) each one has to come
after) are comprehensive enough that it can be flattened to this:</p>
<img alt="_images/test_fixtures_order_dependencies_flat.svg" class="align-center" src="_images/test_fixtures_order_dependencies_flat.svg" /><p>Enough information has to be provided through these requests in order for pytest
to be able to figure out a clear, linear chain of dependencies, and as a result,
an order of operations for a given test. If there’s any ambiguity, and the order
of operations can be interpreted more than one way, you should assume pytest
could go with any one of those interpretations at any point.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">d</span></code> didn’t request <code class="docutils literal notranslate"><span class="pre">c</span></code>, i.e.the graph would look like this:</p>
<img alt="_images/test_fixtures_order_dependencies_unclear.svg" class="align-center" src="_images/test_fixtures_order_dependencies_unclear.svg" /><p>Because nothing requested <code class="docutils literal notranslate"><span class="pre">c</span></code> other than <code class="docutils literal notranslate"><span class="pre">g</span></code>, and <code class="docutils literal notranslate"><span class="pre">g</span></code> also requests <code class="docutils literal notranslate"><span class="pre">f</span></code>,
it’s now unclear if <code class="docutils literal notranslate"><span class="pre">c</span></code> should go before/after <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span></code>, or <code class="docutils literal notranslate"><span class="pre">d</span></code>. The
only rules that were set for <code class="docutils literal notranslate"><span class="pre">c</span></code> is that it must execute after <code class="docutils literal notranslate"><span class="pre">b</span></code> and
before <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>pytest doesn’t know where <code class="docutils literal notranslate"><span class="pre">c</span></code> should go in the case, so it should be assumed
that it could go anywhere between <code class="docutils literal notranslate"><span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>This isn’t necessarily bad, but it’s something to keep in mind. If the order
they execute in could affect the behavior a test is targetting, or could
otherwise influence the result of a test, then the order should be defined
explicitely in a way that allows pytest to linearize/”flatten” that order.</p>
</div>
<div class="section" id="autouse-fixtures-are-executed-first-within-their-scope">
<span id="autouse-order"></span><h3>Autouse fixtures are executed first within their scope<a class="headerlink" href="#autouse-fixtures-are-executed-first-within-their-scope" title="Permalink to this headline">¶</a></h3>
<p>Autouse fixtures are assumed to apply to every test that could reference them,
so they are executed before other fixtures in that scope. Fixtures that are
requested by autouse fixtures effectively become autouse fixtures themselves for
the tests that the real autouse fixture applies to.</p>
<p>So if fixture <code class="docutils literal notranslate"><span class="pre">a</span></code> is autouse and fixture <code class="docutils literal notranslate"><span class="pre">b</span></code> is not, but fixture <code class="docutils literal notranslate"><span class="pre">a</span></code>
requests fixture <code class="docutils literal notranslate"><span class="pre">b</span></code>, then fixture <code class="docutils literal notranslate"><span class="pre">b</span></code> will effectively be an autouse
fixture as well, but only for the tests that <code class="docutils literal notranslate"><span class="pre">a</span></code> applies to.</p>
<p>In the last example, the graph became unclear if <code class="docutils literal notranslate"><span class="pre">d</span></code> didn’t request <code class="docutils literal notranslate"><span class="pre">c</span></code>. But
if <code class="docutils literal notranslate"><span class="pre">c</span></code> was autouse, then <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> would effectively also be autouse
because <code class="docutils literal notranslate"><span class="pre">c</span></code> depends on them. As a result, they would all be shifted above
non-autouse fixtures within that scope.</p>
<p>So if the test file looked like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">d</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">e</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_order_and_g</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>the graph would look like this:</p>
<img alt="_images/test_fixtures_order_autouse.svg" class="align-center" src="_images/test_fixtures_order_autouse.svg" /><p>Because <code class="docutils literal notranslate"><span class="pre">c</span></code> can now be put above <code class="docutils literal notranslate"><span class="pre">d</span></code> in the graph, pytest can once again
linearize the graph to this:</p>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">c</span></code> makes <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> effectively autouse fixtures as
well.</p>
<p>Be careful with autouse, though, as an autouse fixture will automatically
execute for every test that can reach it, even if they don’t request it. For
example, consider this file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">c1</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c1&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">c2</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c2&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">c3</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">c1</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c3&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TestClassWithC1Request</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c3</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c1&quot;</span><span class="p">,</span> <span class="s2">&quot;c3&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TestClassWithoutC1Request</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">test_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c1&quot;</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Even though nothing in <code class="docutils literal notranslate"><span class="pre">TestClassWithoutC1Request</span></code> is requesting <code class="docutils literal notranslate"><span class="pre">c1</span></code>, it still
is executed for the tests inside it anyway:</p>
<img alt="_images/test_fixtures_order_autouse_multiple_scopes.svg" class="align-center" src="_images/test_fixtures_order_autouse_multiple_scopes.svg" /><p>But just because one autouse fixture requested a non-autouse fixture, that
doesn’t mean the non-autouse fixture becomes an autouse fixture for all contexts
that it can apply to. It only effectively becomes an auotuse fixture for the
contexts the real autouse fixture (the one that requested the non-autouse
fixture) can apply to.</p>
<p>For example, take a look at this test file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">order</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">c1</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c1&quot;</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">c2</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
    <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c2&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TestClassWithAutouse</span><span class="p">:</span>
    <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">c3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;c3&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_req</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">c1</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c2&quot;</span><span class="p">,</span> <span class="s2">&quot;c3&quot;</span><span class="p">,</span> <span class="s2">&quot;c1&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">test_no_req</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c2&quot;</span><span class="p">,</span> <span class="s2">&quot;c3&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">TestClassWithoutAutouse</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">test_req</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">c1</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;c1&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">test_no_req</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[]</span>
</pre></div>
</div>
<p>It would break down to something like this:</p>
<img alt="_images/test_fixtures_order_autouse_temp_effects.svg" class="align-center" src="_images/test_fixtures_order_autouse_temp_effects.svg" /><p>For <code class="docutils literal notranslate"><span class="pre">test_req</span></code> and <code class="docutils literal notranslate"><span class="pre">test_no_req</span></code> inside <code class="docutils literal notranslate"><span class="pre">TestClassWithAutouse</span></code>, <code class="docutils literal notranslate"><span class="pre">c3</span></code>
effectively makes <code class="docutils literal notranslate"><span class="pre">c2</span></code> an autouse fixture, which is why <code class="docutils literal notranslate"><span class="pre">c2</span></code> and <code class="docutils literal notranslate"><span class="pre">c3</span></code> are
executed for both tests, despite not being requested, and why <code class="docutils literal notranslate"><span class="pre">c2</span></code> and <code class="docutils literal notranslate"><span class="pre">c3</span></code>
are executed before <code class="docutils literal notranslate"><span class="pre">c1</span></code> for <code class="docutils literal notranslate"><span class="pre">test_req</span></code>.</p>
<p>If this made <code class="docutils literal notranslate"><span class="pre">c2</span></code> an <em>actual</em> autouse fixture, then <code class="docutils literal notranslate"><span class="pre">c2</span></code> would also execute
for the tests inside <code class="docutils literal notranslate"><span class="pre">TestClassWithoutAutouse</span></code>, since they can reference
<code class="docutils literal notranslate"><span class="pre">c2</span></code> if they wanted to. But it doesn’t, because from the perspective of the
<code class="docutils literal notranslate"><span class="pre">TestClassWithoutAutouse</span></code> tests, <code class="docutils literal notranslate"><span class="pre">c2</span></code> isn’t an autouse fixture, since they
can’t see <code class="docutils literal notranslate"><span class="pre">c3</span></code>.</p>
</div>
</div>
<div class="section" id="running-multiple-assert-statements-safely">
<h2>Running multiple <code class="docutils literal notranslate"><span class="pre">assert</span></code> statements safely<a class="headerlink" href="#running-multiple-assert-statements-safely" title="Permalink to this headline">¶</a></h2>
<p>Sometimes you may want to run multiple asserts after doing all that setup, which
makes sense as, in more complex systems, a single action can kick off multiple
behaviors. pytest has a convenient way of handling this and it combines a bunch
of what we’ve gone over so far.</p>
<p>All that’s needed is stepping up to a larger scope, then having the <strong>act</strong>
step defined as an autouse fixture, and finally, making sure all the fixtures
are targetting that highler level scope.</p>
<p>Let’s pull <a class="reference internal" href="#safe-fixture-structure"><span class="std std-ref">an example from above</span></a>, and tweak it a
bit. Let’s say that in addition to checking for a welcome message in the header,
we also want to check for a sign out button, and a link to the user’s profile.</p>
<p>Let’s take a look at how we can structure that so we can run multiple asserts
without having to repeat all those steps again.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For this example, certain fixtures (i.e. <code class="docutils literal notranslate"><span class="pre">base_url</span></code> and
<code class="docutils literal notranslate"><span class="pre">admin_credentials</span></code>) are implied to exist elsewhere. So for now, let’s
assume they exist, and we’re just not looking at them.</p>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># contents of tests/end_to_end/test_login.py</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urljoin</span>

<span class="kn">from</span> <span class="nn">selenium.webdriver</span> <span class="kn">import</span> <span class="n">Chrome</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="kn">from</span> <span class="nn">src.utils.pages</span> <span class="kn">import</span> <span class="n">LoginPage</span><span class="p">,</span> <span class="n">LandingPage</span>
<span class="kn">from</span> <span class="nn">src.utils</span> <span class="kn">import</span> <span class="n">AdminApiClient</span>
<span class="kn">from</span> <span class="nn">src.utils.data_types</span> <span class="kn">import</span> <span class="n">User</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">admin_client</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="n">admin_credentials</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AdminApiClient</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="o">**</span><span class="n">admin_credentials</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="n">admin_client</span><span class="p">):</span>
    <span class="n">_user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Susan&quot;</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;testuser-</span><span class="si">{</span><span class="n">uuid4</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s2">&quot;P4$$word&quot;</span><span class="p">)</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">create_user</span><span class="p">(</span><span class="n">_user</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">_user</span>
    <span class="n">admin_client</span><span class="o">.</span><span class="n">delete_user</span><span class="p">(</span><span class="n">_user</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">driver</span><span class="p">():</span>
    <span class="n">_driver</span> <span class="o">=</span> <span class="n">Chrome</span><span class="p">()</span>
    <span class="k">yield</span> <span class="n">_driver</span>
    <span class="n">_driver</span><span class="o">.</span><span class="n">quit</span><span class="p">()</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">landing_page</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">login</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">LandingPage</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TestLandingPageSuccess</span><span class="p">:</span>
    <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="n">autouse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">login</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="p">,</span> <span class="n">base_url</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="n">driver</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">urljoin</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="s2">&quot;/login&quot;</span><span class="p">))</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">LoginPage</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>
        <span class="n">page</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_name_in_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">landing_page</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">landing_page</span><span class="o">.</span><span class="n">header</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;Welcome, </span><span class="si">{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">!&quot;</span>

    <span class="k">def</span> <span class="nf">test_sign_out_button</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">landing_page</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">landing_page</span><span class="o">.</span><span class="n">sign_out_button</span><span class="o">.</span><span class="n">is_displayed</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_profile_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">landing_page</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="n">profile_href</span> <span class="o">=</span> <span class="n">urljoin</span><span class="p">(</span><span class="n">base_url</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;/profile?id=</span><span class="si">{</span><span class="n">user</span><span class="o">.</span><span class="n">profile_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">landing_page</span><span class="o">.</span><span class="n">profile_link</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s2">&quot;href&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">profile_href</span>
</pre></div>
</div>
<p>Notice that the methods are only referencing <code class="docutils literal notranslate"><span class="pre">self</span></code> in the signature as a
formality. No state is tied to the actual test class as it might be in the
<code class="docutils literal notranslate"><span class="pre">unittest.TestCase</span></code> framework. Everything is managed by the pytest fixture
system.</p>
<p>Each method only has to request the fixtures that it actually needs without
worrying about order. This is because the <strong>act</strong> fixture is an autouse fixture,
and it made sure all the other fixtures executed before it. There’s no more
changes of state that need to take place, so the tests are free to make as many
non-state-changing queries as they want without risking stepping on the toes of
the other tests.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">login</span></code> fixture is defined inside the class as well, because not every one
of the other tests in the module will be expecting a successful login, and the <strong>act</strong> may need to
be handled a little differently for another test class. For example, if we
wanted to write another test scenario around submitting bad credentials, we
could handle it by adding something like this to the test file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestLandingPageBadCredentials</span><span class="p">:</span>
    <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;class&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">faux_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="n">_user</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
        <span class="n">_user</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="s2">&quot;badpass&quot;</span>
        <span class="k">return</span> <span class="n">_user</span>

    <span class="k">def</span> <span class="nf">test_raises_bad_credentials_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">login_page</span><span class="p">,</span> <span class="n">faux_user</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">BadCredentialsException</span><span class="p">):</span>
            <span class="n">login_page</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">faux_user</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fixtures-can-introspect-the-requesting-test-context">
<span id="request-context"></span><h2>Fixtures can introspect the requesting test context<a class="headerlink" href="#fixtures-can-introspect-the-requesting-test-context" title="Permalink to this headline">¶</a></h2>
<p>Fixture functions can accept the <code class="xref py py-class docutils literal notranslate"><span class="pre">request</span></code> object
to introspect the “requesting” test function, class or module context.
Further extending the previous <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture example, let’s
read an optional server URL from the test module which uses our fixture:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of conftest.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">import</span> <span class="nn">smtplib</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">smtp_connection</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">server</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">module</span><span class="p">,</span> <span class="s2">&quot;smtpserver&quot;</span><span class="p">,</span> <span class="s2">&quot;smtp.gmail.com&quot;</span><span class="p">)</span>
    <span class="n">smtp_connection</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="mi">587</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">smtp_connection</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;finalizing </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">,</span> <span class="n">server</span><span class="p">))</span>
    <span class="n">smtp_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>We use the <code class="docutils literal notranslate"><span class="pre">request.module</span></code> attribute to optionally obtain an
<code class="docutils literal notranslate"><span class="pre">smtpserver</span></code> attribute from the test module.  If we just execute
again, nothing much has changed:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest -s -q --tb=no
FFfinalizing &lt;smtplib.SMTP object at 0xdeadbeef&gt; (smtp.gmail.com)

========================= short test summary info ==========================
FAILED test_module.py::test_ehlo - assert 0
FAILED test_module.py::test_noop - assert 0
<span class=" -Color -Color-Bold -Color-Bold-Red">2 failed</span><span class=" -Color -Color-Red"> in 0.12s</span>
</pre></div>
</div>
<p>Let’s quickly create another test module that actually sets the
server URL in its module namespace:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_anothersmtp.py</span>

<span class="n">smtpserver</span> <span class="o">=</span> <span class="s2">&quot;mail.python.org&quot;</span>  <span class="c1"># will be read by smtp fixture</span>


<span class="k">def</span> <span class="nf">test_showhelo</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">):</span>
    <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="n">smtp_connection</span><span class="o">.</span><span class="n">helo</span><span class="p">()</span>
</pre></div>
</div>
<p>Running it:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest -qq --tb=short test_anothersmtp.py
<span class=" -Color -Color-Red">F</span>                                                                    <span class=" -Color -Color-Red">[100%]</span>
================================= FAILURES =================================
<span class=" -Color -Color-Bold -Color-Bold-Red">______________________________ test_showhelo _______________________________</span>
<span class=" -Color -Color-Bold -Color-Bold-Red">test_anothersmtp.py</span>:6: in test_showhelo
    assert 0, smtp_connection.helo()
<span class=" -Color -Color-Bold -Color-Bold-Red">E   AssertionError: (250, b&#39;mail.python.org&#39;)</span>
<span class=" -Color -Color-Bold -Color-Bold-Red">E   assert 0</span>
------------------------- Captured stdout teardown -------------------------
finalizing &lt;smtplib.SMTP object at 0xdeadbeef&gt; (mail.python.org)
========================= short test summary info ==========================
FAILED test_anothersmtp.py::test_showhelo - AssertionError: (250, b&#39;mail....
</pre></div>
</div>
<p>voila! The <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture function picked up our mail server name
from the module namespace.</p>
</div>
<div class="section" id="using-markers-to-pass-data-to-fixtures">
<span id="using-markers"></span><h2>Using markers to pass data to fixtures<a class="headerlink" href="#using-markers-to-pass-data-to-fixtures" title="Permalink to this headline">¶</a></h2>
<p>Using the <code class="xref py py-class docutils literal notranslate"><span class="pre">request</span></code> object, a fixture can also access
markers which are applied to a test function. This can be useful to pass data
into a fixture from a test:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">fixt</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">marker</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">get_closest_marker</span><span class="p">(</span><span class="s2">&quot;fixt_data&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Handle missing marker in some way...</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">marker</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Do something with the data</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">fixt_data</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_fixt</span><span class="p">(</span><span class="n">fixt</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">fixt</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<div class="section" id="factories-as-fixtures">
<span id="fixture-factory"></span><h2>Factories as fixtures<a class="headerlink" href="#factories-as-fixtures" title="Permalink to this headline">¶</a></h2>
<p>The “factory as fixture” pattern can help in situations where the result
of a fixture is needed multiple times in a single test. Instead of returning
data directly, the fixture instead returns a function which generates the data.
This function can then be called multiple times in the test.</p>
<p>Factories can have parameters as needed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">make_customer_record</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">_make_customer_record</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;orders&quot;</span><span class="p">:</span> <span class="p">[]}</span>

    <span class="k">return</span> <span class="n">_make_customer_record</span>


<span class="k">def</span> <span class="nf">test_customer_records</span><span class="p">(</span><span class="n">make_customer_record</span><span class="p">):</span>
    <span class="n">customer_1</span> <span class="o">=</span> <span class="n">make_customer_record</span><span class="p">(</span><span class="s2">&quot;Lisa&quot;</span><span class="p">)</span>
    <span class="n">customer_2</span> <span class="o">=</span> <span class="n">make_customer_record</span><span class="p">(</span><span class="s2">&quot;Mike&quot;</span><span class="p">)</span>
    <span class="n">customer_3</span> <span class="o">=</span> <span class="n">make_customer_record</span><span class="p">(</span><span class="s2">&quot;Meredith&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the data created by the factory requires managing, the fixture can take care of that:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">make_customer_record</span><span class="p">():</span>

    <span class="n">created_records</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_make_customer_record</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Customer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">created_records</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span>

    <span class="k">yield</span> <span class="n">_make_customer_record</span>

    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">created_records</span><span class="p">:</span>
        <span class="n">record</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">test_customer_records</span><span class="p">(</span><span class="n">make_customer_record</span><span class="p">):</span>
    <span class="n">customer_1</span> <span class="o">=</span> <span class="n">make_customer_record</span><span class="p">(</span><span class="s2">&quot;Lisa&quot;</span><span class="p">)</span>
    <span class="n">customer_2</span> <span class="o">=</span> <span class="n">make_customer_record</span><span class="p">(</span><span class="s2">&quot;Mike&quot;</span><span class="p">)</span>
    <span class="n">customer_3</span> <span class="o">=</span> <span class="n">make_customer_record</span><span class="p">(</span><span class="s2">&quot;Meredith&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="parametrizing-fixtures">
<span id="fixture-parametrize"></span><h2>Parametrizing fixtures<a class="headerlink" href="#parametrizing-fixtures" title="Permalink to this headline">¶</a></h2>
<p>Fixture functions can be parametrized in which case they will be called
multiple times, each time executing the set of dependent tests, i. e. the
tests that depend on this fixture.  Test functions usually do not need
to be aware of their re-running.  Fixture parametrization helps to
write exhaustive functional tests for components which themselves can be
configured in multiple ways.</p>
<p>Extending the previous example, we can flag the fixture to create two
<code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture instances which will cause all tests using the fixture
to run twice.  The fixture function gets access to each parameter
through the special <code class="xref py py-class docutils literal notranslate"><span class="pre">request</span></code> object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of conftest.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">import</span> <span class="nn">smtplib</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;smtp.gmail.com&quot;</span><span class="p">,</span> <span class="s2">&quot;mail.python.org&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">smtp_connection</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">smtp_connection</span> <span class="o">=</span> <span class="n">smtplib</span><span class="o">.</span><span class="n">SMTP</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="mi">587</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">smtp_connection</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;finalizing </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">))</span>
    <span class="n">smtp_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The main change is the declaration of <code class="docutils literal notranslate"><span class="pre">params</span></code> with
<a class="reference internal" href="reference.html#pytest.fixture" title="pytest.fixture"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;pytest.fixture</span></code></a>, a list of values
for each of which the fixture function will execute and can access
a value via <code class="docutils literal notranslate"><span class="pre">request.param</span></code>.  No test function code needs to change.
So let’s just do another run:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest -q test_module.py
<span class=" -Color -Color-Red">FFFF</span>                                                                 <span class=" -Color -Color-Red">[100%]</span>
================================= FAILURES =================================
<span class=" -Color -Color-Bold -Color-Bold-Red">________________________ test_ehlo[smtp.gmail.com] _________________________</span>

smtp_connection = &lt;smtplib.SMTP object at 0xdeadbeef&gt;

    def test_ehlo(smtp_connection):
        response, msg = smtp_connection.ehlo()
        assert response == 250
        assert b&quot;smtp.gmail.com&quot; in msg
&gt;       assert 0  # for demo purposes
<span class=" -Color -Color-Bold -Color-Bold-Red">E       assert 0</span>

<span class=" -Color -Color-Bold -Color-Bold-Red">test_module.py</span>:7: AssertionError
<span class=" -Color -Color-Bold -Color-Bold-Red">________________________ test_noop[smtp.gmail.com] _________________________</span>

smtp_connection = &lt;smtplib.SMTP object at 0xdeadbeef&gt;

    def test_noop(smtp_connection):
        response, msg = smtp_connection.noop()
        assert response == 250
&gt;       assert 0  # for demo purposes
<span class=" -Color -Color-Bold -Color-Bold-Red">E       assert 0</span>

<span class=" -Color -Color-Bold -Color-Bold-Red">test_module.py</span>:13: AssertionError
<span class=" -Color -Color-Bold -Color-Bold-Red">________________________ test_ehlo[mail.python.org] ________________________</span>

smtp_connection = &lt;smtplib.SMTP object at 0xdeadbeef&gt;

    def test_ehlo(smtp_connection):
        response, msg = smtp_connection.ehlo()
        assert response == 250
&gt;       assert b&quot;smtp.gmail.com&quot; in msg
<span class=" -Color -Color-Bold -Color-Bold-Red">E       AssertionError: assert b&#39;smtp.gmail.com&#39; in b&#39;mail.python.org\nPIPELINING\nSIZE 51200000\nETRN\nSTARTTLS\nAUTH DIGEST-MD5 NTLM CRAM-MD5\nENHANCEDSTATUSCODES\n8BITMIME\nDSN\nSMTPUTF8\nCHUNKING&#39;</span>

<span class=" -Color -Color-Bold -Color-Bold-Red">test_module.py</span>:6: AssertionError
-------------------------- Captured stdout setup ---------------------------
finalizing &lt;smtplib.SMTP object at 0xdeadbeef&gt;
<span class=" -Color -Color-Bold -Color-Bold-Red">________________________ test_noop[mail.python.org] ________________________</span>

smtp_connection = &lt;smtplib.SMTP object at 0xdeadbeef&gt;

    def test_noop(smtp_connection):
        response, msg = smtp_connection.noop()
        assert response == 250
&gt;       assert 0  # for demo purposes
<span class=" -Color -Color-Bold -Color-Bold-Red">E       assert 0</span>

<span class=" -Color -Color-Bold -Color-Bold-Red">test_module.py</span>:13: AssertionError
------------------------- Captured stdout teardown -------------------------
finalizing &lt;smtplib.SMTP object at 0xdeadbeef&gt;
========================= short test summary info ==========================
FAILED test_module.py::test_ehlo[smtp.gmail.com] - assert 0
FAILED test_module.py::test_noop[smtp.gmail.com] - assert 0
FAILED test_module.py::test_ehlo[mail.python.org] - AssertionError: asser...
FAILED test_module.py::test_noop[mail.python.org] - assert 0
<span class=" -Color -Color-Bold -Color-Bold-Red">4 failed</span><span class=" -Color -Color-Red"> in 0.12s</span>
</pre></div>
</div>
<p>We see that our two test functions each ran twice, against the different
<code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> instances.  Note also, that with the <code class="docutils literal notranslate"><span class="pre">mail.python.org</span></code>
connection the second test fails in <code class="docutils literal notranslate"><span class="pre">test_ehlo</span></code> because a
different server string is expected than what arrived.</p>
<p>pytest will build a string that is the test ID for each fixture value
in a parametrized fixture, e.g. <code class="docutils literal notranslate"><span class="pre">test_ehlo[smtp.gmail.com]</span></code> and
<code class="docutils literal notranslate"><span class="pre">test_ehlo[mail.python.org]</span></code> in the above examples.  These IDs can
be used with <code class="docutils literal notranslate"><span class="pre">-k</span></code> to select specific cases to run, and they will
also identify the specific case when one is failing.  Running pytest
with <code class="docutils literal notranslate"><span class="pre">--collect-only</span></code> will show the generated IDs.</p>
<p>Numbers, strings, booleans and <code class="docutils literal notranslate"><span class="pre">None</span></code> will have their usual string
representation used in the test ID. For other objects, pytest will
make a string based on the argument name.  It is possible to customise
the string used in a test ID for a certain fixture value by using the
<code class="docutils literal notranslate"><span class="pre">ids</span></code> keyword argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_ids.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;spam&quot;</span><span class="p">,</span> <span class="s2">&quot;ham&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>


<span class="k">def</span> <span class="nf">test_a</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">idfn</span><span class="p">(</span><span class="n">fixture_value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fixture_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;eggs&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ids</span><span class="o">=</span><span class="n">idfn</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>


<span class="k">def</span> <span class="nf">test_b</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The above shows how <code class="docutils literal notranslate"><span class="pre">ids</span></code> can be either a list of strings to use or
a function which will be called with the fixture value and then
has to return a string to use.  In the latter case if the function
returns <code class="docutils literal notranslate"><span class="pre">None</span></code> then pytest’s auto-generated ID will be used.</p>
<p>Running the above tests results in the following test IDs being used:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest --collect-only
<span class=" -Color -Color-Bold">=========================== test session starts ============================</span>
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR
collected 10 items

&lt;Module test_anothersmtp.py&gt;
  &lt;Function test_showhelo[smtp.gmail.com]&gt;
  &lt;Function test_showhelo[mail.python.org]&gt;
&lt;Module test_ids.py&gt;
  &lt;Function test_a[spam]&gt;
  &lt;Function test_a[ham]&gt;
  &lt;Function test_b[eggs]&gt;
  &lt;Function test_b[1]&gt;
&lt;Module test_module.py&gt;
  &lt;Function test_ehlo[smtp.gmail.com]&gt;
  &lt;Function test_noop[smtp.gmail.com]&gt;
  &lt;Function test_ehlo[mail.python.org]&gt;
  &lt;Function test_noop[mail.python.org]&gt;

======================= 10 tests collected in 0.12s ========================
</pre></div>
</div>
</div>
<div class="section" id="using-marks-with-parametrized-fixtures">
<span id="fixture-parametrize-marks"></span><h2>Using marks with parametrized fixtures<a class="headerlink" href="#using-marks-with-parametrized-fixtures" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="reference.html#pytest.param" title="pytest.param"><code class="xref py py-func docutils literal notranslate"><span class="pre">pytest.param()</span></code></a> can be used to apply marks in values sets of parametrized fixtures in the same way
that they can be used with <a class="reference internal" href="parametrize.html#pytest-mark-parametrize"><span class="std std-ref">&#64;pytest.mark.parametrize</span></a>.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_fixture_marks.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pytest</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">marks</span><span class="o">=</span><span class="n">pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">skip</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">data_set</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>


<span class="k">def</span> <span class="nf">test_data</span><span class="p">(</span><span class="n">data_set</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Running this test will <em>skip</em> the invocation of <code class="docutils literal notranslate"><span class="pre">data_set</span></code> with value <code class="docutils literal notranslate"><span class="pre">2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ pytest test_fixture_marks.py -v
=========================== test session starts ============================
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR
collecting ... collected 3 items

test_fixture_marks.py::test_data[0] PASSED                           [ 33%]
test_fixture_marks.py::test_data[1] PASSED                           [ 66%]
test_fixture_marks.py::test_data[2] SKIPPED (unconditional skip)     [100%]

======================= 2 passed, 1 skipped in 0.12s =======================
</pre></div>
</div>
</div>
<div class="section" id="modularity-using-fixtures-from-a-fixture-function">
<span id="interdependent-fixtures"></span><h2>Modularity: using fixtures from a fixture function<a class="headerlink" href="#modularity-using-fixtures-from-a-fixture-function" title="Permalink to this headline">¶</a></h2>
<p>In addition to using fixtures in test functions, fixture functions
can use other fixtures themselves.  This contributes to a modular design
of your fixtures and allows re-use of framework-specific fixtures across
many projects.  As a simple example, we can extend the previous example
and instantiate an object <code class="docutils literal notranslate"><span class="pre">app</span></code> where we stick the already defined
<code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> resource into it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_appsetup.py</span>

<span class="kn">import</span> <span class="nn">pytest</span>


<span class="k">class</span> <span class="nc">App</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smtp_connection</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smtp_connection</span> <span class="o">=</span> <span class="n">smtp_connection</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">app</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">App</span><span class="p">(</span><span class="n">smtp_connection</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_smtp_connection_exists</span><span class="p">(</span><span class="n">app</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">app</span><span class="o">.</span><span class="n">smtp_connection</span>
</pre></div>
</div>
<p>Here we declare an <code class="docutils literal notranslate"><span class="pre">app</span></code> fixture which receives the previously defined
<code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture and instantiates an <code class="docutils literal notranslate"><span class="pre">App</span></code> object with it.  Let’s run it:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest -v test_appsetup.py
<span class=" -Color -Color-Bold">=========================== test session starts ============================</span>
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR
<span class=" -Color -Color-Bold">collecting ...</span> collected 2 items

test_appsetup.py::test_smtp_connection_exists[smtp.gmail.com] <span class=" -Color -Color-Green">PASSED</span> <span class=" -Color -Color-Green">[ 50%]</span>
test_appsetup.py::test_smtp_connection_exists[mail.python.org] <span class=" -Color -Color-Green">PASSED</span> <span class=" -Color -Color-Green">[100%]</span>

<span class=" -Color -Color-Green">============================ </span><span class=" -Color -Color-Bold -Color-Bold-Green">2 passed</span><span class=" -Color -Color-Green"> in 0.12s =============================</span>
</pre></div>
</div>
<p>Due to the parametrization of <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code>, the test will run twice with two
different <code class="docutils literal notranslate"><span class="pre">App</span></code> instances and respective smtp servers.  There is no
need for the <code class="docutils literal notranslate"><span class="pre">app</span></code> fixture to be aware of the <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code>
parametrization because pytest will fully analyse the fixture dependency graph.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">app</span></code> fixture has a scope of <code class="docutils literal notranslate"><span class="pre">module</span></code> and uses a
module-scoped <code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> fixture.  The example would still work if
<code class="docutils literal notranslate"><span class="pre">smtp_connection</span></code> was cached on a <code class="docutils literal notranslate"><span class="pre">session</span></code> scope: it is fine for fixtures to use
“broader” scoped fixtures but not the other way round:
A session-scoped fixture could not use a module-scoped one in a
meaningful way.</p>
</div>
<div class="section" id="automatic-grouping-of-tests-by-fixture-instances">
<span id="automatic-per-resource-grouping"></span><h2>Automatic grouping of tests by fixture instances<a class="headerlink" href="#automatic-grouping-of-tests-by-fixture-instances" title="Permalink to this headline">¶</a></h2>
<p>pytest minimizes the number of active fixtures during test runs.
If you have a parametrized fixture, then all the tests using it will
first execute with one instance and then finalizers are called
before the next fixture instance is created.  Among other things,
this eases testing of applications which create and use global state.</p>
<p>The following example uses two parametrized fixtures, one of which is
scoped on a per-module basis, and all the functions perform <code class="docutils literal notranslate"><span class="pre">print</span></code> calls
to show the setup/teardown flow:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_module.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;module&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mod1&quot;</span><span class="p">,</span> <span class="s2">&quot;mod2&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">modarg</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  SETUP modarg&quot;</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">param</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  TEARDOWN modarg&quot;</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">otherarg</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  SETUP otherarg&quot;</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">param</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  TEARDOWN otherarg&quot;</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_0</span><span class="p">(</span><span class="n">otherarg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  RUN test0 with otherarg&quot;</span><span class="p">,</span> <span class="n">otherarg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_1</span><span class="p">(</span><span class="n">modarg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  RUN test1 with modarg&quot;</span><span class="p">,</span> <span class="n">modarg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_2</span><span class="p">(</span><span class="n">otherarg</span><span class="p">,</span> <span class="n">modarg</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  RUN test2 with otherarg </span><span class="si">{}</span><span class="s2"> and modarg </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">otherarg</span><span class="p">,</span> <span class="n">modarg</span><span class="p">))</span>
</pre></div>
</div>
<p>Let’s run the tests in verbose mode and with looking at the print-output:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest -v -s test_module.py
<span class=" -Color -Color-Bold">=========================== test session starts ============================</span>
platform linux -- Python 3.x.y, pytest-6.x.y, py-1.x.y, pluggy-1.x.y -- $PYTHON_PREFIX/bin/python
cachedir: $PYTHON_PREFIX/.pytest_cache
rootdir: $REGENDOC_TMPDIR
<span class=" -Color -Color-Bold">collecting ...</span> collected 8 items

test_module.py::test_0[1]   SETUP otherarg 1
  RUN test0 with otherarg 1
PASSED  TEARDOWN otherarg 1

test_module.py::test_0[2]   SETUP otherarg 2
  RUN test0 with otherarg 2
PASSED  TEARDOWN otherarg 2

test_module.py::test_1[mod1]   SETUP modarg mod1
  RUN test1 with modarg mod1
PASSED
test_module.py::test_2[mod1-1]   SETUP otherarg 1
  RUN test2 with otherarg 1 and modarg mod1
PASSED  TEARDOWN otherarg 1

test_module.py::test_2[mod1-2]   SETUP otherarg 2
  RUN test2 with otherarg 2 and modarg mod1
PASSED  TEARDOWN otherarg 2

test_module.py::test_1[mod2]   TEARDOWN modarg mod1
  SETUP modarg mod2
  RUN test1 with modarg mod2
PASSED
test_module.py::test_2[mod2-1]   SETUP otherarg 1
  RUN test2 with otherarg 1 and modarg mod2
PASSED  TEARDOWN otherarg 1

test_module.py::test_2[mod2-2]   SETUP otherarg 2
  RUN test2 with otherarg 2 and modarg mod2
PASSED  TEARDOWN otherarg 2
  TEARDOWN modarg mod2


<span class=" -Color -Color-Green">============================ </span><span class=" -Color -Color-Bold -Color-Bold-Green">8 passed</span><span class=" -Color -Color-Green"> in 0.12s =============================</span>
</pre></div>
</div>
<p>You can see that the parametrized module-scoped <code class="docutils literal notranslate"><span class="pre">modarg</span></code> resource caused an
ordering of test execution that lead to the fewest possible “active” resources.
The finalizer for the <code class="docutils literal notranslate"><span class="pre">mod1</span></code> parametrized resource was executed before the
<code class="docutils literal notranslate"><span class="pre">mod2</span></code> resource was setup.</p>
<p>In particular notice that test_0 is completely independent and finishes first.
Then test_1 is executed with <code class="docutils literal notranslate"><span class="pre">mod1</span></code>, then test_2 with <code class="docutils literal notranslate"><span class="pre">mod1</span></code>, then test_1
with <code class="docutils literal notranslate"><span class="pre">mod2</span></code> and finally test_2 with <code class="docutils literal notranslate"><span class="pre">mod2</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">otherarg</span></code> parametrized resource (having function scope) was set up before
and teared down after every test that used it.</p>
</div>
<div class="section" id="use-fixtures-in-classes-and-modules-with-usefixtures">
<span id="usefixtures"></span><h2>Use fixtures in classes and modules with <code class="docutils literal notranslate"><span class="pre">usefixtures</span></code><a class="headerlink" href="#use-fixtures-in-classes-and-modules-with-usefixtures" title="Permalink to this headline">¶</a></h2>
<p>Sometimes test functions do not directly need access to a fixture object.
For example, tests may require to operate with an empty directory as the
current working directory but otherwise do not care for the concrete
directory.  Here is how you can use the standard <a class="reference external" href="http://docs.python.org/library/tempfile.html">tempfile</a> and pytest fixtures to
achieve it.  We separate the creation of the fixture into a conftest.py
file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of conftest.py</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">cleandir</span><span class="p">():</span>
    <span class="n">old_cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">newpath</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">newpath</span><span class="p">)</span>
    <span class="k">yield</span>
    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">old_cwd</span><span class="p">)</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">newpath</span><span class="p">)</span>
</pre></div>
</div>
<p>and declare its use in a test module via a <code class="docutils literal notranslate"><span class="pre">usefixtures</span></code> marker:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of test_setenv.py</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pytest</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;cleandir&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TestDirectoryInit</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">test_cwd_starts_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span> <span class="o">==</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;myfile&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_cwd_again_starts_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span> <span class="o">==</span> <span class="p">[]</span>
</pre></div>
</div>
<p>Due to the <code class="docutils literal notranslate"><span class="pre">usefixtures</span></code> marker, the <code class="docutils literal notranslate"><span class="pre">cleandir</span></code> fixture
will be required for the execution of each test method, just as if
you specified a “cleandir” function argument to each of them.  Let’s run it
to verify our fixture is activated and the tests pass:</p>
<div class="highlight-pytest notranslate"><div class="highlight"><pre><span></span>$ pytest -q
<span class=" -Color -Color-Green">..</span>                                                                   <span class=" -Color -Color-Green">[100%]</span>
<span class=" -Color -Color-Bold -Color-Bold-Green">2 passed</span><span class=" -Color -Color-Green"> in 0.12s</span>
</pre></div>
</div>
<p>You can specify multiple fixtures like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;cleandir&quot;</span><span class="p">,</span> <span class="s2">&quot;anotherfixture&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>and you may specify fixture usage at the test module level using <a class="reference internal" href="reference.html#globalvar-pytestmark"><code class="xref std std-globalvar docutils literal notranslate"><span class="pre">pytestmark</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pytestmark</span> <span class="o">=</span> <span class="n">pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;cleandir&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to put fixtures required by all tests in your project
into an ini-file:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="c1"># content of pytest.ini</span>
<span class="k">[pytest]</span>
<span class="na">usefixtures</span> <span class="o">=</span> <span class="s">cleandir</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note this mark has no effect in <strong>fixture functions</strong>. For example,
this <strong>will not work as expected</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">usefixtures</span><span class="p">(</span><span class="s2">&quot;my_other_fixture&quot;</span><span class="p">)</span>
<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">my_fixture_that_sadly_wont_use_my_other_fixture</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Currently this will not generate any error or warning, but this is intended
to be handled by <a class="reference external" href="https://github.com/pytest-dev/pytest/issues/3664">#3664</a>.</p>
</div>
</div>
<div class="section" id="overriding-fixtures-on-various-levels">
<span id="override-fixtures"></span><h2>Overriding fixtures on various levels<a class="headerlink" href="#overriding-fixtures-on-various-levels" title="Permalink to this headline">¶</a></h2>
<p>In relatively large test suite, you most likely need to <code class="docutils literal notranslate"><span class="pre">override</span></code> a <code class="docutils literal notranslate"><span class="pre">global</span></code> or <code class="docutils literal notranslate"><span class="pre">root</span></code> fixture with a <code class="docutils literal notranslate"><span class="pre">locally</span></code>
defined one, keeping the test code readable and maintainable.</p>
<div class="section" id="override-a-fixture-on-a-folder-conftest-level">
<h3>Override a fixture on a folder (conftest) level<a class="headerlink" href="#override-a-fixture-on-a-folder-conftest-level" title="Permalink to this headline">¶</a></h3>
<p>Given the tests file structure is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

    <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/conftest.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">username</span><span class="p">():</span>
            <span class="k">return</span> <span class="s1">&#39;username&#39;</span>

    <span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_something.py</span>
        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">username</span> <span class="o">==</span> <span class="s1">&#39;username&#39;</span>

    <span class="n">subfolder</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

        <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
            <span class="c1"># content of tests/subfolder/conftest.py</span>
            <span class="kn">import</span> <span class="nn">pytest</span>

            <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
            <span class="k">def</span> <span class="nf">username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;overridden-&#39;</span> <span class="o">+</span> <span class="n">username</span>

        <span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
            <span class="c1"># content of tests/subfolder/test_something.py</span>
            <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">username</span> <span class="o">==</span> <span class="s1">&#39;overridden-username&#39;</span>
</pre></div>
</div>
<p>As you can see, a fixture with the same name can be overridden for certain test folder level.
Note that the <code class="docutils literal notranslate"><span class="pre">base</span></code> or <code class="docutils literal notranslate"><span class="pre">super</span></code> fixture can be accessed from the <code class="docutils literal notranslate"><span class="pre">overriding</span></code>
fixture easily - used in the example above.</p>
</div>
<div class="section" id="override-a-fixture-on-a-test-module-level">
<h3>Override a fixture on a test module level<a class="headerlink" href="#override-a-fixture-on-a-test-module-level" title="Permalink to this headline">¶</a></h3>
<p>Given the tests file structure is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

    <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/conftest.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">username</span><span class="p">():</span>
            <span class="k">return</span> <span class="s1">&#39;username&#39;</span>

    <span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_something.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;overridden-&#39;</span> <span class="o">+</span> <span class="n">username</span>

        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">username</span> <span class="o">==</span> <span class="s1">&#39;overridden-username&#39;</span>

    <span class="n">test_something_else</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_something_else.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;overridden-else-&#39;</span> <span class="o">+</span> <span class="n">username</span>

        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">username</span> <span class="o">==</span> <span class="s1">&#39;overridden-else-username&#39;</span>
</pre></div>
</div>
<p>In the example above, a fixture with the same name can be overridden for certain test module.</p>
</div>
<div class="section" id="override-a-fixture-with-direct-test-parametrization">
<h3>Override a fixture with direct test parametrization<a class="headerlink" href="#override-a-fixture-with-direct-test-parametrization" title="Permalink to this headline">¶</a></h3>
<p>Given the tests file structure is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

    <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/conftest.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">username</span><span class="p">():</span>
            <span class="k">return</span> <span class="s1">&#39;username&#39;</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">other_username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;other-&#39;</span> <span class="o">+</span> <span class="n">username</span>

    <span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_something.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;directly-overridden-username&#39;</span><span class="p">])</span>
        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">username</span> <span class="o">==</span> <span class="s1">&#39;directly-overridden-username&#39;</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;directly-overridden-username-other&#39;</span><span class="p">])</span>
        <span class="k">def</span> <span class="nf">test_username_other</span><span class="p">(</span><span class="n">other_username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">other_username</span> <span class="o">==</span> <span class="s1">&#39;other-directly-overridden-username-other&#39;</span>
</pre></div>
</div>
<p>In the example above, a fixture value is overridden by the test parameter value. Note that the value of the fixture
can be overridden this way even if the test doesn’t use it directly (doesn’t mention it in the function prototype).</p>
</div>
<div class="section" id="override-a-parametrized-fixture-with-non-parametrized-one-and-vice-versa">
<h3>Override a parametrized fixture with non-parametrized one and vice versa<a class="headerlink" href="#override-a-parametrized-fixture-with-non-parametrized-one-and-vice-versa" title="Permalink to this headline">¶</a></h3>
<p>Given the tests file structure is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tests</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>

    <span class="n">conftest</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/conftest.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">])</span>
        <span class="k">def</span> <span class="nf">parametrized_username</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">non_parametrized_username</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;username&#39;</span>

    <span class="n">test_something</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_something.py</span>
        <span class="kn">import</span> <span class="nn">pytest</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
        <span class="k">def</span> <span class="nf">parametrized_username</span><span class="p">():</span>
            <span class="k">return</span> <span class="s1">&#39;overridden-username&#39;</span>

        <span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">])</span>
        <span class="k">def</span> <span class="nf">non_parametrized_username</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">request</span><span class="o">.</span><span class="n">param</span>

        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">parametrized_username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">parametrized_username</span> <span class="o">==</span> <span class="s1">&#39;overridden-username&#39;</span>

        <span class="k">def</span> <span class="nf">test_parametrized_username</span><span class="p">(</span><span class="n">non_parametrized_username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">non_parametrized_username</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]</span>

    <span class="n">test_something_else</span><span class="o">.</span><span class="n">py</span>
        <span class="c1"># content of tests/test_something_else.py</span>
        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">parametrized_username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">parametrized_username</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">test_username</span><span class="p">(</span><span class="n">non_parametrized_username</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">non_parametrized_username</span> <span class="o">==</span> <span class="s1">&#39;username&#39;</span>
</pre></div>
</div>
<p>In the example above, a parametrized fixture is overridden with a non-parametrized version, and
a non-parametrized fixture is overridden with a parametrized version for certain test module.
The same applies for the test folder level obviously.</p>
</div>
</div>
<div class="section" id="using-fixtures-from-other-projects">
<h2>Using fixtures from other projects<a class="headerlink" href="#using-fixtures-from-other-projects" title="Permalink to this headline">¶</a></h2>
<p>Usually projects that provide pytest support will use <a class="reference internal" href="writing_plugins.html#setuptools-entry-points"><span class="std std-ref">entry points</span></a>,
so just installing those projects into an environment will make those fixtures available for use.</p>
<p>In case you want to use fixtures from a project that does not use entry points, you can
define <a class="reference internal" href="reference.html#globalvar-pytest_plugins"><code class="xref std std-globalvar docutils literal notranslate"><span class="pre">pytest_plugins</span></code></a> in your top <code class="docutils literal notranslate"><span class="pre">conftest.py</span></code> file to register that module
as a plugin.</p>
<p>Suppose you have some fixtures in <code class="docutils literal notranslate"><span class="pre">mylibrary.fixtures</span></code> and you want to reuse them into your
<code class="docutils literal notranslate"><span class="pre">app/tests</span></code> directory.</p>
<p>All you need to do is to define <a class="reference internal" href="reference.html#globalvar-pytest_plugins"><code class="xref std std-globalvar docutils literal notranslate"><span class="pre">pytest_plugins</span></code></a> in <code class="docutils literal notranslate"><span class="pre">app/tests/conftest.py</span></code>
pointing to that module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pytest_plugins</span> <span class="o">=</span> <span class="s2">&quot;mylibrary.fixtures&quot;</span>
</pre></div>
</div>
<p>This effectively registers <code class="docutils literal notranslate"><span class="pre">mylibrary.fixtures</span></code> as a plugin, making all its fixtures and
hooks available to tests in <code class="docutils literal notranslate"><span class="pre">app/tests</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sometimes users will <em>import</em> fixtures from other projects for use, however this is not
recommended: importing fixtures into a module will register them in pytest
as <em>defined</em> in that module.</p>
<p>This has minor consequences, such as appearing multiple times in <code class="docutils literal notranslate"><span class="pre">pytest</span> <span class="pre">--help</span></code>,
but it is not <strong>recommended</strong> because this behavior might change/stop working
in future versions.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015–2020, holger krekel and pytest-dev team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  <script src="_static/version_warning_offset.js"></script>

  </body>
</html>